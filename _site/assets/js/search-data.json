{"0": {
    "doc": "Week 1",
    "title": "Week 1",
    "content": " ",
    "url": "/week/1.html",
    "relUrl": "/week/1.html"
  },"1": {
    "doc": "Week 10",
    "title": "Week 10",
    "content": " ",
    "url": "/week/10.html",
    "relUrl": "/week/10.html"
  },"2": {
    "doc": "Week 11",
    "title": "Week 11",
    "content": " ",
    "url": "/week/11.html",
    "relUrl": "/week/11.html"
  },"3": {
    "doc": "Week 12",
    "title": "Week 12",
    "content": " ",
    "url": "/week/12.html",
    "relUrl": "/week/12.html"
  },"4": {
    "doc": "Week 13",
    "title": "Week 13",
    "content": " ",
    "url": "/week/13.html",
    "relUrl": "/week/13.html"
  },"5": {
    "doc": "Week 14",
    "title": "Week 14",
    "content": " ",
    "url": "/week/14.html",
    "relUrl": "/week/14.html"
  },"6": {
    "doc": "Week 2",
    "title": "Week 2",
    "content": " ",
    "url": "/week/2.html",
    "relUrl": "/week/2.html"
  },"7": {
    "doc": "Week 3",
    "title": "Week 3",
    "content": " ",
    "url": "/week/3.html",
    "relUrl": "/week/3.html"
  },"8": {
    "doc": "Week 4",
    "title": "Week 4",
    "content": " ",
    "url": "/week/4.html",
    "relUrl": "/week/4.html"
  },"9": {
    "doc": "Week 5",
    "title": "Week 5",
    "content": " ",
    "url": "/week/5.html",
    "relUrl": "/week/5.html"
  },"10": {
    "doc": "Week 6",
    "title": "Week 6",
    "content": " ",
    "url": "/week/6.html",
    "relUrl": "/week/6.html"
  },"11": {
    "doc": "Week 7",
    "title": "Week 7",
    "content": " ",
    "url": "/week/7.html",
    "relUrl": "/week/7.html"
  },"12": {
    "doc": "Week 8",
    "title": "Week 8",
    "content": " ",
    "url": "/week/8.html",
    "relUrl": "/week/8.html"
  },"13": {
    "doc": "Week 9",
    "title": "Week 9",
    "content": " ",
    "url": "/week/9.html",
    "relUrl": "/week/9.html"
  },"14": {
    "doc": "Readings",
    "title": "Readings",
    "content": "Please read the following short articles: . | Absolute Beginners Guide to Slaying APIs using Python | Python API Tutorial | Intermediate Python API Tutorial | . For more information about possible APIs, you can look at a long list here . All of these are tutorials that explain what an API is and how to use a couple of common ones. As you read these, think about the kinds of things you might use APIs for. What might you want to use an API for? What APIs do you want to exist? Browse through the long list of APIs and think about what other APIs you might want to use. Summarize your thoughts on APIs, and what they are useful for, and what they are not useful for, on D2L. Then, write down a question. It can be a point of confusion or a needed clarification about anything in the readings, or it can be something interesting that you thought about while you were reading that goes beyond the reading. Or it can be an example you thought about, or a connection you made between the concepts here and other parts of your life. But write down a good question or example based on what you were thinking about while reading. The summary + question for this week can be submitted on D2L. ",
    "url": "/readings/apis.html",
    "relUrl": "/readings/apis.html"
  },"15": {
    "doc": "Studio",
    "title": "Advice",
    "content": "What follows is just advice for doing it. You don’t have to follow my advice. Do whatever you want. This is just my experience in doing this, and you might want to do it differently. Work together . You should work in small groups on this studio. Groups of 2-4 people. Work together to create the story and to write the code. But don’t divide up the work; that’s no fun. Everyone should work on all parts. If you need to come up with the next step of the story, then get the whole group together and brainstorm the story. If you need to implement a choice in Python, then get the whole group together and work on it until it looks how you want it to. Have one person on the keyboard sharing their screen, and the rest looking over helping (navigating). Since we don’t have a good way of sharing files with one another yet, having one person drive is the easiest way to work on the story together. Choosing a story . If you are good at coming up with stories, then you don’t need this advice. If you aren’t awesome at it, then the easiest way to start is to start with an existing story and set of characters. For example, I’d probably start with the Avengers movies because I like them and they have LOTS of interesting stories. Pick a story that you already know a lot about to start with, and begin there. It could be from a movie, a book, a game, a TV show, a fairy tale, or real life. It could be a true story, or it could be made up. The easiest place to start is to tell that story. Then think about different places where people in the story could have made different choices, and things would have turned out differently. Those are great places to ask the user to make a choice. You’ll also have to write the alternative outcomes / stories. Diagram . Once you’ve got an idea for a story, I’d recommend creating a diagram. Put major events in circles on a piece of paper, and then draw a line between them to signify order. Figure out what kinds of choices can be made, and add other outcomes as additional circles. It will really help to have a diagram that you can refer back to as you work on the programming. Here is a very simple example of a diagram. It is perfectly OK to use pencil and paper. It is also OK to find a computer program to draw the diagram, and then share your screen as you do that. It is up to you what tools you want to use, and how you use them. I think you will find that using external tools (like pencil and paper) is a very important part of computer programming. Start simple, then expand . Don’t try to do everything at once. Start with as simple of a story as you can, and then build from there. For example, the first thing you should do is probably just have it print out a single story block, and then end. Get that working first. Then write your first choice – get the coding working for a single choice, that prints out something silly, but different based on the choice the user made. Once that works correctly when you run it, then you can replace the silly text with the actual story you want to be telling. And then you can add more choices. But don’t move on add anything new until everything you’ve already written works correctly. Keep testing small bits of the program as you go! . This also means that you don’t need to have the whole story written before you start writing your program. Get the first bit of it written, then try to make it work as a computer program. Alternate between writing story and writing code. If you try to do it all at once, it’s easy to get bogged down in unimportant details. By going back and forth between story writing and coding, you make sure that each piece works well before you move on. Submit on D2L . When you are done, please submit screenshots of your code working and the .py file with the program you created to D2L under Assignments. At least one person in the group needs to submit something. ",
    "url": "/studios/choose_your_own_adventure.html#advice",
    "relUrl": "/studios/choose_your_own_adventure.html#advice"
  },"16": {
    "doc": "Studio",
    "title": "Studio",
    "content": "The goal for today’s studio is to write an interactive Choose Your Own Adventure story. In these types of stories, the reader gets to choose what happens next in the story based on a set series of choices. When you run the program, it should show the beginning of the story, ask the user to make a choice from a few choices that you give them, and then continue the story based on that choice. And so on. If I run the program again, it will start in the same place, but if I make different choices, the story should go in a different direction. Be creative! You can look at avengers.py from Tuesday’s lab as a place to start. You must work in a small group on this project. Form a group of 2-4 people and work together on this project. Who you work with is up to you, but you can’t work alone. ",
    "url": "/studios/choose_your_own_adventure.html",
    "relUrl": "/studios/choose_your_own_adventure.html"
  },"17": {
    "doc": "Using command line",
    "title": "Command line applications",
    "content": "Both MacOS and Windows come with command line applications preinstalled. In this class we’ll be using: . Windows: PowerShell MacOS: Terminal . ",
    "url": "/reference/command_line.html#command-line-applications",
    "relUrl": "/reference/command_line.html#command-line-applications"
  },"18": {
    "doc": "Using command line",
    "title": "Navigating through folders",
    "content": "The most important thing to remember about command line is that it only will let you do things with files if it thinks it’s in the same location the file is. That means if the file you want to work with is in the Downloads folder, then command line also needs to be pointed at the Downloads folder before you can do anything with that file. Folder structures on computers are nested on multiple levels. It might look like this: . geier - Desktop - Documents - - Photos - - School - - - MI 250 - Downloads . In this example, the MI 250 folder is inside the School folder, which is inside Documents, which is inside the top level ‘geier’ folder. To navigate to the MI 250 folder, you have to go through all of its ‘parent’ folders first. By default, both PowerShell and Terminal start at a folder named after the computer’s user. Desktop, Downloads, and Documents as well as a few other folders are there by default. When you make a new folder, you need to pay attention to where you’re putting it in this structure so you can find it again. In command line, to navigate to a folder, you use cd, which stands for ‘change directory’. cd is not case sensitive (you don’t have to use capital letters). To get to the MI 250 folder, I would give this command: . cd documents/school/\"mi 250\" . Getting to a folder fast . There’s a neat trick that works in both Windows and Mac OS to get to the folder you want to go to within typing in the full path to get there. | Type cd in command line - make sure there is a space after cd. | Open up the folder you want in File Explorer (Windows) or Finder (Mac OS) – the normal way of viewing folders. | Drag the folder over to the command line window. When you release your mouse on top of the command line window, that should put the full directory name after cd. | . Other useful commands for navigation . A couple of other useful command line commands: . | You can get a list of the files in the current directory with the ls command | You can move up one directory (to the parent directory) with the command cd .. | If you start typing the name of a file or directory, you can hit the Tab key and it will try to automatically finish typing the name of that file/directory for you. | . To learn more about navigating through folders with command line, you can read Navigating the Command Line (which I recommend if you haven’t worked with the command line before). ",
    "url": "/reference/command_line.html#navigating-through-folders",
    "relUrl": "/reference/command_line.html#navigating-through-folders"
  },"19": {
    "doc": "Using command line",
    "title": "Python’s interactive mode (and getting out of it)",
    "content": "To run Python programs in command line, you type python (Windows) or python3 (MacOS) followed by the name of the program. So to run eliza.py, you’d type python eliza.py and that will run the program. If you only type python without giving it a program to run, it will go into interactive mode. You can use this mode to try out short snippets of code to see if it works. We won’t be using it much in this class, though. You’ll know you’re in this mode if you see three arrows (&gt;&gt;&gt;) on the last line. To get out of this mode, type quit() and hit Enter. On Windows, you can also hit Control+Z and then Enter. On MacOS, you can use Control+D. ",
    "url": "/reference/command_line.html#pythons-interactive-mode-and-getting-out-of-it",
    "relUrl": "/reference/command_line.html#pythons-interactive-mode-and-getting-out-of-it"
  },"20": {
    "doc": "Using command line",
    "title": "More tips",
    "content": "Saving time . When the space next to the prompt in command line is empty (you haven’t typed anything yet), you can hit the “up” arrow on your keyboard - this will autopopulate the last command that was given. If you hit the up arrow multiple times, it will cycle through all of the previous commands you’ve given it. The down arrow goes the opposite direction through the commands. ",
    "url": "/reference/command_line.html#more-tips",
    "relUrl": "/reference/command_line.html#more-tips"
  },"21": {
    "doc": "Using command line",
    "title": "More resources",
    "content": "More information about command line (or ‘shell’) commands can be found here. ",
    "url": "/reference/command_line.html#more-resources",
    "relUrl": "/reference/command_line.html#more-resources"
  },"22": {
    "doc": "Using command line",
    "title": "Using command line",
    "content": "You’ll be using command line a lot in this class to run Python programs. Here are some tips and tricks to help you out. ",
    "url": "/reference/command_line.html",
    "relUrl": "/reference/command_line.html"
  },"23": {
    "doc": "Lab",
    "title": "Print - outputting information",
    "content": "You learned a bit about the print statement in the readings this week. You’ll be using it a lot this semester; we’ll start practicing now. Exercise 1: Hello world . The first program that almost everyone writes when they’re learning how to program is called “Hello World”. The idea is to create a program that communicates with a user by giving them a simple piece of information – in this case, it says hello. I’ve already written a simple version of this program, and its called “hello.py”. First, run this program in command line with: . python hello.py . Remember to use python3 if you’re on a Mac! If you need a refresher on running Python programs, go back to Lab 1. Open up the hello.py in your text editor. What does it look like? What do you think print does? . Exercise 2: Say hello to someone . Next we will practice modifying this program. Last week, we opened program files in a text editor, edited them, and then ran them on the command line. We are going to do that again this week; however, this week we are going to be making more careful edits that do more than we did last week. Have the program, when you run it, say hello to a specific person – use the name of the person who is the driver in your pair today. To do this, you want to put the drvier’s name into the print statement. So if the driver’s name is David Bowie, then the program should print out . Hello David Bowie . Exercise 3: Add more information . Next, have hello.py print out some additional information. To do this, you’ll need to add additional print statements. Each print statement prints out one line of output. You want the program to introduce the person who is navigating to the driver, so that when the driver runs the program, they learn more about their partner for the lab. So, for example, the program could output something like: . Hello David Bowie I am Ziggy Stardust and I am a sophomore media and information major. I enjoy helping people use technology. I hope to become a user experience professional when I graduate. You can always go back to the readings and videos from this week to remind yourself about print statements and how to use them. Make sure that all of this information is not on one line, but instead appears on multiple different lines. Also remember that you can print a blank line using print(\"\"). Change places . Now is a good time to switch places with your partner. Before you do, remember to take a screenshot or two of hello.py with the changes you made running in command line. The new driver will need to download the Git repository for today’s lab on their computer now - go to the top of this page if you need a refresher on how to do that. ",
    "url": "/labs/control_flow.html#print---outputting-information",
    "relUrl": "/labs/control_flow.html#print---outputting-information"
  },"24": {
    "doc": "Lab",
    "title": "Variables – storing information for later use",
    "content": "Now that we’ve had a chance to practice printing out information, let’s use variables to change up what we are displaying. To do this, we will first put pieces of information into variables. Then we’ll use the print command to print out information that fills in blanks with the contents of a variable. We will start with the file mad-libs.py. The first thing you should do is to run the program. What does it print out? . Exercise 4: Words . Now open up the file, and notice that at the top of the file, there are some variables. The name of each variable is a prompt, like “body_part” or “action”. Ask the navigator to come up with new words to respond to the prompts by reading the variable names to them. Replace what’s in there now with the new words. Run the program again, and notice what changed. Why did that happen? . Notice what running the program does – it stores specific words (in \"\" quotes) into variables like body_part and action. Then, when it prints out, instead of print out the word action, it prints out whatever is stored in the variable named action. This is how variables work – you store something in them, and then python will substitute whatever is stored in them as it runs. Exercise 5: New Mad-libs . Pick a new movie quote. It can be from any movie you want, though if you like the Guardians of the Galaxy theme, here are some of the memorable quotes. Add a new print statement that prints out the quote. Then choose a word to replace, and create a variable to hold the word that replaces it. Try to get it so that you can change the value of the variable at the top of the file, and it will change what is printed out. Change places . This is another good place to switch from driver to navigator, and vice versa. When the next exercise uses a different file, that’s often a good time to trade places. ",
    "url": "/labs/control_flow.html#variables--storing-information-for-later-use",
    "relUrl": "/labs/control_flow.html#variables--storing-information-for-later-use"
  },"25": {
    "doc": "Lab",
    "title": "Getting input from users",
    "content": "So far, every time we run the programs we’ve worked on, they do the same thing. That’s not a bad thing – some of the most interesting programs do the same thing every time they are run (like display tomorrow’s weather, or figure out a prediction, or render a 3D movie). But the most interesting programs are interactive – they ask the user for input, and then change what they do based on what the user does. Up to this point, the way you made the program do something different was to edit the program. That is, you were both being the programmer (who edits the program) and the user (who tells the program what to do). Starting now, we are going to separate those roles. You will write a program that asks the user – which may be you, or it may be other people – for input. Then the program will do interesting things with that user input. What this means is that, starting now, we are going to be writing programs that are not just for ourselves, but that can also be used by other people for their own purposes. This is one of the most interesting and exciting parts of programming – that other people can take your program and do interesting things with it. Today, we are going to begin with the simplest way to get user input – through the keyboard using input(). First, notice that there is a second mad-libs file, mad-libs-input.py. Run that program using python mad-libs-input.py. Ask the navigator for words based on the prompts, and enter them into the program as it runs. Then observe what comes out. This is a simple interactive program that asks for input (words) and then changes what it says based on what the user inputs. Next, run it again, and type in different things. What happens? . Exercise 6: Update the Mad-Lib . The original source of that mad-lib is the song “Space Oddity” by David Bowie. It’s an old song from the late 60s, written during the space race. For this challenge, change the mad-lib. Pick a different song that YOU like, and use that song to create the mad-lib. Feel free to edit this file; you don’t need to create a whole new program. Your new mad-lib should ask the user for new types of words. They should be words that fit into the song you choose, not the types of words that I asked for. Take what the user enters and have the program store them into variables. Then print out the lyrics to your song, replacing key words with words that the user inputs. Notice how you store things. The code says variable = input(\"...\"). You pick a variable and put it on the left side of the equals sign. Then you put what you want to put into the variable on the right side. Previously, we put actual words in quotation marks – the quotation marks tell Python that we want the words inside to be reproduced as-is. In this program, instead of putting quotation marks, we use the command input(\"...\") to get input from the user. The text inside the parentheses () is the prompt that the user gets when they run the program. Whatever the user types in, it stores into the variable on the left side of the equals sign. (Question: What happens if you put the input(\"...\") command, but don’t include variable = before it? Answer: It asks the user for input, but then the program immediately forgets what the user typed because it didn’t have anywhere to store it.) . Note: The code for your program – the file you edit in your text editor – should not have the actual words in it like it did in exercise 4. Instead, it should just contain instructions to ask the user for words. Change places . This is another good time to change places with your partner. ",
    "url": "/labs/control_flow.html#getting-input-from-users",
    "relUrl": "/labs/control_flow.html#getting-input-from-users"
  },"26": {
    "doc": "Lab",
    "title": "Not always doing the same thing",
    "content": "Next, we will work with basic conditionals. There are three kinds of conditional statements: if, elif, and else. They all cause things to to cause different things to happen in different situations. To begin, let’s run the Avengers program: . python avengers.py . Now go through and read the source code for the Avengers program – open up avengers.py in your text editor. Notice that when you run the program, not every line in the source code gets printed out; instead, it depends on what the user of the program types in. Pay particular attention to how things are indented. Indentation is really important in Python. Indentation controls which lines are part of the if statement and which ones are not. When if, elif, and else statements are all indented at the same level, this connects them together as one big statement with multiple branches of possibility. Exercise 7: Try different inputs . Run the avengers program multiple times. Give different answers to the prompts. Try out all three avengers as an answer to the first prompt. What happens? . Now look at the code. Why is that happening? What is each part of the statement doing? What are the differences between if, elif, and else? (Hint: elif is short for “else if”.) . Also, as you tried things, did anything not work as you expected? Make a list of ‘bugs’ – problems with the program where it doesn’t work the way you expect it to. What you’re doing here is testing the program to understand how it works and thinking about how you could improve it. Exercise 8: What Happens when Captain America tries? . Next, modify the code. What happens when Captain America tries to pick up the hammer? Put some print statements in the right place to tell the story of what happens when Captain America tries to pick up the hammer. Exercise 9: Lowercase . Right now, if you type in Thor’s name or Iron Man’s name, it works even if you don’t capitalize their names. But Captain America’s name has to be capitalized. Modify the code so that you can use lowercase to type in captain america’s name. Exercise 10: Nicknames . What happens if you just type in “cap” instead of “captain america”? It doesn’t work right. Let’s fix that. Make it so that you can enter in nicknames like “cap” or “tony” and it’ll still work. Exercise 11: Black Widow . Black Widow was also hanging out with the rest of her team. Let’s add her in to the story. Create a new branch where she tries to lift the hammer, and print out what happens when she tries. ",
    "url": "/labs/control_flow.html#not-always-doing-the-same-thing",
    "relUrl": "/labs/control_flow.html#not-always-doing-the-same-thing"
  },"27": {
    "doc": "Lab",
    "title": "Challenges",
    "content": "If you and your partner finish all of the exercises before the end of class, try at least one of the challenges below: . Challenge 1: Two-part Mad-libs . Take the mad-libs program that you worked on, and create a second part of the mad-libs. So you input a bunch of words, nad it prints out part of a story / song / something. Then you get a chance to input more words, and it prints out the second half. You’ve already got a first half of the mad-libs program written. Add a second half to your mad-libs program. Challenge 2: Avengers Mad-Libs . Turn the avengers story into mad-libs. Replace some of the words with variables, and then fill in the variables at the beginning of the program with funny words. Challenge 3: Avengers bug-list . As part of challenge 6, you made a list of bugs. Try this again; run the program over and over and try out different inputs, and see what happens. Make a list of each input, what you expect to happen, and what actually happens. Any time what actually happens is different than what you expect, you’ve found a bug! The goal here is just to make a list of bugs in the program. Challenge 4: Avengers bug-fixing . Don’t do this until finishing making the bug list. Go through your list of avengers bugs, and try to fix them. How do you get it to do the right thing in all of those situations? . ",
    "url": "/labs/control_flow.html#challenges",
    "relUrl": "/labs/control_flow.html#challenges"
  },"28": {
    "doc": "Lab",
    "title": "Turn in your work",
    "content": "Today, you’ll turn in screenshots of your code working (programs running in PowerShell or Terminal) and the .py files you edited for today’s exercises. Turn everything in on D2L, under Assignments -&gt; Lab 2 Screenshots and Code. For a refresher on taking screenshots, see the screenshot reference page. ",
    "url": "/labs/control_flow.html#turn-in-your-work",
    "relUrl": "/labs/control_flow.html#turn-in-your-work"
  },"29": {
    "doc": "Lab",
    "title": "Lab",
    "content": "The first thing you need to do today is to create a copy of the files you’ll need for the lab. These files are in the git repository linked above. Last week, you only downloaded one file. This week, download the full repository. Find the download button (next to the blue “Clone” button) on the main repository page and choose the “.zip” option. It will download as a .zip folder on your computer. Once you get the repository on your computer, you may need to unzip it to be able to work with the files inside. On Windows, right click on the file and choose ‘Extract All’ - this will create a new folder with the same name. On Mac, double click on the folder and it will do the same thing. You should have a folder named ‘control-flow-master’ with 5 files in it: . | README.md | avengers.py | hello.py | mad-libs.py | mad-libs-input.py | . The goal of these labs is to practice. Each lab will be a series of exercises and challenge to practice the concepts you were introduced to in the readings/videos for the week. You’ll continue practicing the concepts from this lab in the studio this week, and in future labs and studios. Many of the concepts build on each other and can be used in combination with one another. As with all labs, this lab will be done in pairs. Remember to switch places every so often! Everyone should spend at least part of the class as the driver, and at least part of the class as the navigator. ",
    "url": "/labs/control_flow.html",
    "relUrl": "/labs/control_flow.html"
  },"30": {
    "doc": "Lab",
    "title": "Counting in a loop",
    "content": "Exercise 1: Count . As an example of how to do loops, look at the file counter.py in the git repository. The program is supposed to count to 5. Run the program to see what it does. Then open the file and look at the code. How does it work? Read the code and see if you can figure out how this program works. Does it do anything you’re not expecting? . Edit the program so that it counts to 5 the way a person would count (that is, starting at 1). Hint: When Python counts using numbers, it always starts at 0. Hint 2: There are multiple ways to do this. One way is to use an increment, another is to modify the range. range() can take multiple values! Check out this week’s readings for more detail. Exercise 2: Print a random number . Right now when you run counter.py, it only counts to 5. It counts to 5 every single time. Let’s give it a random number to count to instead. First, let’s test out the random module by printing some random numbers outside of the for loop. We have to tell Python we’re using the module first, though. Do this by adding import random at the top of the counter.py program, above the for loop. Let’s generate a random number and print it out (outside of the for loop!) so we know it’s working. Try putting random.random() inside of a print statement: this will print out a number between 0 and 1. Run the program a few times and you’ll notice the number changing. The first number I got when I ran it was 0.4094163341030903. The numbers you get will be different. That’s cool, but counter.py only works well with whole numbers. You can use random.randint(x,y) to generate a whole number inside of a range of numbers, where x is the smallest number and y is the biggest. Try generating a number between 1 and 10 and print it out. Run the program a few times to make sure it’s giving you different numbers. Note: the for loop will still be running whenever you run the program. The first number that prints out when you run it will be the random number. Exercise 3: Count to a random number . The for loop is still running, and still only counts to 5. Let’s make it count to a random number instead. You’re already generating a random whole number, but you’re only printing it out. Let’s put it in the for loop. Store the random number in a variable called count and then use the variable in the for loop so that instead of running 5 times, it will run a random number of times. Exercise 4: Add some text . The program only spits out a bunch of numbers. Let’s make it a little more user friendly by adding some text to tell the person running it what it’s doing. Print out a line of text that says The program is counting to X, but replace X with the random number you’re generating. Hint: This should be easy to do if you stored your random number in a variable! Look at mad-libs.py from the Control Flow lab if you can’t remember how to use a variable inside of a print statement that already has other text in it. Hint 2: You’ll need to figure out where the best place is to put this print statement. Should it be before the loop, after the loop, or inside of it? Do what you think will make the most sense to a user who is running the program. ",
    "url": "/labs/counting_and_loops.html#counting-in-a-loop",
    "relUrl": "/labs/counting_and_loops.html#counting-in-a-loop"
  },"31": {
    "doc": "Lab",
    "title": "Change places with Git",
    "content": "Now is a good time to save your changes to Git and trade driver positions with your partner. The old driver should add, commit, and push their code, and then make sure their changes show up in GitLab. The new driver should use git pull to pull the changes their partner made down to their computer. For a refresher, see Using Git in the reference section on the course site. ",
    "url": "/labs/counting_and_loops.html#change-places-with-git",
    "relUrl": "/labs/counting_and_loops.html#change-places-with-git"
  },"32": {
    "doc": "Lab",
    "title": "Singing a song",
    "content": "Exercise 5: Looping verses . If you run the program bottles.py in the git repository, it will print out the first verse of the song 99 bottles. Let’s start small! Modify the program so it repeats the verse 5 times. Don’t worry about number of bottles in each verse just yet; just get the loop working. Your code should only be 5 lines in total. Hint: range(5) will count from 0 to 4. It always stops just before it gets to the end number. range(1, 5) will count starting at 1, so will count from 1 to 4. range(5, 1, -1) will count by -1, so it will count backwards from 5 down to 2. Exercise 6: Make the number of bottles go down . Now modify the code so that the number of bottles counts down with each verse, like in the song. Hint: A for loop uses a variable. In for i in range(10), the i is a variable. You can use that variable inside the loop. Each time through the loop, the for loop fills in that variable with the current number. So the first time through the loop, i is 0; the second time, it is 1, the third time is 2, and so on. Exercise 7: All the verses . Now modify the program to print out all 100 verses of the song. The last verse should have 0 bottles in the last line. At this point, your program should still only have 5 lines of code! . Exercise 8: Change the final verse . Modify your program to change the final verse of the song. Rather than singing zero, have it sing a different ending. For example, here is one alternative ending to the song: . No more bottles of beer on the wall, no more bottles of beer. We've taken them down and passed them around; now we're drunk and passed out! . Feel free to write your own lyrics for the last verse! . Hint: There are multiple ways to do this, and none of them is wrong. A question to ask: should the new verse be inside of the loop or outside? . Exercise 9: Change the 6th-to-last verse . There is an alternative way to sing the 99 bottles song, where the 3rd line is replaced with: . If one of those bottles should happen to fall, 98 bottles of beer on the wall... Modify your program so that the 6th-to-last verse (“5 bottles”) uses this alternative line instead of the normal line. Hint: You can use an if statement inside the loop to check which loop you are on, and print out something different if you are on a specific loop. ",
    "url": "/labs/counting_and_loops.html#singing-a-song",
    "relUrl": "/labs/counting_and_loops.html#singing-a-song"
  },"33": {
    "doc": "Lab",
    "title": "Change places with Git",
    "content": "This is another good time to save your changes to Git and trade driver positions with your partner. The old driver should add, commit, and push their code, and then make sure their changes show up in GitLab. The new driver should use git pull to pull the changes their partner made down to their computer. For a refresher, see Using Git in the reference section on the course site. ",
    "url": "/labs/counting_and_loops.html#change-places-with-git-1",
    "relUrl": "/labs/counting_and_loops.html#change-places-with-git-1"
  },"34": {
    "doc": "Lab",
    "title": "Guessing game",
    "content": "For loops are great if you want a loop to run a set number of times, and to stop once that number is reached. They’re not so great if you want a loop to keep running for some undefined amount of time – usually until something specific happens. That’s where while loops come in. Exercise 10: Play a guessing game . Run question.py. Right now, it asks one question, then tells you if you’re right or wrong. Let’s change the program so it keeps asking the question until the user gets it right. You can do this with a while loop. There are two parts to a while loop: the condition that makes the loop run, and the condition that causes the loop to end. The most basic while loop starts with while True: – everything inside of it will keep running until it reaches a condition which causes the loop to end. The True part of it means everything in the loop is true, until proven false (that is, until it breaks!). Remember: Python sees code as being inside of other code by looking at how the code is indented. The other piece the loop needs to have is a condition in it that causes it to end. Important: The keyword break is used to signal that the loop should end. If you don’t break a while loop somewhere, it will keep running forever! . A basic while loop looks something like this: . while True: stuff to repeat if &lt;condition to be met&gt;: break . Set up question.py so it keeps asking the question, and then end the loop with break when the question is answered correctly. Exercise 11: Ask a different question . Change the question and the answer to something interesting about yourself. My example of my favorite color is very boring. I’m sure you can come up with a more interesting fact about yourself than that. Exercise 12: Ask another question . Ask a second question. Once the user has succesfully answered the first question, the program should start asking the second question. Hint: You’ll need a second loop for this! . Git . At this point, you should have modified versions of all 3 programs for this lab. Make sure all of the modifications you’ve made on your own computers are pushed to your Gitlab repository! This is how you’re turning your code in for this lab, and for all future labs. ",
    "url": "/labs/counting_and_loops.html#guessing-game",
    "relUrl": "/labs/counting_and_loops.html#guessing-game"
  },"35": {
    "doc": "Lab",
    "title": "Challenges",
    "content": "If you finish the lab, please try to do at least one of the challenges. If you can get one or more of the challenges working correctly, then you can leave class early. Challenge 1: Alternate lines . Modify your bottles program so that every other line uses the alternative version. So the first verse should say take one down, pass it around, the second verse should say if one of those bottles should happen to fall; the third verse should say take one down, pass it around, and so on. Hint: Python has a modulus operator: %. Modulus finds the remainder after division. So 13 % 5 is equal to 3, since when you divide 13 by 5 ,you get 2 with a remainder of 3. You can use this to figure out if a number is even or odd: if the line number divided by 2 has a remainder of 0, then it is an even number. If the line number divided by 2 has a remainder of 1, then it is an odd number. Challenge 2: Random number of bottles . Use a the random module to make the song start at a random number of bottles, rather than at 100. When you do this, think about practicalities - you need the number it generates to be a whole number, but don’t want it to be too many digits or else your program will take forever to run. Remember to include import random at the top of the program! . Challenge 3: Limited tries . For question.py, change the code so it only lets the user try to answer the first question 3 times before it moves onto the next question. How would you do this with a while loop? (hint: there are examples in this week’s reading on loops.) How would you do it with a for loop? Bonus: use a while loop for the first question, and a for loop for the second question. Remember the loop still needs to end immediately if the user guesses the answer correctly. Challenge 4: Random guessing game . Make a guessing game that generates a random number and then asks the user to guess the number. It should work similarly to question.py in that it keeps asking the user to guess until the user gives the correct answer. Make it user friendly, too - print out some introductory text to introduce the user to the game and describe how to play. Remember to include import random at the top of the program! . I recommend making a new file and calling it random-guess.py for this challenge. Make sure to save the file in the same folder as your other code for this lab. Some of the code you wrote in question.py and counter.py might be helpful to copy+paste into the new file as you write the program. ",
    "url": "/labs/counting_and_loops.html#challenges",
    "relUrl": "/labs/counting_and_loops.html#challenges"
  },"36": {
    "doc": "Lab",
    "title": "Lab",
    "content": "For this lab, we are going to use a git repository like we did for last week. The first thing you should do is fork this week’s GitLab project (linked above). Only one person needs to create a forked project. Once forked, add your partner to the project (and Caitlin and Jack), and then clone the repository onto your computer. Check out the Git reference for a reminder on how to do this. ",
    "url": "/labs/counting_and_loops.html",
    "relUrl": "/labs/counting_and_loops.html"
  },"37": {
    "doc": "Readings",
    "title": "Readings",
    "content": ". | Using dictionaries to store data as key-value pairs | Automate the Boring Stuff: Chapter 5 - Dictionaries and Structuring Data – skim | Think Python: Chapter 11 – skim up to “11.6 Memos” | . ",
    "url": "/readings/dictionaries.html#readings",
    "relUrl": "/readings/dictionaries.html#readings"
  },"38": {
    "doc": "Readings",
    "title": "Summary",
    "content": "For this week’s summary, think about what you already know about other ways of storing data in Python, like variables and lists. Think about how dictionaries are different from those structures. Summary prompt: What do you think dictionaries might be useful for in Python? . ",
    "url": "/readings/dictionaries.html#summary",
    "relUrl": "/readings/dictionaries.html#summary"
  },"39": {
    "doc": "Readings",
    "title": "Question",
    "content": "As per usual, your question can be one of three types: . | Confusion: what didn’t you understand in the readings? | Curiousity: what do you want to know more about? | Connection: how does this topic connect to your own experiences? | . Submit your summary+question on D2L under Quizzes before class starts on Tuesday. ",
    "url": "/readings/dictionaries.html#question",
    "relUrl": "/readings/dictionaries.html#question"
  },"40": {
    "doc": "Readings",
    "title": "Readings",
    "content": "Dictionaries are another data structure in Python. We’ve used variables, which can store one thing, and lists, which can store many of the same thing. Dictionaries are a little like lists, except more structured. Things stored in dictionaries are stored in pairs. These pairs are called “key-value pairs” and work like actual paper dictionaries, which have words with definitions attached to them. The word is the key, and the definition is the value associated with that key. ",
    "url": "/readings/dictionaries.html",
    "relUrl": "/readings/dictionaries.html"
  },"41": {
    "doc": "Lab",
    "title": "Working with Dictionaries",
    "content": "Dictionaries are key/value stores. They are similar to lists, but differently structured. In a list, values are stored in order: 0, 1, 2, etc. In a dictionary, values are stored by name. The name is called the ‘key’ of the dictionary. To create a dictionary, we use the curly braces: {}. Everything between the curly braces is part of the dictionary. We can create dictionaries in python like this: . my_dictionary = { 'word': 'definition', 'word2': 'definition2' } . Any time you need the definition of a word, you can ask python for my_dictionary['word'] and it will provide the definition for that word. You can also create a blank dictionary and add stuff to it later, like with lists. The process of adding things is slightly different, though. my_dictionary = {} my_dictionary['word'] = 'definition' . The second line adds a single key-value pair to the dictionary called my_dictionary. I’ve used the terms ‘word’ and ‘definition’ - paper dictionaries are structured like this, and that’s loosely what Python dictionaries are based on. But Python dictionaries are more flexible than that. You can have them store anything you like. Today’s lab is long, but some of the exercises are pretty easy. If you get through everything, then great! If you don’t, then that’s OK too. Dictionaries are really useful, but also a somewhat weird way to think. It can take some time to figure out how they work and how to do things with them. ",
    "url": "/labs/dictionaries_as_data_structures.html#working-with-dictionaries",
    "relUrl": "/labs/dictionaries_as_data_structures.html#working-with-dictionaries"
  },"42": {
    "doc": "Lab",
    "title": "Using dictionaries",
    "content": "Exercise 1: Print out a mascot . Start by looking at the program mascots.py. There is a dictionary full of schools and mascots, where the name of each school is associated with its mascot. If you give the dictionary the name of a school, the dictionary will spit back out the mascot for that school (much like if you look in a real-world dictionary for a word, it gives you back the defintion of that word). We use this feature in the first print statement. We give the dictionary the name \"Wisconsin\". When we run the program, it goes into the dictionary and gets the mascot for Wisconsin and prints out “badgers”. Modify this program to print out the mascot for Ohio State. Note: you should not have to change the dictionary for this exercise, and at no point should you have to type “Buckeyes”. You should be able to do this by just changing the print statement on line 10 to use a different school. Exercise 2: Add another mascot . Your next task is to modify the dictionary and add another school’s mascot to the dictionary. The University of Washington was just added to the Big 10 this year. Let’s add “Washington” to the dictionary, along with their mascot (UW folks are called “Huskies”). Modify the dictionary to include Washington and its mascot, and then modify the print statement so it prints out the mascot for Washington. Exercise 3: Ask the User . Right now, all the program does is print out a single mascot for a single university. What if you want to know a different university’s mascot? Let’s modify the program to be a bit more interactive. After creating the dictionary, add some code that uses input() to ask the user which university they want to know the mascot for. Then the program should print out the mascot for whatever university the user entered by looking it up in the dictionary. The output of the program should look similar to this: . What university do you want to know the mascot for? Wisconsin People who go to Wisconsin are called Badgers . Your program should NOT use any if statements. You should be able to do this by collecting input from the user, storing in a variable, and then using that variable to look up the answer in your dictionary. Hint: Don’t forget to change the school’s name in the print statement to whatever the user typed, in addition to printing out the mascot. ",
    "url": "/labs/dictionaries_as_data_structures.html#using-dictionaries",
    "relUrl": "/labs/dictionaries_as_data_structures.html#using-dictionaries"
  },"43": {
    "doc": "Lab",
    "title": "Storing structured data",
    "content": "Exercise 4: Print out favorite food . Next, look at the file student.py. Run it; it should print out some information about me (your instructor). Right now, the program prints out my name and major. But the dictionary stores one more piece of information about me: my favorite food. Modify the program to also print out my favorite food by adding an additional print line. Exercise 5: Change the dictionary to your partner’s information . Now that the program is printing out all of my information, change whose information it prints out. Ask your lab partner for his or her information, and change the information in the dictionary to his or her information. To do this exercise, you should only change the information inside the dictionary; you should not need to change the print statements at all. Exercise 6: Add favorite color . Name, major, and favorite food are great, but that isn’t much information about a person. Add to the program the ability to store the person’s favorite color, and also print out that favorite color. BUT instead of just editing the dictionary directly again, this time we’re going to add the information using a separate line of code. The format dictionary[key] = value will add a new key and value to the dictionary. In this example, dictionary, key, and value are all generic - you’ll need to replace them all with information specific to this program. Make sure to add a new print statement to print out the person’s favorite color. Hint: If you’re not sure the information is being added to the dictionary correctly, you can always print out the dictionary’s structure in the console to check using print(student). Printing things to the console can be a helpful way to troubleshoot your code. Exercise 7: Ask the user for more information . Now let’s ask the program’s user for additional information using input() and add it to the dictionary. Ask them what their favorite movie is, and add that information to the dictionary. Make sure to add a new print statement to print out the person’s favorite movie. Hint: You can use the same structure as in the last exercise, but instead of hard-coding the value, save the user’s input to a variable and use the variable as the value instead. The key should probably be something like 'favorite_movie'. ",
    "url": "/labs/dictionaries_as_data_structures.html#storing-structured-data",
    "relUrl": "/labs/dictionaries_as_data_structures.html#storing-structured-data"
  },"44": {
    "doc": "Lab",
    "title": "Structured data into functions",
    "content": "One of the advantanges of dictionaries is that you can store complex data – such as all of the information about a student – in a single variable. That means that you can pass that single variable into a function. Exercise 8: Passing a dict into a function . Next, let’s order a pizza. Go run the program “pizza.py”. It prints out my normal Monday pizza order. Open of the file and look at it. There is a function called print_pizza_order that takes a single variable as a parameter – the pizza order. This order is a dictionary that contains all of the information needed for the order – the size of the pizza, the type of crust, and any toppings. The function then uses the information in the dictionary to fill in some print statements. Modify the program to print out my normal Friday order. You should be able to do this by changing exactly one word in the program. Exercise 9: Your pizza! . OK, time for you to order a pizza. Add a new variable to the program under friday. That variable should contain a dictionary with your pizza order – whatever type of pizza you like! Then modify the program to have it print out your order instead of mine, by calling print_pizza_order() and passing in the dictionary with your order. Note: There can be multiple values assigned to a single key in a Python dictionary - which means you can theoretically have multiple toppings. We’ll get to this in a later exercise – for now, only add one topping. ",
    "url": "/labs/dictionaries_as_data_structures.html#structured-data-into-functions",
    "relUrl": "/labs/dictionaries_as_data_structures.html#structured-data-into-functions"
  },"45": {
    "doc": "Lab",
    "title": "List of dictionaries",
    "content": "We’ve learned both lists and dictionaries. You can combine these in interesting ways. Exercise 10: Random pizza order . Sometimes I am so hungry I can’t decide what I want on my pizza. That’s when a random pizza ordering program would be useful. We know from previous labs that we can use random.choice() to pick a random item out of a list. Let’s use this with our pizzas. Modify the pizza program to take the three orders that already exist – my Monday order, my Friday order, and your favorite pizza – and put them into a list. Then have the program use random.choice() to pick a random item out of that list, and give that choice to print_pizza_order() to print out the full order. Don’t forget to import random at the top of your program. Hint: You can make a list of dictionaries. The easiest way is to put each dictionary in a variable, and then put those variables into a list: . cheese_pizza = {'crust': 'traditional', 'toppings': \"cheese\"} pepperoni_pizza = {'crust': \"thin\", 'toppings': \"pepperoni\"} pizza_list = [cheese_pizza, pepperoni_pizza] . Exercise 11: Lists inside of dictionaries . Dictionary keys can also be paired with lots of different kinds of things, including lists. Look in the file deluxe.py. This file contains a pizza order inside a dictionary, but instead of having one topping, it has a list attached to the toppings key. The print_pizza_order() function is also in deluxe.py, but it doesn’t quite work with this dictionary. Run the program to see what it prints out. Remember how to access items in a dictionary. Just like pizza['crust'] will give you a string with the type of crust, pizza['toppings'] will give you a list of strings. You can then do the things you would normally do with a list, such as accessing the first item (pizza['toppings'][0]) or looping through the list (for item in pizza['toppings']) or getting the length of the list using len(pizza['toppings']). Modify the function so it loops through the toppings list and prints out each topping one by one, like this: . I would like a extra large pizza on a thin crust With 5 toppings on it: - pepperoni - black olives - green peppers - sausage - mushrooms . Hint: When a list is stored inside of a dictionary (e.g. toppings), you can get the whole list at once using the dictionary syntax pizza['toppings']. Then you can loop through it like any other list using a for loop: . for top in pizza['toppings']: print(top) . Hint 2: Remember you can use len() to get the length of a list - that will be helpful for the “With X toppings on it” line. Exercise 12: Delivery Address . In the previous exercise, you stored a list inside of a dictionary. The key in the key-value pair is always a string, but the value can be anything you want. Here is a dictionary that contains a delivery address for the pizza: . address = { 'street': \"1278 Spartan Dr\", 'city': \"East Lansing\", 'state': \"Michigan\", 'zip': 48864 } . We want to put this address inside of the pizza order, so we know where to deliver this pizza. We can do this by modifying the pizza order: . cheese_pizza = { 'crust': \"traditional\", 'size': \"large\", 'toppings': ['cheese'], 'delivery': address } . Notice that I did not put quotes around the address. In Python, if you put something in quotes, it’s a string. The only information a string stores is the text inside the quotes. But I don’t to delivery to be linked to the word \"address\", I want it to link to the dictionary that is stored in the variable address. So I use address without quotes to point to the variable. You access this is basically the same way as before. If you access cheese_pizza['delivery'], it gives you a dictionary of information. And then you can use the same technique to get items out of that. So cheese_pizza['delivery']['street'] will tell you the street address that you are delivering it to. Add the address dictionary to deluxe.py (you can change the address info if you want) and then reference the address dictionary inside the deluxe_pizza dictionary. Modify the print_pizza_order() function to print out the address the pizza should be delivered to. Your function should still just accept one parameter – a dictionary with the pizza order. Exercise 13: Pretty print . Now that we are getting more and more complicated dictionaries, it is sometimes useful to print out the contents of a dictionary to the terminal so we can better see what it looks like. Modify your program to just call print(pizza) – that is, to use the regular print function and passing it the dictionary. This gives you the information, but it is hard to read. Another, clearer way to do this is called “pretty printing”. This tries to format the dictionary in a way that is easier for humans to read. We can use the ``pprint` library to pretty print. import pprint pprint.pprint(deluxe_pizza) . Modify your deluxe.py program to pretty print the entire dictionary your pizza. We don’t normally do this in code that is intended for other people to use. But pretty printing a dictionary is a great way for us to see what the dictionary looks like, and is a useful tool for writing (or reading!) code that uses dictionaries. ",
    "url": "/labs/dictionaries_as_data_structures.html#list-of-dictionaries",
    "relUrl": "/labs/dictionaries_as_data_structures.html#list-of-dictionaries"
  },"46": {
    "doc": "Lab",
    "title": "Thinking about structured data",
    "content": "All of these exercises today are using dictionaries in a very specific way, and in a way that is different than how we used them before. All of these exercises are using dictionaries to store “structured data” – complex data that is made up of multiple different pieces of information that are grouped into a logical whole. A student is a logical whole, but the information about that student has multiple different pieces. Same with a pizza order. When we put this information into a dictionary, we do so in a specific way. Dictionarys store “key/value” information that associates some value (e.g. definition) with a key (e.g. word). In our structured dictionaries, the keys define the structure of the data. So we have keys that look like “crust”, “toppings”, or “name” – they are words in quotes. The values associated with those keys are the actual data. This is a really common and valuable way to think about and use dictionaries in Python. Exercise 14: Structuring Data . Now that you have experience working with dictionaries to store structured data, it is time to create the a structure yourself. Create a new file called post.py. Imagine a post on social media, such as a Facebook post or an Instagram post. The post is actually a complex object that has a lot of information – who posted it, the text content of the post, an optional picture, hashtags, the date and time when it was posted, etc. Write a program that stores a post on an imaginary social media system that you are creating in a dictionary, and then prints out the contents of the post by pulling data from the dictionary. Create multiple different posts as separate dictionaries. Make sure that the code you use to print out the post is a function, and test that it works correctly with multiple different posts. It is up to you how you want to structure / organize your dictionary. The only rule is that the entire post has to be stored in a single variable – which means in a dictionary. Hint: your final program should look similar to deluxe.py in that it has a function that prints out data from the dictionary, the dictionary itself, and then calls the function at the end. ",
    "url": "/labs/dictionaries_as_data_structures.html#thinking-about-structured-data",
    "relUrl": "/labs/dictionaries_as_data_structures.html#thinking-about-structured-data"
  },"47": {
    "doc": "Lab",
    "title": "Challenges",
    "content": "Please complete at least one challenge before leaving for the day. It is up to you which one you do. Have the instructor or TA come over and see the results of your challenge before you leave. Challenge 1: Input pizza order . Right now, the pizza orders are hard-coded into your Python program. Modify your program to instead ask the user what they want to order using input(). You’ll have to ask multiple questions, and then assemble the results into a dictionary. The dictionary should be able to be printed using your existing print_pizza_order() function. Bonus: put your questions and input() commands into a function that returns the complete dictionary. Challenge 2: Calculate GPA . Modify the student program to store a list of grades in the dictionary for the student. Then write a function that goes through the student’s grades and calculates their GPA. Challenge 3: Display your social media post . Modify the program from Exercise 14 (the social media post) to use Turtle to display all of the information in the post visually. ",
    "url": "/labs/dictionaries_as_data_structures.html#challenges",
    "relUrl": "/labs/dictionaries_as_data_structures.html#challenges"
  },"48": {
    "doc": "Lab",
    "title": "Lab",
    "content": " ",
    "url": "/labs/dictionaries_as_data_structures.html",
    "relUrl": "/labs/dictionaries_as_data_structures.html"
  },"49": {
    "doc": "Readings",
    "title": "Readings",
    "content": "Read the first article in full; it’s short, and will give you a basic idea of what we’ll be doing in the lab. The other two readings go much more in depth. Skim them and read parts that are interesting to you, but don’t spend too much time on them – skim with the goal of getting more familiar with the different things Turtle can do. | The Python Turtle Library, Step by Step | (Skim) Ch 13: Turtle Graphics – Stop reading at 13.5 Visualizing recursion; don’t read that section or anything after it | (Skim) Turtle Documentation – Everything the turtle can do, in way too much detail (this is a great resource!) | . ",
    "url": "/readings/drawing.html#readings",
    "relUrl": "/readings/drawing.html#readings"
  },"50": {
    "doc": "Readings",
    "title": "Summary",
    "content": "For the summary this week, think about all of the different things you’ve learned about what Turtle can do. Summary prompt: Why do you think we’re learning Turtle for this class? What would you like to be able to do with programmatic drawings? . ",
    "url": "/readings/drawing.html#summary",
    "relUrl": "/readings/drawing.html#summary"
  },"51": {
    "doc": "Readings",
    "title": "Question",
    "content": "As per usual, your question can be one of three types: . | Confusion: what didn’t you understand in the readings? | Curiousity: what do you want to know more about? | Connection: how does this topic connect to your own experiences? | . Submit your summary+question on D2L under Quizzes before class starts on Tuesday. ",
    "url": "/readings/drawing.html#question",
    "relUrl": "/readings/drawing.html#question"
  },"52": {
    "doc": "Readings",
    "title": "Readings",
    "content": "This week we’ll start using Python to draw images on the screen. We will be using a library called Turtle. There are a ton of commands you can use with Turtle - don’t worry about memorizing them all. ",
    "url": "/readings/drawing.html",
    "relUrl": "/readings/drawing.html"
  },"53": {
    "doc": "Lab",
    "title": "Using Functions",
    "content": "In your readings, you learned about functions. Functions are named sections of code that you can “call” from other parts of code. Functions let you use the same chunks of code over and over again without having to write it all out each time. In this section of the lab, we will be using the cards.py program. The top of this program defines 4 functions in it: one that draws a diamond, one that draws a heart, one that draws a club, and one that draws a spade. You shouldn’t need to modify or change these functions; leave them in the program. If you run the program, it just draws a spade right now (because, at the end of the file, we call the spade() function). Exercise 1: Draw a club . Change cards.py to draw a club instead of a spade. This should only involve changing one line of code in the program. Exercise 2: Draw a heart . Next, change the program to draw a heart instead of a spade. Again, this should only involve changing one line. Exercise 3: Draw a spade and a heart next to each other . Next, change the program to draw a spade and a heart next to each other. You shouldn’t need to change the functions at all. Instead, you should call the spade function, then move the turtle, and then call the heart function. Hint: Remember you can use penup() and pendown() so that you don’t draw a line in between drawing the two shapes. Exercise 4: Draw two clubs and a diamond next to each other . Finally, modify your program to draw two clubs and a diamond next to each other. ",
    "url": "/labs/drawing_with_functions.html#using-functions",
    "relUrl": "/labs/drawing_with_functions.html#using-functions"
  },"54": {
    "doc": "Lab",
    "title": "Creating your own functions",
    "content": "In cards.py, the code I gave you used def spade(): to define the spade function. All of the indented lines after that are part of that function. You can use def to create your own functions. Exercise 5: Fill in a function that draws a star . Look at the program stars.py. It has the line def star(): near the top of the program. That is creating a new function that is supposed to draw a star. However, right now, the code for the function (everything indented below it) just says pass. This is a placehoolder: pass is Python’s way of saying “do nothing”. Modify the star function to include the code for drawing a star. When you run the program, it should look like this: . Hint: Remember, it is OK to look at past labs (and the solutions to past labs) for help. You probably drew some stars in the Turtle lab. Hint 2: You can speed up the turtle by putting the command speed(0) near the top of your program. ",
    "url": "/labs/drawing_with_functions.html#creating-your-own-functions",
    "relUrl": "/labs/drawing_with_functions.html#creating-your-own-functions"
  },"55": {
    "doc": "Lab",
    "title": "Functions with parameters",
    "content": "So far in this lab, we have just used functions as a way of organizing our program. Basically, we give a section of our program a name, and then we can “call” that function – which runs the section with the name. This is a really useful feature of functions. Remember how long and confusing the code was for your flags two weeks ago. If we broke it up into logical pieces – the piece that draws a bar, the piece that draws a star, etc. – then we can give each of those pieces a name and make them a function. This would make the code easier to understand, and also allow you to use each chunk of code multiple times. Functions can do more than just that, though. They can also have parameters that modify what they do. The parameter is what goes inside of the parentheses for a function name. For example, forward() is a function that takes one parameter: a number which specifies the distance in pixels that the Turtle should move forward. You can put any number you like into the forward() function, and it will move the Turtle that many pixels forward. Parameters make functions more flexible. Parameters are like variables that you can put different things into to make the function do different things every time you call it. The forward() function in Turtle will move a different distance depending on what number you give it, for example. Exercise 6: Sizes of Stars . Look at the program sizes.py. It has a function called star that draws a star. Except unlike the star function you wrote above, it accepts a parameter – size. This parameter tells it how big of a star to draw. When you define a function that has parameters, you also define the parameters, like this: . def star(size): . This defines a function called star(), with one parameter, called size. The parameter is a variable that is specific to the function: it will be filled in later when you call the function. The code inside the function should say where the parameter is used. Notice where size is used inside of the star() function. Right now that program draws a single star of size 25. Modify the program so that it draws 3 stars next to each other, each one bigger than the other (25, 50, 100). When complete, it should look like this: . Hint: because you’ve added a parameter, when you call the star() function now, you have to call it with the parameter filled in or Python will give you an error. Hint 2: remember you’ll need to write some code to move the turtle between drawing each star so the stars don’t overlap. Exercise 7: Colored bars on a flag . Next, look at the program flag.py. The goal of this program is to draw the flag of Germany, but the program isn’t done yet. Since each of the three bars is the same thing except a different color, I decided to write a bar() function that draws a single bar. That function takes one parameter – bar_color – that tells the function what color to make the bar. We’ll ignore the parameter for now and come back to it in the next exercise. Let’s start by writing a simple bar() function that just draws a 300x50 rectangle. If you put the code to draw a rectange into the bar() function, then it should look like this when it works: . Hint: the code that moves the turtle into position before drawing the next bar expects the turtle (the arrow) to be in the same position and angle it started in before drawing the bar. Exercse 8: German Flag . Let’s continue to modify the flag program to draw the flag of Germany: three colored bars that are black, red, and yellow. The bar() function accepts one parameter – bar_color. When it is used at the bottom of the file, it calls bar() three times, each time asking to draw a different colored bar. Modify the code for the bar function to color that rectangle whatever color the parameter says it should be. Remember the parameter is like a variable; it will be filled in with a ‘real’ value when the function is called. Your program should look like this: . Hint: pencolor() changes the color of the outline, fillcolor() changes the fill color. color() changes the color of both the outline and the fill. Which should you use to get it to look like the screenshot above? Also remember to use begin_fill() and end_fill(). Exercise 9: Flag of Ghana . You now have a function that draws horizontal bars, and a function that draws a star of a different size. As the next exercise in this lab, create a new program called ghana.py and copy both of those functions into it. Use those functions to write a program that draws the Flag of Ghana. Your program should use the bar() function and the star() function to draw the colored bars and the black star. You shouldn’t need to modify the bar function. You will need to modify the star() function so it draws a black star instead of an outline. To draw the flag, you should only need to call the functions with the right colors and write a bit more code to move the turtle to the right places. ",
    "url": "/labs/drawing_with_functions.html#functions-with-parameters",
    "relUrl": "/labs/drawing_with_functions.html#functions-with-parameters"
  },"56": {
    "doc": "Lab",
    "title": "Your own functions",
    "content": "So far in this lab, you have used functions that I wrote, and filled in functions that I created. Next, you need to write your own function. Exercise 10: Next Suit Function . Go back to the cards.py program. Write a move_next() function that moves the turtle to a place to get it ready to draw the next suit. Once your function works, you should be able to use it like this: . spade() move_next() heart() move_next() diamond() . ",
    "url": "/labs/drawing_with_functions.html#your-own-functions",
    "relUrl": "/labs/drawing_with_functions.html#your-own-functions"
  },"57": {
    "doc": "Lab",
    "title": "Challenges",
    "content": "If you complete all of the exercises before the end of class, try at least one of these challenges: . Challenge 1: Random color stars . Modify stars.py to include a parameter for the color of the star called star_color. Use the list of colors below and random.choice() so that when each star in the circle is drawn, it draws as a random color from the list. You’ll need to modify where star() is called inside the for loop so that it’s called using the parameter. colors = [\"red\",\"orange\",\"green\",\"blue\",\"yellow\",\"light blue\",\"purple\"] . You can put more colors into the list if you want to. Note: remember to add import random to the top of your program. Challenge 2: 5 suits . Go back to your cards.py program and modify it to ask the user which suit it should draw. Then draw the suit that the user specifies. Put this user input into a loop: Ask the user 5 times what suits they want drawn, and then draw those five symbols next to each other on the screen. Bonus: keep drawing suit symbols until the user says to stop. Challenge 3: Different star sizes . Modify the stars program to draw circles of different sized stars. You’ll probably want to use a parameter for the size. You can use the random library to vary the size randomly, but you don’t have to. What are other different ways you could change the sizes of the stars? . Challenge 4: Draw the original U.S. flag . The Betsy Ross varient of the original U.S. flag had 13 stars in a circle on the blue part of the flag. The code in stars.py draws a circle of 13 stars. Use the star() function, the loop that draws the circle of stars, and the bar() function to draw the original U.S. flag. You’ll probably need to modify the bar() function so it draws skinnier bars. ",
    "url": "/labs/drawing_with_functions.html#challenges",
    "relUrl": "/labs/drawing_with_functions.html#challenges"
  },"58": {
    "doc": "Lab",
    "title": "Lab",
    "content": " ",
    "url": "/labs/drawing_with_functions.html",
    "relUrl": "/labs/drawing_with_functions.html"
  },"59": {
    "doc": "Lab",
    "title": "Lab",
    "content": "Today is election day; there is no class today. The Summary + Question for this week will not be due until Thursday Nov 9 before the start of class. ",
    "url": "/labs/election.html",
    "relUrl": "/labs/election.html"
  },"60": {
    "doc": "Lab",
    "title": "Lab",
    "content": "Fall break at MSU in 2023 is Oct 23-24 (Monday and Tuesday). The Summary + Question for this week will not be due until Thursday Oct 26 before the start of class. Enjoy your break! . ",
    "url": "/labs/fall_break.html",
    "relUrl": "/labs/fall_break.html"
  },"61": {
    "doc": "Readings",
    "title": "Readings",
    "content": "Please read the following: . | https://www.programiz.com/python-programming/file-operation | Think Python, Chapter 14: Files (Up through 14.4. Stop at 14.5 Catching Exceptions) | . Also, please re-read (skim) the following chapters about dictionaries: . | Automate the Boring Stuff: Chapter 5 – Dictionaries and Structuring Data | Think Python: Chapter 11 – Dictionaries (stop at “11.6 Memos”) | . As you read these, think about how you might use this. What kinds of programs might you want to write that use these features? Submit this summary on D2L. Then, write down a question. It can be a point of confusion or a needed clarification about anything in the readings, or it can be something interesting that you thought about while you were reading that goes beyond the reading. Or it can be an example you thought about, or a connection you made between the concepts here and other parts of your life. But write down a good question or example based on what you were thinking about while reading. The summary + question for this week can be submitted on D2L. ",
    "url": "/readings/files.html",
    "relUrl": "/readings/files.html"
  },"62": {
    "doc": "Final Week",
    "title": "Final Week",
    "content": " ",
    "url": "/week/final.html",
    "relUrl": "/week/final.html"
  },"63": {
    "doc": "Lab",
    "title": "Engine Features",
    "content": "Read and display files . The obvious place to start work is with a function that will read in the content of a file and print out that content on the screen. This is the most basic functionality of your program, and probably the thing you should get working first. I recommend passing the name of the file in as a parameter – so you can use the same function every time you need to read in and display the next file. Provide an option to quit . Your user might want to just stop the program in the middle. You should allow your user to enter “quit” (or some other, equivalent input) and when you notice that, the program should just stop. You can use the sys.exit() function to just stop the whole program. So when the user enters “quit”, call sys.exit() to stop the program. Don’t forget that you need to import sys somewhere for this to work. Loop to load the next file . Once you’ve got the code working that reads and displays the .txt files, and also the code that gets inputs from users, then you can try to loop the code. Use the input to figure out what the next .txt file is that you should load, and then loop back around to load and display the contents of that file and ask for another user input. Most engines contain a main loop like this. This main loop is what controls the whole interactive experience. Display the story with turtle graphics . Once you have all of that working using the terminal, you might want to instead change it to display using turtle graphics. Using turtle graphics, you can use different fonts to make your story more interesting, and you can draw other things on the screen around the text. That is, you can make the interactive story more like a creative art project. Think about what you want your screen to look like, and how you want to display your story. I recommend getting the interactive story working on the terminal before moving to turtle graphics. ",
    "url": "/labs/final.html#engine-features",
    "relUrl": "/labs/final.html#engine-features"
  },"64": {
    "doc": "Lab",
    "title": "Storytelling",
    "content": "This is a computer programming class, and the natural inclination is to focus your time and energy on the programming part of this assignment. I strongly encourage you to spend at least as much time on the storytelling part of the assignment! Telling an interesting, creative, interactive story is important – it is a different way of expressing yourself, and a different way of thinking about how you can express yourself. The programming is not the end goal – it never is! Instead, the programming is just a means to tell a story. If you don’t tell an interesting story, it doesn’t matter how good the programming is. Also, good storytelling will cause you to go back and improve the programming to make it better, and good programming will enable more interesting storytelling. The two build on each other. Choose a milieu – a “world” for the story to be in . If you are good at coming up with stories, then you don’t need this advice. If, like me, you aren’t awesome at it, then the easiest way to start is to start with an existing story and a set of characters. For example, I’d probably start with the Avengers movies because I like them and they have LOTS of interesting stories (and the Infinity War saga movies feel sort of like a choose-your-own-adventure movie). Pick a story that you already know a lot about to start with, and begin there. It could be from a movie, a book, a game, a TV show, a fairy tale, or real life. It could be a true story, or it can be made up. But pick an existing story. The easiest place to start is to tell that story. Then think about different places where people in the story could have made different choices, and things would have turned out differently. Those are great places to ask the user to make a choice. You’ll also have to write the alternative outcomes / stories. Think interactively . Telling an interactive story, where the reader gets to make choices, is different than telling a straight story. This semester, you have not only been learning how to program, but you’ve been learning how to adjust your thinking around the opportunities that programming gives you. Use this; think about dfferent ways you can give the reader of your story opportunities to be involved, while still telling an interesting story with a plot and characters? . Is this person the “reader” of your story? Or is the person a “user” of your program? Because this is an interactive creative story, they are both! Use that to your advantage. Support your work: Create diagrams . Once you’ve got an idea for a story, I’d recommend creating a diagram. Put major events in circles on a piece of paper, and then draw a line between them to signify order. Figure out what kinds of choices can be made, and add other outcomes as additional circles. It will really help to have a diagram that you can refer back to as you work on the programming. Here is a very simple example of a diagram. Each circle in the diagram can end up being a file in the story. You can label the possible paths with choice names. The diagram will contain a lot of the information that ends up in your text files. ",
    "url": "/labs/final.html#storytelling",
    "relUrl": "/labs/final.html#storytelling"
  },"65": {
    "doc": "Lab",
    "title": "Features for Integrating Storytelling and Engine",
    "content": "Here are some suggestions for additional features you could add. They are in no particular order. You don’t have to add all these features; they are just here to help you think about how you could make your story more interesting. I recommend getting the basic program and story working before trying to add these features. Control what’s next from the content files . First, get the simple version of the engine working. But if you get that working, one way to improve your engine is to integrate the story text and the possible options into the same text file. The text file would then contain the text to display to the user, the options for what’s next, and what file to read next if that option is chosen. So the intro.txt file could look like this: . It was a dark and stormy night. You have been walking down this road for what seems like forever, and are soaked to the bone from the rain. You come across a lonely house -- the first one you've seen. It is dark inside. What do you do? --- Knock on the door: inside.txt Run away screeming: scream.txt . The beginning of the file is the story text that should be displayed to the user. Then there is a line that is just 3 dashes. After that, each line contains an option that the user can choose, followed by a colon and then the name of the next file that the program should read and display, if the user chooses that option. Only accept valid inputs . The next hard part of the program is to figure out what options the user has. If you think back to your adventure program in week 1, you used if statements to check whether the user entered a valid input. And you hard coded the possible valid inputs. In this program, the possible valid inputs are coming from the .txt files with the content, so you will need a way to read the possible valid inputs from the .txt file, get input from the user, and then compare the users input with the possible valid inputs. You might also want to use a loop for this, so that if the user enters something that isn’t valid, you can tell them that and ask them again. I recommend putting the code that does this into a function that you can call. Colors . Colors can really help set the mood. Different points in the story might best be told in different colors. So let’s have each text file specify what the background color for the screen should be, and what the text color should be. Modify your program so that the first two lines of each text file can specify a color. The first line should specify the background color, and the second line should specify what color the text should be. When reading in your file, you should read in these colors and set them appropriately. Then your content files might look like this: . black white --- It was a dark and stormy night. You have been walking down a long road.... Inline Emoji . You’ve got a graphical system for displaying your story. That means you can put little graphics in the story, like emoji. Create an ability to specify emoji in the text files. Think about what kinds of emoji or graphics you would want in your stories. Create a set of functions that draw these emoji. Then, modify the part of your program that prints out the text to look for inline emoji indicators. For example, you could write the text file like this: . It was a dark and stormy night *frown*. You have been walking down a long road... Notice that there are two asterisks with the word frown between them; have your program remove them from the text and replace them with a frowning face emoji. Think about what kinds of emoji you might want to include in your story. Information display . Often, it is valuable to display some kind of information in a panel in the upper right hand corner of the screen. For example, if you are writing a story about a sports event, you could display the current score there. If you are writing a horror story, you could display the main character’s current heart rate next to a heart emoji. Create a small information display in the upper right hand corner that keeps track of some aspect of the story. If you are writing a horror story, then it could display the heart rate, and every time the person sees something scary, you can increase the heart rate. If the heart rate gets too high, then the story can go to a specific text file? . Chance . Rather than the user making a direct choice with a direct consequence, there could be an element of chance involved. If you choose to run away, maybe that would include some code that would pick a random number between 1 and 10, and give you different options depending on what you roll. You can use random.randint(1, 10) to pick a random number between 1 and 10. Then you can check if that random number is less than something (7 == 70% chance; 2 = 20% chance) . ",
    "url": "/labs/final.html#features-for-integrating-storytelling-and-engine",
    "relUrl": "/labs/final.html#features-for-integrating-storytelling-and-engine"
  },"66": {
    "doc": "Lab",
    "title": "General Advice",
    "content": "Break program into parts (functions, modules) . This is the largest and most complicated program you will write this semester. If you try to make it all one list of commands, it will get confusing quickly. Try to stay organized. You are already separating the logic (programming) part from the story part (the .txt files). In the programming, stay organized by breaking your code into functions. Each logical thing that your program does should be a separate function. Also, you can organize your functions by putting them into separate python files (“modules”). Each module should contain logically related functions – for example, you could put all of the turtle graphics functions in one module, and all of the file reading and input getting functions in a separate module. Staying organized will help you make your program more interesting and make it easier as the program gets more complicated. Work as a team . You are working on a team on this project. Use the whole team! Break up the work into parts, and have different people do different parts of the project. Maybe one or two people work on the story for an hour, while the other people on the team work on the engine. Then after an hour, you change up the work. Or have one person work on input and the other work on output. Talk with your teammates about how to organize the work to make the project interesting and to use the creativity and skills of all of the team members. Think about pair programming – where one person types while another looks over their shoulder and helps out. Does pair programming help you work faster or slower? . Use past code . You have spent this whole semester writing code. That code does a lot of valuable, interesting things. Don’t waste your effort. Think about what code you’ve written before, and then go look it up and try to re-use it here. You can copy-and-paste your past code if it already does what you need done, or you can copy it and then modify it if it is close but not quite what you need. Use what you’ve already written as much as possible; it is much easier to start with existing code than it is to write code from scratch. For all of the labs this semester, I have posted solutions – my working code that solves the lab problems. Go to the GitLab page for each lab, and choose “solutions” from the dropdown labeled “master”. Feel free to use my solutions code also – just make sure you understand what it is doing and how it works. Likewise, it is a good thing to use existing Python libraries (like turtle, random, and sys). They can do many things for you. Here is a list of built-in functions and the full Python standard library. As you work, if you feel like “this has probably already been written”, then it probably has. Try searching Google for advice. You might find code that can help you do what you are trying to do. Often, you will find code that is close, and then you have to read, understand, and modify that code to do exactly what you are trying to do. But Google can help you get closer. Use git . Git is a good way to share your work with your teammates. You’ve been using it all semester to share work. Do that for this project. You will end up with a lot of different files – both python files and .txt story files – that you will need to share to get your program to work. Putting all of those in a cloned git repository is the easiest way to stay organized and share your work with your team. Use git and GitLab to help you. Also, don’t just commit to git at the end of the day. You want to create multiple version, so you can easily go back to an older version if you need to. It is better to commit frequently, as soon as you get something working. Test pieces separately, and then the whole . As you develop, think about how you can test out your program. You don’t have to do the automated testing that we learned in class, though you can if you want to. But we also learned how to think about testing. As you work on each piece of your program, think about how to test it to make sure that it works the way you think it does. Then also think about integration testing – how do you test that all of the pieces fit together and work together in the way you hope they do? . Comment before Wednesday . Be sure to remember to add comments to your code that will help you remember and understand what you did. You will be putting this aside for 2 days while you work on other things, and then coming back to it on Wednesday. Comments now will really help your code make sense for you on Wednesday when you come back to working on it. ",
    "url": "/labs/final.html#general-advice",
    "relUrl": "/labs/final.html#general-advice"
  },"67": {
    "doc": "Lab",
    "title": "Lab",
    "content": "For all of this week, we will be going back to the beginning of this class. Our very first studio assignment was to make a “Choose your Own Adventure” story – a program that tells an interactive story where the user gets to make meaningful choices that affect the progression of the story. This week, we are going to do that again – but this time, you will be using the skills you’ve learned in class to make the program more fun and interesting. This entire week is a studio; form into teams of 2-4 people; you will be continuing this same project on Wednesday with the same group. One thing that many programs do: they separate the “logic” of the program (how it works) from the content (what it says). The logic portion is known as an “engine”, and it controls all of the interactive parts of the story. The content part (usually just called “content”) is where the actual story is. In games, it is also where the art and music and other aspects of the story are. For this studio, you will be creating both an interactive storytelling engine, and also creating a set of files that contain a specific, interesting story that is being told. The engine will be one or more python files. Those files will have code to display the text-based story, accept input from users, figure out what the next stage of the story is, and allow the user to quit. The actual story itself will be stored in plain text files (.txt) that are in the same directory as your python program. The plain text files should look like this: . It was a dark and stormy night. You have been walking down this road for what seems like forever, and are soaked to the bone from the rain. You come across a lonely house -- the first one you've seen. It is dark inside. What do you do? . The file contains the story text that should be displayed to the user at this point. Each point should be a separate text file. For example, this file might be called intro.txt, and if the user chooses to go inside, the next text file might be called inside.txt. (And if the user choser to stay outside, you would display the contents of outside.txt instead…) . Using this structure, your goal is to create an interesting, interactive story experience. You will write the code that reads these files, displays them to users, and gives the users interactive options. And you will also write an interesting and compelling story. The Engine + Content structure allows you to separate the work on the two parts of the story – the interactivity, and the story text. Work on both simultaneously, and go back and forth between them as you work. I expect that as you work, you will come up with more ideas. That’s basically it. Those are the instructions – create an engine for telling an interactive, text-based story, and then use that engine to create a fun and interesting story experience. I think of this as an interactive art project that you are creating. What follows are some suggestions for features and ways to think about doing this. You have both today’s class and Wednesday’s class to do this project. The final, working project must be stored in a git repository that is shared with both Dr. Wash and with Jack Waier. Additionally, please post screenshots to D2L of your finished program running. ",
    "url": "/labs/final.html",
    "relUrl": "/labs/final.html"
  },"68": {
    "doc": "Readings",
    "title": "Readings",
    "content": "There are no readings for this week. However, I would like you to think about and submit a summary+question. For this week’s summary, think back over the class. What have you learned? Do you feel like you are able to program computers now? Do you feel like you understand programming enough that you could work with a professional, where you do related work (technology design, art design, game design, advertising design, etc.) and tell the programmers what to do? What skills do you think you understand pretty well? What skills do you feel like you still need to learn? . There is a lot more about programming that you can learn; this was just one course. But reflect over this course and summarize what kinds of things you feel like you are now able to do that you couldn’t do at the beginning of the course. For the summary part of the assignment, summarize what you feel like you’ve learned in this course. For the question part of the course, think about how you might use these skills in the future. How do you think you might use the skills you learned in your future courses? in your future career? in your future life? Are you already using the skills from this course in interesting and valuable ways? . If you have spare time, this is interesting reading: https://automatetheboringstuff.com/chapter18/ . ",
    "url": "/readings/final.html",
    "relUrl": "/readings/final.html"
  },"69": {
    "doc": "Studio",
    "title": "Final Project",
    "content": "This Choose-Your-Own-Adventure engine and story is the final project for the course. You should be able to get it working during the approximately 4 hours of class time this week. Once you feel like your adventure program is finished, please make sure that the current, working version is checked into a git repository stored on MSU’s GitLab, and that GitLab project is shared with both the instructor and the TA. Also, please submit screenshots of your program working on D2L. Due: Wednesday, May 3rd at 7:45pm (the scheduled final exam period) . Grading . In addition to the normal check, check plus, check minus grades for class this week, this project will receive a grade as the final project for the class. This grade is based on how well the program works and how interesting / creative the program is. This class has not only taught you how to program, but also emphasized how programming is a useful tool for expressing creativity. The grade for your final project is 20% of your overall grade for the class. Here is how the grade for your final project will be determined: . Basic necessities (aka the “Minimum Viable Product”) (70% of grade; 10% each) . | Program runs (with minimal effort) | Content exists; the program tells a story | Program is interactive and gives the user multiple paths to follow (those choices matter for the story) | Logic of program separated from content somehow | Option to quit the program exists | Code is stored in Gitlab | Screenshots of final, working program in D2L (or in Gitlab) | . The remaining 30% of the grade is for going beyond the minimum, and making an interesting choose-your-own-adventure program. This can be done through creativity, through programming, or through a combination of both: . Creativity . | Tells an interesting story | Story has an interesting setting / millieu | Turtle interface that looks interesting | Turtle interface that adds to the story | Other, unanticipated creative strengths | . Programming . | The program is well commented and easy to read | The code and content is well organized | Uses interesting programming / logic to tell the story | Uses complex-but-not-unnecessarily-complex code/logic (e.g. dictionaries / files) | Other, unanticipated programming strengths | . Each of these can be awarded 0-15 percentage points based on how good / interesting it is. Maximum grade is 100%. Generally, if one of these things is there, it is worth 5%. If it is good, then 10%, and if it is really great, then 15%. Plan to incorprate at least 2 things which go beyond the minimum, and play to your group’s strengths. Collaboration Outside of Class . You do not have to work outside of class. In past years, many groups have finished their final project during the normal class periods. However, if you would like to continue to work on this project outside of class, you are welcome to do so. The final project isn’t due until the scheduled final exam time. You are welcome to use any collaboration tools that you like. I encourage you to continue to use git and GitLab for your collaboration; you’ve been using it all semester, and it is specifically designed for collaboration on programming projects like this. You don’t have to work synchronously with your team, but it is often nice to so do. You can create your own zoom meetings for your team by going to https://msu.zoom.us, logging in, and scheduling a new meeting. ",
    "url": "/studios/final.html#final-project",
    "relUrl": "/studios/final.html#final-project"
  },"70": {
    "doc": "Studio",
    "title": "Studio",
    "content": "We will be continuing to work on our Choose Your Own Adventure engine and story. Please keep working on it today with the same group you had on Monday. As you work, think about the code you wrote on Monday. Does it still make sense? Is there anything you wish you had done differently so it would be easier to work with today? . Also, think about scope: how much can you get done? You worked for about 2 hours on Monday, and you’ve got another 2 hours or so to work today. How much did you get done on Monday? What do you still have left to do? Do you think you’ll reasonably be able to complete that work by the end of class today? If you don’t have much left, you might want to expand your scope and add some addtional features or story elements. If you have too much left, you’ll need to prioritize and maybe cut some of the features or story elements you were planning. ",
    "url": "/studios/final.html",
    "relUrl": "/studios/final.html"
  },"71": {
    "doc": "Readings",
    "title": "Readings",
    "content": ". | Syllabus | What is Computer Programming? | Why Should We Teach Programming? | . ",
    "url": "/readings/first_week.html",
    "relUrl": "/readings/first_week.html"
  },"72": {
    "doc": "Readings",
    "title": "Summary",
    "content": "When writing your summary of this week’s reading, think about what you now know about programming based on the readings and based on your own experiences. There’s probably a lot you don’t fully understand right now, and that’s okay! That’s why you’re in this class. The summaries you write every week are a chance for you to reflect on what you’re learning in the class, and on how what you’re learning might relate to your life. Summary prompt: Why might programming be useful for you to learn? . ",
    "url": "/readings/first_week.html#summary",
    "relUrl": "/readings/first_week.html#summary"
  },"73": {
    "doc": "Readings",
    "title": "Question",
    "content": "Normally, there won’t be a question prompt. But since this is the first week we want to know what specific questions you have about the course. Question prompt: After reading the syllabus, what is a question or concern you have about this class? . ",
    "url": "/readings/first_week.html#question",
    "relUrl": "/readings/first_week.html#question"
  },"74": {
    "doc": "Readings",
    "title": "Turn in",
    "content": "Turn in your summary + question by going to D2L -&gt; Quizzes. This is Week 1. Please turn it in before class starts on Thursday, August 31. Caitlin will read them all before class starts and answer the most pressing questions at the beginning of class. ",
    "url": "/readings/first_week.html#turn-in",
    "relUrl": "/readings/first_week.html#turn-in"
  },"75": {
    "doc": "Studio",
    "title": "Advice",
    "content": "What follows is just advice for doing it. You don’t have to follow my advice, but some of it might help. Define Your Country . Talk with your group - if you were to create a new country, what would its values be? Who would live there? What kind of climate might it have? Coming up with a backstory for your country will help you design a good flag to represent it. Flag Symbolism . Flags are not easy to design. Flags have a lot of symbolism in them. Figure out what you want your flag to symbolize, and try to make sure that the flag conveys the symbols you want it to convey. It may help to talk with your group to decide what all is important to you and think about how you might represent those things using symbols. Flag Design . The flag should follow good flag design. Here is a pamphlet from the North American Vexillography Association that describes their 5 principles for good flag design, with examples: https://nava.org/digital-library/design/GFBF_English.pdf . Also think about what’s easy and hard about using Turtle to draw things, based on your experience with the lab on Tuesday. It’s harder to draw a flower with Turtle than to draw a circle or a square. It might help to draw out ideas on paper or using the whiteboard first. Start Simple . Start simple. First, design a really simple flag (a 2 or three color striped flag like the Flag of Italy?) and write a program to draw that. Then think about how you can make the flag more complicated or more interesting. Change the colors. Change the orientation. Change the size of the flag. If you have specific symbols you want to incorporate, think about how to make them as simple as possible while still conveying meaning. You can also think about how you might make a more complex shape using simple shapes (like squares and circles) that are drawn on top of each other. Think like a Pen . Turtle graphics are designed to be like drawing with a pen. Draw a line here, lift the pen, move it over here, put it back down, and draw another line. If you get stuck thinking about your program, figure out how you would draw the same thing with a pen. Break down the pen drawing into steps; those steps are the steps for the turtle. Again, using paper and pencil or using the whiteboard might help with this. Turtle Graphics . | Official Turtle Documentation | . If there is something you would do with a pen, you can probably do it with a turtle. There are a lot more turtle commands than what we used in the readings or in the lab. Look at the official Turtle documentation to find more commands to help you think about how to draw things. There are also loads of colors you can use in Turtle. See exercise 11 in the Turtle lab for a couple of ways to find colors. Push yourself to try new things and new features with the Turtle graphics. It doesn’t hurt to try. If you aren’t sure, try and see what happens. For example, in one single program you can have two different turtles drawing different things at the same time! . Use What You Know . You know a lot about programming already – if statements and for loops and using variables to store information and getting input from users. Use all of that knowledge to help you in you drawing. Remember you can always refer to old labs for reminders on how to do things. Stay Organized, and Use Comments . One of the hardest parts of programmming computers to draw on the screen is the sheer number of commands and instructions it takes. You will find that your programs are getting long quickly because it takes a lot of instructions to draw anything. Think about how to stay organized. You can always add blank lines; use that to group sets of commmands. So if you’ve got one set of commands that draws a blue square, and another that draws a white star, leave a blank line in between them. Also, use comments (lines that start with # that don’t get read by Python) to tell yourself what those chunks of code do, logically. Its hard to understand what fd(10); right(120); fd(10); right(120); fd(10) does. It is much easier if you label this with # Draw a triangle: . # Draw a Triangle fd(10) right(120) fd(10) right(120) fd(10) . Adding comments to your code is a really good way to remind yourself (and your group mates!) what the code is doing as your program gets longer. Use Programming’s Strengths . Your flag is a computer program. That means that it can do things that other flags cannot. Think about how you can use programming to make your flag more interesting than just a flat drawing. For example, could you animate something on the flag, or have a special way of drawing the flag? Or maybe you can ask the user for some input, and then customize the flag around that input. Maybe you can use the random library to make the flag have different dimensions every time the program is run. Programming can be an artistic tool. And unlike other artistic tools, like paintbrushes or clay, programming can be very dynamic and interactive - it can produce things that are different each time the program runs. How can you harness this strength of programming to make your flag unique? . ",
    "url": "/studios/flag.html#advice",
    "relUrl": "/studios/flag.html#advice"
  },"76": {
    "doc": "Studio",
    "title": "Studio",
    "content": "Today we are going to practice Vexillography – the art of designing flags! . Imagine that you and your teammates are going to go and start your own country. This isn’t so crazy at it sounds; not too long ago, a family colonized an old weapons platform outside England and created the Principality of Sealand. Others have claimed islands in the Pacific Ocean or tried to create floating countries. What all countries need is a flag. Your job today is to design a flag for your group’s new country, and then write a Python program that draws that flag on the screen using the turtle package. ",
    "url": "/studios/flag.html",
    "relUrl": "/studios/flag.html"
  },"77": {
    "doc": "Studio",
    "title": "Today’s studio",
    "content": "Your goal today is to write a flash card program to help someone study a specific topic. The topic is up to you. Your program should do these things: . | Display a prompt (the question), and ask the user to input their response (the answer). | Tell the user if the response is correct or not. | Keep asking a question until the user gets it right. | Once a question is answered correctly, move on to the next flashcard. | Optional: keep track of how many tries each flashcard took to answer correctly and print that out at the end. | . It is OK if it always prints out the flash cards in the same order every time. We will learn how to make things in different orders later in the semester. ",
    "url": "/studios/flashcards.html#todays-studio",
    "relUrl": "/studios/flashcards.html#todays-studio"
  },"78": {
    "doc": "Studio",
    "title": "Git",
    "content": "Store your project in a git repository on the MSU GitLab. You’ll need to make a new repository for you and your group - it’s easiest to do this first, before you start writing any code. Only one person in the group needs to create a repository; once it’s shared, everyone else in the group will have access to it. Remember to add Caitlin (geierac) and Jack (waierjac) as members along with your groupmates. See the Using Git in the Reference section for a refresher. ",
    "url": "/studios/flashcards.html#git",
    "relUrl": "/studios/flashcards.html#git"
  },"79": {
    "doc": "Studio",
    "title": "Advice",
    "content": "What follows is advice for doing this. You don’t have to follow this advice. Do whatever you want. This is just my experience in doing this, and you might want to do it differently. That’s ok! . Make it useful . Try to make this program actually useful. The easiest way is if you make the flashcard app for something you are already trying to learn. For example, maybe you have some vocabulary or dates you need to know for one of your other classes. Or it can be something related to a hobby or interest you have, like remembering which player is on which baseball team (Question: What team is Julio Rogriguez on? Answer: Seattle Mariners), or who trivia about favorite novels (Question: Who wrote American Gods? Answer: Neil Gaiman). If you can’t think of anything you might want to test yourself on, you can create a flashcard program for someone else; for example, create a program to help a middle school student remember biology facts, or a high school student remember world history, or an elementary school student study multiplication. Or make a program that could be used for playing trivia night at a bar or cafe. Do your research . Just because you are making the program doesn’t mean that you have to already know everything! Then why would you need the app? Instead, plan on doing some research to figure out what things you need to learn. Spend some time with Google trying to make a list of the things you would need to learn, and then spend some time on paper trying to turn those into flash cards. Also, remember that flash cards work best for facts – things with a right or wrong answer that you need to memorize. They don’t really help much with other types of learning, like learning how to write, or how to pronouce words in foreign languages, or how to develop your own style. Input, if, print . There are many different ways to make flash cards. But at their simplest, they are an input statement to ask the user for the response, and an if/else statement to check if it was correct. Get the basic pieces working before making it more complex. question.py from the lab this week might be useful to look at. Loop until correct . For each flash card, what happens when the user enters the wrong answer? Make your program tell the user that it was wrong, and then ask them again for the answer. Put this in a loop so that they keep getting asked until they get it right. Some of the exercises you did for this week’s lab might be helpful. Start simple and test often . Don’t try to do everything at once. Start with something really simple, test it until it works, and then build from there. For example, the first thing you should do is probably just have it print one prompt, and then end. Get that working first. Then write your first input, that asks the user for the response and checks if it is correct. Just print out whether it is correct. Once that works correctly when you run it, then you can add a second flash card. But don’t move on add anything new until everything you’ve already written works correctly. One thing to keep in mind is testing. You want to test the program, over and over, to make sure it does the right thing. Run it multiple times. Put in the right answer. Put in a wrong answer. What happens? Have a teammate run it. Does it work right for them? You should be spending a large amount of your time actually running your program over and over to see if it is working the way you expect it to. This also means that you don’t need to have the whole set of flash cards written before you start writing your program. Get the first one or two written, then try to make it work as a computer program. Once you’ve got those written, write on or two more and make them work as a computer program. Alternate between writing flash cards and writing code. If you try to do it all at once, the its easy to get bogged down in unimportant details. By going back and forth between flashcard writing and coding, you make sure that each activity works well with the other activity. Also, it is best to get a basic flashcard program working, where you only get one try for each card, and then later add in the retry feature that asks them over and over until they get it correct. Follow pair programming . In the lab, you practiced pair programming, with two people using one computer. One person was the driver, controlling the keyboard and mouse, and the other person was the navigator, helping out and thinking. Do that again here. It really does help get things working easier. If your group has more than 2 people, rotate the driver frequently so everyone gets a chance to write some code; the people who aren’t driving can help by using Google, coaching, and writing flashcards. Take Turns . Take turns doing the different parts of the work. Don’t have one person be the “programmer” and the other be the “flash card writer”. Instead, take turns. Have one person in front of the computer programming for 10-20 minutes and then swap to another person. The original programmer can then take a turn with Google looking up facts. Taking turns keeps things interesting as you work, and makes it easier to collaborate and produce something more interesting than you could do yourself. Remember to use Git for this! When you trade places, the old driver should add, commit, and push their code to the GitLab repository for the studio. The new driver should use git pull to get the changes onto their computer before starting to write new code. ",
    "url": "/studios/flashcards.html#advice",
    "relUrl": "/studios/flashcards.html#advice"
  },"80": {
    "doc": "Studio",
    "title": "Studio",
    "content": "Research on how people learn has suggested that, when learning facts, one of the most important things to do is to periodically “retrieve” the information from your memory. That is, if you occasionally remember those facts and use them in some way, then you are more likely to remember them long-term. One of the keys is to remember the fact, but not recognize it. That is, it has to come from your brain, and not from something else like notes or a book or a web page. Doing this remembering periodically, over time helps you remember those facts long-term. To help people with this, one of the most common ways of remembering a bunch of facts is Flash Cards. Flash cards used to be physical note cards with a prompt on one side (“What is 2 + 3?”) and an answer on the other (“5”). You use them by reading the prompt and trying to remember the answer. Once you remember the answer, then you can flip the card over and check if your answer was right. Flash cards are also nice because you can measure progress; you can count the number you get right, and tell whether you are remembering more or less than in the past. Now, instead of physical note cards, most people use flashcard apps on their computer, phone, or tablet to accomplish the same goal. ",
    "url": "/studios/flashcards.html",
    "relUrl": "/studios/flashcards.html"
  },"81": {
    "doc": "Readings",
    "title": "Readings",
    "content": ". | Think Python: Functions | Automate the Boring Stuff: Functions – stop reading at “Local and Global Scope” | . ",
    "url": "/readings/functions.html#readings",
    "relUrl": "/readings/functions.html#readings"
  },"82": {
    "doc": "Readings",
    "title": "Summary",
    "content": "For the summary this week, think about what you’ve learned about functions, and whether anything else you’ve encountered outside of the class is similar . Summary prompt: How would you describe what a function does, and what it’s for? How is a function different from a variable? . ",
    "url": "/readings/functions.html#summary",
    "relUrl": "/readings/functions.html#summary"
  },"83": {
    "doc": "Readings",
    "title": "Question",
    "content": "As per usual, your question can be one of three types: . | Confusion: what didn’t you understand in the readings? | Curiousity: what do you want to know more about? | Connection: how does this topic connect to your own experiences? | . Submit your summary+question on D2L under Quizzes before class starts on Tuesday. ",
    "url": "/readings/functions.html#question",
    "relUrl": "/readings/functions.html#question"
  },"84": {
    "doc": "Readings",
    "title": "Readings",
    "content": "Functions are a nice way to organize your code and make it reusable. We’ve already been using functions a lot in this class: print() is a function that’s built into Python, and forward() and right() are functions that are built into the Turtle library. This week you’ll start writing your own functions. ",
    "url": "/readings/functions.html",
    "relUrl": "/readings/functions.html"
  },"85": {
    "doc": "Lab",
    "title": "Part 1 - Setting Up Git",
    "content": " ",
    "url": "/labs/git_and_gitlab.html#part-1---setting-up-git",
    "relUrl": "/labs/git_and_gitlab.html#part-1---setting-up-git"
  },"86": {
    "doc": "Lab",
    "title": "Make a copy of the repository for your pair (only do this once!)",
    "content": "At the top of this page, there is a link to this week’s GitLab project. Click on that link and open it in a new window. What opens is a web interface to a repository for the base version of this lab. You will have to log into GitLab with your NetID and password in order to be able to see the project and repository. GitLab is a system hosted by MSU that hosts repositories and allows you to create new ones. Each project in GitLab is a Git repository. GitLab allows you to share them with other people as much as you want, for free. Fork the project . The first thing you will do is to fork the project. Forking a project means making a new project that is a copy of an existing project. IMPORTANT: only one person in your pair should do this step each week. Usually this will be whoever’s driving first. You only need one copy of the project between the two of you. To do this, look for the “fork” button on the top right of the project page and click it. It will ask you for a ‘namespace’: there should be only one option, with your name. Click on that to start the forking process. Forking will take a moment. Once it finishes, then it will take you to the new project. The new project should look almost the same as the original – it is a copy, after all! The main difference is if you look at the top, instead of saying “MI-250 / Git and Gitlab”, it should say your username now. If it does, then great! It worked! If not, then ask the instructor or TA for some assistance. (Note: sometimes you may get a 404 Error page. That happens when forking is slow. Just wait a minute and hit “refresh” and it usually fixes itself.) . Give other people access to the new project . The first thing you should do after forking a project is to give your partner, Caitlin, and Jack access to the project. In the menu on the left, find “Manage” and then go to “Members”. This is the page where you can give other people access. Click on the blue “Invite Members” button on the top right. A window will pop up. Search for your partner in the “username or email address” box – the easiest way is to search for their MSU NetID. Also search for and add Caitlin (geierac) and Jack (waierjac). Then change the “role permission” to “Maintainer” – the highest level of permissions. You don’t need to add an expiration date. When you’re done, click the “Invite” button at the bottom of the window. The three people you added (your partner, Caitlin, and Jack) should show up in the member list. Make sure your partner can access your forked project . Next, the navigator (who was just added to the project) should try to log into Gitlab https://gitlab.msu.edu and click on “Projects” -&gt; “Your Projects”. They should see the “Git and Gitlab” project on the list, and be able to click on it and view the files inside of it. Congrats! You’ve now got your first GitLab project! Good work! . ",
    "url": "/labs/git_and_gitlab.html#make-a-copy-of-the-repository-for-your-pair-only-do-this-once",
    "relUrl": "/labs/git_and_gitlab.html#make-a-copy-of-the-repository-for-your-pair-only-do-this-once"
  },"87": {
    "doc": "Lab",
    "title": "Set up your computer to use the new git repository",
    "content": "NOTE: remember to practice pair programming for this section! Get everything working on one person’s computer first before you start trying things on the second person’s computer. This will make things easier in the long run, I promise! . You’ve now got your own project, but right now it only exists on GitLab. That’s great – it is on a webpage where others can see it also. But you need to be able to edit and run the programs on your own computer. To work with the files in the repository on your own computer, you could download the files like we did last week. But it’s hard to share files with your partner that way (as you may have discovered last week). Instead, we’ll be using Git. What Git allows you to do that simply downloading the files doesn’t is to make a two way street between the files on your computer and the files in the repository on GitLab. Git allows you to make changes to the versions of the files on your own computer and then to easily push those changes back up to GitLab so that other people (like your partner) can access them. Git is a tool that is built to allow programmers to easily share code with one another. Install Git . The first thing you’ll need to do is download and install Git onto your computer. You can download the Git installer from the Git Downloads Page. On Mac: . If you are on a Mac, choose the “Binary Installer”. On Windows: . On Windows, it will ask you a lot of questions. Just click next on all of them. Once you’ve got Git installed, open up a command line window (Powershell on Windows or Terminal on Mac). If you just type the command git, it should print out a bunch of help information about the different git commands. If it does that, then you’ve got git installed correctly! If you get an error message, then you haven’t installed Git correctly yet. Try running the installer you downloaded again. Tell Git who you are . The first thing you need to do to set up Git is to tell it who your are. Use the following two commands to tell it who you are, substituting your name and email address for mine: . git config --global user.name \"Caitlin Geier\" git config --global user.email \"geierac@msu.edu\" . Be sure to keep the quotation marks. You should only need to do this step once on your computer. After that, it will remember who you are. Create a GitLab Access Token . To get files from Gitlab using Git, you need to use something called an “Access Token”. This is kind of like a passkey that you give to GitLab to let it know that it’s you. To create an access token, go back to the GitLab webpage and click on the profile image in the upper right hand corner of the page. It should bring up a user menu with your name at the top – choose “Preferences” in that menu. Once you’re on the Preferences page, find the menu item on the left hand menu for “Access Tokens”. If you can only see icons on the left, the icon looks like an oval with three dots (…) in it. On the Access Tokens page, create a new Personal Access Token. Steps: . | Type in your NetID in the “Token Name” field. | Choose an expiration date that is at after the class ends - like December 31, 2023. | Important: click the “write_repository” checkbox. If you don’t, your token won’t let you access the files inside your repositories. When done, click the “Create personal access token” button. The webpage will reload, and near the top, it will print out a new “access token” which is basically a randomly generated password for you to use. | . Write down this access token!!. (Or copy-and-paste it somewhere you can find it.) . You should only need to do the access token thing today; after completing this lab, Git should remember it and never ask you again. ",
    "url": "/labs/git_and_gitlab.html#set-up-your-computer-to-use-the-new-git-repository",
    "relUrl": "/labs/git_and_gitlab.html#set-up-your-computer-to-use-the-new-git-repository"
  },"88": {
    "doc": "Lab",
    "title": "Clone the repository",
    "content": "Cloning a repository is always done in three steps: . | Fork the repository (you will do this for every lab) or create a new repository (for studios) | In command line, use cd to navigate to the place on your computer where you want the repository to live | Use the git clone command to clone your repository onto your computer | . Step 1: Forking the repository . You already did this step above! Make sure you’re on the page for your forked repository on Gitlab. One way to tell if you’re in the right place is to make sure your name shows up in the breadcrumb links above the name of the repository. If it says MI 250 instead, you’re not in the right place. Step 2: Navigate to the right place in command line . On your computer, you should make a place to keep your work for this class – all of the labs and studios that you work on. Me, personally, I created a folder on my desktop called “MI 250” and keep everything in there. But its your computer, and you can put it wherever you want (so long as you remember where it is!). To get a repository on your computer, you need to “clone” the repository – which means using Git to make a copy of the repository that will live on your computer and will talk to the copy that’s on Gitlab. Open up your command line program (Terminal on Mac or PowerShell on Windows). Then change directories to the directory where you want to keep your files using the cd command. Check out the command line reference if you need help remembering how to do this. Step 3: Git clone . If you look at the project page for your forked repository, in the upper right hand corner there is a blue button labled “Clone”. If you click on that, you get two options: “Clone with SSH” and “Clone with HTTPS”. Those are just two different ways of accomplishing the same thing. In this class, we will always use “Clone with HTTPS”. Click the “Copy URL” button that looks like a clipboard icon next to the HTTPS option: it will copy a link to the repository onto your clipboard. Next, we will use a git command in command line to clone the project. By default, this command will clone the project into whatever directory you are currently in on the command line. That’s why it was important that we cd into our folder for this class before running this command (see Step 2 above!). The command to use git to clone a project onto your computer is git clone to clone the project. In command line, type in git clone and then paste in the HTTPS link that you copied from the Gitlab website. It should look something like this: . git clone https://gitlab.msu.edu/geierac/git-and-gitlab.git . When you do this, it will ask you for your username and password. Don’t enter your real password! Instead, log in with your NetID (don’t include @msu.edu) and then use your newly created “access token” as the password. If this works, then it should print out information telling you it is “receiving objects”, which means it is downloading the files for the repository for you. Once the repository has downloaded, you will get a prompt on the command line again. If you use the command ls, you should see a new directory called “git-and-gitlab”. Change directories into that using the command cd git-and-gitlab. If you do an ls again, you’ll see that all of the files from the repository have now been downloaded onto your computer and are there for you to work with. If you look at the folder in Exporer/Finder, then you should also see the files. IMPORTANT: The new folder that appeared on your computer represents the repository. Anything inside that folder will talk to the repository on Gitlab. If you change the name of the folder or move files outside of it before you work on them, the link between the folder on your computer and the Gitlab repository will be broken. ",
    "url": "/labs/git_and_gitlab.html#clone-the-repository",
    "relUrl": "/labs/git_and_gitlab.html#clone-the-repository"
  },"89": {
    "doc": "Lab",
    "title": "Make a change to a file on your computer and “push” it to Gitlab",
    "content": "Next, let’s make a change. Open up the file README.md in your text editor. Right now, it has my name (Caitlin Geier) in there as the author. That’s no longer accurate, though – this is YOUR repository now! Change the name to your name. Add, Commit and Push the change . You’ve made a change to README.md on your local computer. But if you go look at the file in the repository on GitLab, it still has my name in it. That is because you haven’t committed or pushed your change; that is, the change only exists on your computer. The idea behind Git is you can make all sorts of changes on your own computer that may or may not work. Since they’re only on your computer, you won’t break the code for everyone else who uses the repository. Once you get things working, then you can save those changes to the official repository (which lives on Gitlab) so that other people can access the new, working code. There are three steps to getting your code from your computer up to the repository that’s shared with other people: add, commit, and push. We’ll go through each of these one by one. Add . Start by running the status command on the command line: . git status . This command will show you the current status of the version of your git repository that is on your computer. It will let you know if any files have been modified since the last version you got, and if any files have been added or deleted. You should see that you’ve modified the README.md file. It’s good practice to run git status regularly when using Git. It’s especially helpful for troubleshooting issues. The first step is to let Git know what changes go together. Sometimes you make changes in multiple different files and you want all of those changes to logically go together as one commit. To do this, git has what it calls a “staging area” – a place you put changes until you’ve got the whole set of them together. You use the command git add to add things to this staging area. You can run this command multiple times if you want to add changes from more than one file to the same commit. We only have one file with changes – README.md – so we only need to add one file to the staging area. Let’s do so with the git add command: . git add README.md . If your git add command works correctly, then it won’t print anything out. It will just give you a new prompt. If it doesn’t work, then you’ll get an error message. Tip: If you’ve made changes to multiple files and you want them all to be added to the staging area, you can use what’s called a modifier. The modifier -a stands for “all”. You can use it like this: git add -A . Note: On many systems, the filename is case sensitive; so if you get an error message, try to make sure the case is correct. Commit . Once you’ve got all the changes together in the staging area, the next step is to “commit” those changes. Committing the changes takes all those changes, and creates a new version of your program that has those changes. That is, it formally records that these changes compromise a new version of your program. To do this, we use the command git commit. git commit -m \"adding my name to README\" . Whenever you make a commit, you need to add a message explaining, very briefly, what changes you’ve made and why. -m is a modifier that stands for “message” and you add your message in quotes after it. The purpose of the message is so that you and the other programmers and the project can all tell what’s been changed and why. Push . Committing the changes only records the changes in the clone of the repository that is on your computer; those changes haven’t gotten to Gitlab yet. That’s what git push does – it takes any changes that are on your current computer that you’ve committed, and it pushes them up to the main repository on Gitlab. Run that command now: . git push . Now go check the version of your repository that’s on Gitlab. Don’t forget to refresh the page. When you look at the README.md file, it should have your name in it now instead of my name. That means that you have successfully commited your first change to a git repository! Good work! . ",
    "url": "/labs/git_and_gitlab.html#make-a-change-to-a-file-on-your-computer-and-push-it-to-gitlab",
    "relUrl": "/labs/git_and_gitlab.html#make-a-change-to-a-file-on-your-computer-and-push-it-to-gitlab"
  },"90": {
    "doc": "Lab",
    "title": "Swap and Repeat",
    "content": "The biggest benefit of Git is collaboration – it makes it easier to work on the same code with other people. The next step of today’s lab is to learn how that works by swapping roles. The current driver (the person at the keyboard) will become the navigator, and the navigator will become the driver. Go through all of the same steps, starting with “Set up your computer to use the new git repository” on the new driver’s computer. When you edit the README file, add your name to the file, so that it says “By: Partner’s Name and Your Name”. Be sure to add, commit, and push the changes, and then check on the GitLab to make sure that the changes you made appear there. Once you’ve done this correctly, then there should be a single Git repository in Gitlab for you and your partner and both members of the pair should have a clone of that Git repository on their personal computer. Either person can work on the program, and then commit and push changes back to the repository at any time. This makes collaboration easier, because both people have a copy, and both people can work on it. The code you turn in today will be the code that you and your partner have both contributed to on GitLab – your Gitlab repo is what you’ll turn in. ",
    "url": "/labs/git_and_gitlab.html#swap-and-repeat",
    "relUrl": "/labs/git_and_gitlab.html#swap-and-repeat"
  },"91": {
    "doc": "Lab",
    "title": "Git Pull",
    "content": "Swap roles again, so that the original driver is now driving again using their own computer. If you look at the files on your computer, then you’ll notice that the newest change – the one that adds the navigator’s name to README.md – aren’t there. What is happening is that there are changes in the main GitLab repository, but they haven’t been copied down to your computer yet. To do that, we can use the command git pull. This command will take all of the changes that are in the main repository on GitLab and pull them down to your computer. Run that now: . git pull . Now open the README.md file in the text editor on your computer, and you should see the changes, including both people’s names. You want to run this command any time that your partner makes any changes and then commits and pushes those changes to the repository. Always remember to use git pull before you start working to make sure you have all the latest changes. ",
    "url": "/labs/git_and_gitlab.html#git-pull",
    "relUrl": "/labs/git_and_gitlab.html#git-pull"
  },"92": {
    "doc": "Lab",
    "title": "Part 2 - Programming",
    "content": "Now that you’ve got the Git repository and have figured out how to contribute to it, we can start working on programming in the files in that repository. We are going to begin with the program bottles.py, which is a simple program that prints out lyrics to a song – the song 99 bottles of beer. The first thing to do is to run the program on the command line: . python bottles.py . You should see it print out two verses of the song. ",
    "url": "/labs/git_and_gitlab.html#part-2---programming",
    "relUrl": "/labs/git_and_gitlab.html#part-2---programming"
  },"93": {
    "doc": "Lab",
    "title": "Exercise 1: Change the beverage",
    "content": "Right now, the song is being sung about water. The original song was about beer. What is your favorite beverage? Pick a new beverage, and change the song so that it is being sung about your favorite beverage. ",
    "url": "/labs/git_and_gitlab.html#exercise-1-change-the-beverage",
    "relUrl": "/labs/git_and_gitlab.html#exercise-1-change-the-beverage"
  },"94": {
    "doc": "Lab",
    "title": "Exercise 2: Last verse",
    "content": "The last verse gets down to zero bottles. No one likes singing about “zero” bottles. Most of the time, that last verse gets modified. For example, the Wikipedia article lists “No more bottles of beer on the wall, no more bottles of beer.” as the last verse. Create a last verse that is more interesting for the song; one that doesn’t use the word or number “zero”. ",
    "url": "/labs/git_and_gitlab.html#exercise-2-last-verse",
    "relUrl": "/labs/git_and_gitlab.html#exercise-2-last-verse"
  },"95": {
    "doc": "Lab",
    "title": "Exercise 3: Save your changes using Git",
    "content": "OK, now you’ve made some changes to your bottles program. The next thing you should do it commit that code to your git repository. Use the same sets that you used above – git add &lt;filename&gt;, git commit -m \"&lt;message&gt;\", and git push – to commit those changes and push them back to the main repository on Gitlab. ",
    "url": "/labs/git_and_gitlab.html#exercise-3-save-your-changes-using-git",
    "relUrl": "/labs/git_and_gitlab.html#exercise-3-save-your-changes-using-git"
  },"96": {
    "doc": "Lab",
    "title": "Exercise 4: Swap driver and navigator",
    "content": "Now, swap driver and navigator. On the new driver’s computer, you should then git pull. Run the program again with python bottles.py and make sure that the your computer has all of the changes that your partner made for the previous exercises. ",
    "url": "/labs/git_and_gitlab.html#exercise-4-swap-driver-and-navigator",
    "relUrl": "/labs/git_and_gitlab.html#exercise-4-swap-driver-and-navigator"
  },"97": {
    "doc": "Lab",
    "title": "Exercise 5: 5 bottles",
    "content": "The song right now starts with only 2 bottles. That’s not very many. Expand the song to start with 5 bottles of your favorite beverage, and then count down until there are none left. ",
    "url": "/labs/git_and_gitlab.html#exercise-5-5-bottles",
    "relUrl": "/labs/git_and_gitlab.html#exercise-5-5-bottles"
  },"98": {
    "doc": "Lab",
    "title": "Exercise 6: Git Commit",
    "content": "OK, now you’ve made some more changes to your bottles program. You should commit that code to your git repository. Use the same sets that you used above – git add &lt;filename&gt;, git commit -m \"&lt;message&gt;\", and git push – to commit those changes and push them back to the main repository on Gitlab. Then, swap again, and have the other person git pull on their computer. Make sure all of the new code you both added to bottles.py are on both of your computers AND in your GitLab repository. ",
    "url": "/labs/git_and_gitlab.html#exercise-6-git-commit",
    "relUrl": "/labs/git_and_gitlab.html#exercise-6-git-commit"
  },"99": {
    "doc": "Lab",
    "title": "Challenges",
    "content": "If you have gotten through all of the exercises and tried out Git on both of your computers, great work! If you still have extra time before class ends, do at least one of the challenges below. Challenge 1: Count . The GitLab repository for today has another Python program in it called count.py. Run the program. What does it do? . What happens if the user enters something other than Up or Down? Probably nothing good. Edit the program so it can account for case and for other options for user input, like ‘u’ for Up or ‘d’ for Down. Also add an error case for if the user types something other than the accepted inputs. (Hint: use else!) . Remember to add, commit, and push your changes to Git when you’re done. Challenge 2: Bottles or something else? . In bottles.py, beverage is a variable that is replaced with something else. What else can you replace in the song to make it different? What if your beverage of choice comes in cans? What if the drinks are in the refrigerator instead of on the wall? Pick a word to replace and use a variable to replace it throughout the song. ",
    "url": "/labs/git_and_gitlab.html#challenges",
    "relUrl": "/labs/git_and_gitlab.html#challenges"
  },"100": {
    "doc": "Lab",
    "title": "Turning in your work",
    "content": "Take screenshots of your code working in command line, as per usual, and upload them to D2L under Assignments. If you got all of your changes up in your GitLab repository, you’ve already turned in your code for today! This is how you’ll turn your code in every class from now own. Make sure Caitlin and Jack are both added as members to your repository (see Give other people access to the new project) . ",
    "url": "/labs/git_and_gitlab.html#turning-in-your-work",
    "relUrl": "/labs/git_and_gitlab.html#turning-in-your-work"
  },"101": {
    "doc": "Lab",
    "title": "Troubleshooting",
    "content": " ",
    "url": "/labs/git_and_gitlab.html#troubleshooting",
    "relUrl": "/labs/git_and_gitlab.html#troubleshooting"
  },"102": {
    "doc": "Lab",
    "title": "Troubleshooting git clone",
    "content": "Sometimes, you get an error message when you try to download the repository using git clone. NetID . When you run git clone the first time, it asks you for your username and password. The most common problem is that students put user@msu.edu in the box. Do NOT do that. Just put your username in the box – do NOT put the @msu.edu part. If you did that, then try running git clone again, and use the correct username. If it doesn’t ask you for your username, then Git is trying to remember your (incorrect) username. Windows remembering your password . When you first run git clone, git will ask you for your username and password. both MacOS and Windows will remember these – it won’t ask you for them again after the first time. However, sometimes you get something wrong the first time. Generally Mac handles this well – if it didn’t work, then Mac will prompt you again next time. However, Windows sometimes remembers this wrong username/password, and then git commands don’t work. To fix this, go down to the start bar and search for “Windows Credential Manager”. On the page that comes up, look through the list for the Git/GitLab credential. I usually just delete the entry for Git/GitLab. Then try running git clone again, and it should prompt you for your username and password. ",
    "url": "/labs/git_and_gitlab.html#troubleshooting-git-clone",
    "relUrl": "/labs/git_and_gitlab.html#troubleshooting-git-clone"
  },"103": {
    "doc": "Lab",
    "title": "Troubleshooting git commit",
    "content": "This section contains extra instructions for troubleshooting problems with git commit. Specifically, do this if no file opens when you git commit and you immediately get an error message. If you type in git commit without the -m \"message\" at the end, Git will either give you an error or will try to open a text editor for you to type the message in. This isn’t a big deal on Windows. If it opens up a text editor window, close the window. Go back to command line and try again, making sure to add the message this time. On Mac, it might open up a new screen inside Terminal. Terminal has a very old text editor called Vim built into it which is hard to use. To get out of it, type: . :wq . and then hit Enter. You can also close the Terminal window and reopen it. ",
    "url": "/labs/git_and_gitlab.html#troubleshooting-git-commit",
    "relUrl": "/labs/git_and_gitlab.html#troubleshooting-git-commit"
  },"104": {
    "doc": "Lab",
    "title": "Git conflicts",
    "content": "If multiple people are making changes to a repository at the same time, sometimes there can be conflicts. This especially happens in studios, where different people might be working on different aspects of the studio at the same time. A few tips for avoiding conflicts: . | Always use git pull before you start working on a file to make sure you have the most updated version. | When you’re done working on a file, always add, commit, and push your code to Gitlab. | . Don’t worry if you run into a conflict; Caitlin and Jack are always around to help you resolve them! . ",
    "url": "/labs/git_and_gitlab.html#git-conflicts",
    "relUrl": "/labs/git_and_gitlab.html#git-conflicts"
  },"105": {
    "doc": "Lab",
    "title": "Git reference",
    "content": "I’ve put together a quick reference for Git on this site: Using Git . ",
    "url": "/labs/git_and_gitlab.html#git-reference",
    "relUrl": "/labs/git_and_gitlab.html#git-reference"
  },"106": {
    "doc": "Lab",
    "title": "Lab",
    "content": "In this week’s readings, you read about version control and Git. A Git repository is a specific, named collection of files that usually make up a single program. You’ve already used git repositories in this class - all of the files for last week’s lab were stored in a git repository, which you accessed through the Gitlab website. Today, the first thing you are going to do is to get your OWN copy of the repository for this week’s lab on your computer - not by downloading it, like last week, but by having Git make a copy of it on your computer. ",
    "url": "/labs/git_and_gitlab.html",
    "relUrl": "/labs/git_and_gitlab.html"
  },"107": {
    "doc": "Studio",
    "title": "Advice",
    "content": "What follows is just advice for doing it. You don’t have to follow my advice. Do whatever you want. This is just my experience in doing this, and you might want to do it differently. Be creative! . Use Turtle . You spent last week learning Turtle graphics. Use Turtle to make a visual guestbook that looks nice. Be creative in how it looks, and get the guestbook to look interesting. Remember you can more than just writing out names - you can draw shapes and use different colors and fonts, too. Refer to the Turtle lab if you need a reminder on how to do certain things with Turtle. The Turtle documentation is also a very helpful resource. Use lists . We learned how to use lists this week. Think about how you can approach this using lists. You can add things (like user input) to a list, or sort the list (for example, alphabetically). You can also use a for loop to iterate through a list, item by item. For example, this structure . for item in stuff: print(item) . will go through the list called stuff and will print out each item in the list one by one. Think about how you might want to use lists. Do you want to have everyone add their names to the guestbook first and print it out at the end? Or have it draw out new names using Turtle as they’re added? How would you use a list to store and retrieve the names in each case? . Start simple, then expand . Start with something simple. For example, you could start by getting a really simple guestbook working for just one guest: ask for user input, then draw the user input using Turtle. Then modify it so the name looks nice. Then add a loop so it asks for user input over and over and prints out each name. Then store the names in a list, and print out the list. Or something like that. There are lots of different ways to do this. Think about how to build up features. Wait to do the fancier, more complex features until you have the basic features working well. Use interesting fonts . The write() function in Turtle graphics allows you to specify the font and size. So, for example, you can write: . write(\"Welcome to my Guestbook\", font=(\"Arial\", 30, \"normal\")) . Or . write(\"Please enter your full name\", font=(\"Helvetica\", 12, \"italic\")) . There is a python program here that will give you a list of all the fonts on your computer. Another trick is to open up Microsoft Word and look at the fonts Word lets you use - if there is no cloud icon next to the name of the font in Word’s font list, that means it’s already installed on your computer. Use randomness . Remember you can pull random items out of a list! If you have, for a example, a list of fonts or a list of colors, you can use random.choice() on the list to pull a random item from it. That might be an interesting way to make your guestbook look unique. What other parts of your geustbook design can you apply random features to? . Test your program . Test your program frequently. Every time you add a few lines of code, test it to make sure it works. It’s easier to debug programs if you know the bug is somewhere in the last 2 lines you typed out, rather than having to go through the entire program to figure out what went wrong. ",
    "url": "/studios/guestbook.html#advice",
    "relUrl": "/studios/guestbook.html#advice"
  },"108": {
    "doc": "Studio",
    "title": "Studio",
    "content": "For this week, your goal is to make a digital guestbook. Traditionally, a guestbook is a physical book left near the entrance for an event (like a wedding or funeral) or a place (like a museum). Guests can sign their name and maybe leave a message, and the guestbook acts as a record of who was there. Your goal is to create a digital guestbook. Imagine it being left running so people can enter their names and possibly leave a message. There should be a way to view all of the previous guests, as well as a way for the user to add themself as a guest. Whether people can leave a message along with their name is up to you, as is whether they can add additional information. Use Turtle as the interface for the guestbook - the names and any additional information people enter into the guestbook should be displayed using Turtle. Work in teams of 2-4. One person should start a new repository in GitLab so your team can share code. ",
    "url": "/studios/guestbook.html",
    "relUrl": "/studios/guestbook.html"
  },"109": {
    "doc": "Honors Option",
    "title": "Honors Option: Contract Programming",
    "content": "Most programming work is broken up into different parts, which are usually done by different people. The first part is the specification: deciding what the program needs to do. Specifications are hard because they need to provide enough detail about what the program will need to do that someone else can program. The second part is the implementation, which is writing the main code that (hopefully) accomplishes what the specification says it should The third part is the testing, which checks the main code to see what it does and does not do, to make sure that it accomplishes what it is supposed to do. We are going to do that – specification, implementation, and testing – around a small app. | First, you are going to need to write a specification. Look through the studios for this class, and choose one of them that you find interesting. (You do not need to choose the same studio as your partner.) You will write a specificaiton for a program that fulfills that studio. The specification will need to provide a lot more detail than the studio does, and get you to make decisions about exactly what you want build. The studios are intended to provide space for creativity – but when you are writing a specification, you don’t want to let the programmer be too creative or you will get back something very different than what you intended. So you will have to be creative yourselve, when creating the specification, and be very specific about what you want to the programmer to provide. For example, if you chose Studio 3: Flashcards, you would need to decide what topic you want your flashcards to be about, how many flashcards you want, and write the content for the flashcards compete with prompts and answers. Also, decide what you want the program to look like. What functions should exist? What interface shoudl it have? Should it ask repeatedly until answered correctly, or move on and count wrong answers? You will not be writing the code for this; someone else will. You are just specifying what code you want written, and what it should do once it is finished. Think about how you want someone else to write the code. As you write the specification, remember that the programmer will have about 2 hours to implement this. How much could you get done in 2 hours? What is reasonable to ask for in 2 hours? . | Next, we will swap with partners. Your partner will take your specification and try to implement it. They will write code that tries to do what you specified. And, conversely, you will try to write the code that they specified. They will ask you to do things differently than you asked. Your job will be to do what they asked, not what you envision. | Finally, we will swap back. You will be given a working version of what you specified. Your job now will be to test it: did they do what was asked? What works? What doesn’t? Re-read your specification and compare the program you were given against it. Think about whether the code that you were handed actually works the way you think it should. If it doesn’t, is what the code does reasonable, or would you describe it as a bug or a failure? . | After you’ve gone through all three steps – specification, implementation, and testing – please write up a short reflection. What was the process like? Waas it hard to write a specification that you weren’t going to program yourself? Did the other person interpret things similarly to you or differently than what you imagined? Did you get back something close to what you expected? Did everything work well, or were there bugs in the code? Was it hard to write code where someone else decided what the program should do? Or was it easier because you knew exactly what the proram was supposed to do? (Also, think about all the questions and ideas in the “Is this fun?” heading above.) . | . The reflection doesn’t need to be long; a paragraph or two about what its like to ask someone else to write code, and another paragraph or two about what its like to be the programming doing work for someone else should be enough. What follows is just advice for doing it. You don’t have to follow my advice. Do whatever you want. This is just my experience in doing this, and you might want to do it differently. ",
    "url": "/honors.html#honors-option-contract-programming",
    "relUrl": "/honors.html#honors-option-contract-programming"
  },"110": {
    "doc": "Honors Option",
    "title": "Advice",
    "content": "Be Detailed and Specific . The specification is your contract; it tells the other team what you want done. The more specific you can be, the more likely you are to actually get what you want. If you are doing flashcards, Don’t just say “do some math problems” – how will they ever know what that means? If you just say “do some math problems”, then they might give you back flashcards for grade school math (2+2=4), or they might give you back calculus problems. Which one die you want? Instead, give them exact problems for the flashcards. Tell them exactly how many flashcards. Think about how you would implement it, and give them some structure that they can use to make it work correctly. Do you want it to count the number correct? Do you want it to be serious and boring, or snarky and funny? Be specific. Specify both program and content . The natural impulse is just to write the content (e.g. for the flashcards – what questions should it ask, and what should the answers be?) But that’s not enough. You are asking them to write a computer program. Be sure to also specify what that program should do. Should it be graphical (turtle) or text-based (terminal)? Should it be case senstive? Should it give the user more than one chance to get it right? Should it count the number correct? What else should it do? Anything it should NOT do? . Think About Testing While Writing the Specification . Near the end of class, you are going to get back some code. It almost certainly will not do exactly what you expect it to – but your partner will think it does. Think about how you will test it. As you are writing the specification, also jot down some notes about how to test it. What things will you look for? What does it mean to “work” correctly? What are some possible inputs, and what would you expect to happen with those inputs? . Choose something interesting . I gave an example above using the flashcards studio. But that is probably the least interesting and least creative studio of the year. Try to choose something either that you think would actually be useful to you, or would be interesting for you to work on and think about. Then make it more interesting to you – be creative, and come up with an interesting program that you would want done. Remember, you want creativity to be part of the specification, not part of the implementation. Ask for clarifications . Despite trying really hard, program specifications are almost always more vague and less detailed than you would like. As you start writing code, you start to realize all of the things that the specification did NOT specify. It is OK to ask for clarifications. “When you said X, what did you mean?” “If this happens, would it be better if the program does X or Y?” Clarifying questions are normal and good. Use email to communicate . This isn’t a one-time handoff. You are allowed to communicate with the other team. You will be implementing their specification, and they will be implementing yours. Talk to them! Ask questions! Answer their questions. Get to know them. You’ll need to think about how to do this communication. You’ll probably have multiple questions. Do you send them a separate email every time something comes up? Can you figure out any of the answers yourself? Do you need to wait for a response, or can you keep working while you wait? . When you need a clarification, communicate via email, and CC both Jack and Rick when you email. Is this fun? . As you work, think about what parts of this you are enjoying, and what parts you don’t. Some people really like being told what to do, and having a specification to work towards is nice and easy. Other people hate it because it feels uncreative and like they can’t express themselves. Some people really like testing because it is fun to break things and think about all the weird ways that programs get used; other people hate testing and find it very tedious. Some people like writing specifications because they get to see lots of possibilities, and then get to have other people make them happen. Other people hate writing specifications because they feel like writing down all the details that a specification needs is more work than just writing the code. Think about what parts of this you like, and what parts you don’t like. This will help you as you move forward in your career in thinking about what parts of the work you might want to do, or might want to avoid. (This is a good thing to mention in your reflection.) . Limit your commitment . This honors option shouldn’t take a ton of time. For coming up with a specifcation, set a timer and limit yourself to about 20-30 minutes. Try to come up with a good specification in that time, but its OK if it isn’t perfect. For the actual programming aspect, expect about 2 hours of work – about the same amount of time and complexity as a normal studio in class. Try to design your specification to be able to be done in that amount of time. And when you are programming, limit your time to about 2 hours. IF you really want to, you can go longer, but think of it like a contract job – the client agreed to pay you for 2 hours of work, so if you do more than that, you are doing it for free! . ",
    "url": "/honors.html#advice",
    "relUrl": "/honors.html#advice"
  },"111": {
    "doc": "Honors Option",
    "title": "Suggested Timeline",
    "content": "These dates are only suggestions. Please feel free to recommend changes if you would like different deadlnes. | Step | Time Commitment | Due Date | How to turn in | . | 1. Specification | 20-30 minutes | Friday, April 7 | Email to partner; CC Rick and Jack | . | 2. Programming | ~2 hours | Friday, April 21 | Create new Gitlab repo with your program and place a copy of the specs you followed in it. Add partner, as well as Rick and Jack, to repo as maintainers. Email partner, CC Jack and Rick when done. | . | 3. Testing | 20-30 minutes | Friday, April 28 | (Nothing to turn in, but would be helpful for you to write down a list of what works as you expected and what doesn’t to refer to as you write your reflection) | . | 4. Reflection | However long it takes you to write 2-4 paragraphs | Wednesday, May. 3, 7:45pm (end of finals timeslot for this class) | See bottom of guidelines for what to write about. To turn it in, email to Jack and Rick as PDF or Word doc. Also include a link to the Gitlab repo you created (with the program you wrote based on your partner’s specifications) in the email and/or in the reflection paper. | . ",
    "url": "/honors.html#suggested-timeline",
    "relUrl": "/honors.html#suggested-timeline"
  },"112": {
    "doc": "Honors Option",
    "title": "Honors Option",
    "content": " ",
    "url": "/honors.html",
    "relUrl": "/honors.html"
  },"113": {
    "doc": "Software Testing",
    "title": "Software Testing",
    "content": " ",
    "url": "/testing/",
    "relUrl": "/testing/"
  },"114": {
    "doc": "Software Testing",
    "title": "Exercise: What is a bug?",
    "content": "Software testing is the process of finding and eliminating bugs in software. Take a minute and write down your answer to the question “What is a bug?”. Go ahead; I’ll wait. Computer programs are written with goals in mind; the program is supposed to do something specific. A bug is anytime that the program doesn’t do that. That is, a bug is anytime there is a difference between what the program is supposed to do and what the program actually does. As computer programs get more complicated, so do the bugs. A simple computer program often only does one thing. If it does that then, then great; it works. When you make computer programs more complicated, they have to work in a wider variety of different settings. Different people might enter in different inputs. The program has to work with different types of data. The program has to work on different computers (Mac vs. Windows) with different size screens and other differences. Bugs may appear only in some circumstances but not others – it may work fine for you on your computer, but not for me on my computer. But still, that’s a big problem for me! (AND, also, a problem for you if you want me to pay you for the computer program….) . Fixing Bugs . When people write programs, they often think that they should try to write programs that don’t have bugs. But, that’s impossible! They also think that programs aren’t done until they are bug-free. That’s also impossible! Microsoft Windows shipped with millions of known bugs that were not fixed. People still bought it and use it on a regular basis. Fixing every bug is hard, and often not worth the time and effort. If a bug is any time what the program actually does is different than what the program is supposed to do, then there are two ways to fix a bug: . | Change what the program actually does. Modify the code so that the program does what it is supposed to do. | Change what the program is supposed to do. Change your idea of what the program is supposed to do and what kinds of things it can and can’t do. (and, if applicable, change the written specification) | . Both are entirely reasonable ways to fix a bug. Also, it is reasonable to choose to not fix a bug; just acknowledge that it exists but that it isn’t worth fixing. ",
    "url": "/testing/#exercise-what-is-a-bug",
    "relUrl": "/testing/#exercise-what-is-a-bug"
  },"115": {
    "doc": "Software Testing",
    "title": "Why Test?",
    "content": "Computer programs do not always work as the programmer intends them to. Often, I write code that I think does one thing, and then when I run it, I find out that it does something else. This is a very normal thing to happen, and every programmer experiences it on a daily basis. Testing is really an attempt to understand what your program actually does. Testing is a way to better understand the program that you’ve written and what it can and cannot do. Testing is the process of trying to find bugs. Testing does not necessarily involve fixing bugs. Instead, you test your program to try to learn about the bugs that exist. This gives you the information you need to decide whether it is worth fixing the bugs or not. Automated vs. Manual testing . There are two major ways of doing testing: manually testing the program by running it and entering inputs on your own, and automated testing by writing a 2nd program that tests your 1st one. You are already familiar with manual testing. You do it all the time. You write code, and then you run the code and see what happens. You have some idea in your head about what the program should do, and then you run the program and see what the program actually does. Often, this isn’t a very structured or formalized process, but you still do it all the time. You run your program over and over, adding code and trying different inputs, to see what happens. This is manual testing. It is possible, and not uncommon, to do more structured manual testing. Rather than just ad-hoc running your program, you could think carefully about what kinds of inputs your program might get, and then write down a list of possible inputs. Then you could think about, for each input, what should the program do? Write that down next to the input. Rather than having some vague notion about what the program should do, you now have explicitly written down the expected output. Now you can run the program multiple times, and see if what the program does matches what you wrote down that it should do. This structured, manual testing is quite common in the real world. Large companies pay people to run these structured manual tests and figure out if the program does what it is supposed to do. Some things, like user interfaces, are difficult to test automatically, and mostly are tested this way. However, running through these tests manually is hard and boring work – especially if you have to do it frequently. So, programmers often do what they are good at – they write a computer program to automatically run tests and check if the program does what it is supposed to do. Automated testing invovles using one computer program to test another, and is an extremely common way to do testing. As programs get bigger and bigger, automated testing becomes more important. Regression bugs: bugs that appear later, breaking previously working code. As you work on writing computer programs, one thing that you notice is that you change things in one place, and it affects other parts of the program. That is, it is possible (and common) that one part of the program works fine NOW, but later on you change something else and now that part no longer works. When this happens, it is called a “regression bug”. Regression bugs are really nasty, because they mean that you tested the program and it worked, but then later on it stopped working. The only way to catch regression bugs is to re-run all of your tests again, to make sure that the program still does everything it is supposed to. But doing that is a real pain. That’s one of the big reasons that we automate tests; it is much easier to re-run tests if they are automated and can be run with a single keystroke. ",
    "url": "/testing/#why-test",
    "relUrl": "/testing/#why-test"
  },"116": {
    "doc": "Software Testing",
    "title": "Test Cases and Automating Tests",
    "content": "In order to think about how to test software, we break our program down into test cases. Each case tests one specific feature or function of a program, and a single input to that part of the program. To test a program you’ve written, you will normally have many different test cases that test different parts of the program with different inputs. Basically, test cases break the job of software testing into discrete, managable parts. What is a test case? . A test case is a well-specified set of inputs and expected outputs. Above, I talked about how you could write down an input to your program, and then also specify what the output should be. That is a single test case. The trick with test cases is to be very specific. You are testing a very specific, logical piece of functionality of your code with a well-defined input and well-defined expected output. If your test case is specific enough, then it should be easy for anyone to tell whether the actual output matches the expected output; that is, you can tell whether the test case “passes” or “fails”. Automated test cases: Easy to run over and over . When we are writing automated tests, we usually break our tests into test cases. One function executes exactly one test case, and then decides whether that test passes or fails. For example, let’s pretend we have a really simple function called add() that takes two numbers and adds them together. If I add 1 and 2 together, I would expect to get 3, right? We can make that into a test case – if I call add(1,2), then I would expect the result to be 3. To do testing, we use the assert command in Python. Assert means to test and see if the result is what is expected. So, a really simple automated test case for the add() function would be: . def test_add(): result = add(1,2) assert result == 3 . In this case, the code is a test because the function name starts with test_. It runs the add() function with 1 and 2 as parameters, and then stores the actual result that is calculated in a variable called result. Then it checks (asserts) that this result is equal to 3 – the expected output. If it is equal, then we say that the test case “passes”, and the result is what we expect. If it is not equal, then we say that the test “fails” because it is not what we expected. This is a single test case. If I wanted to test a different set of inputs, that would be a separate test case. So if I also wanted to check that adding 0 and 0 results in 0, here is a second test case: . def test_add_zero(): result = add(0,0) assert result == 0 . Testing harness: runs a collection of test cases and produce output reports . Now we have more than one automated test case. What if we want to run all of these tests, and collect the results into a single output that is easy to read? That is the job of a test harness: a program that runs automated tests for us and reports on their results. In python, a common test harness that is built in is called UnitTest. There are other ones that are commonly used also, such as pytest or nose. ",
    "url": "/testing/#test-cases-and-automating-tests",
    "relUrl": "/testing/#test-cases-and-automating-tests"
  },"117": {
    "doc": "Software Testing",
    "title": "Types of Tests",
    "content": "Most software has a large number of tests associated with it. It is not uncommon for the test code to be more lines of code than the code that is being tested. Now, the next question is what kinds of test cases should we create? How do we think about what to test? . What follows is one way to think about what to test. It is not the best way, and it is certainly not the only way. But it is a useful way to organize your thinking. To help illustrate, I will be writing tests for a function that generate Fibonacci numbers – a sequence of numbers that goes 1, 1, 2, 3, 5, 8, 13, 21, 34… Each number in the sequence is the sum of the two previous numbers. The function takes as a parameter which number in the sequence it should generate (the 1st number, or 3rd number, or what), and it returns that number. Here is an implementation of that function: . def fib(n): if n &lt;= 2: return 1 return (fib(n-1) + fib(n-2)) . For the first two numbers (n=1 and n=2), it returns a hard coded 1. For each number after that, it calculates the two previous numbers and adds them together. This is just an example function. We could write tests for almost any function we create. Level 0: Basic Functionality . The first types of test cases that I write are called “Level 0” tests. These test the most basic functionality; if these fail then the function is hopelessly broken and needs to be fixed. Level 0 tests should test the one or two most common use cases of a function to make sure that it works correctly with completely normal input. For the Fibonacci function, a very normal use is to ask it for the 3rd or 4th number. Let’s pick one – the 4th number. Looking at the Wikipedia page for Fibonacci nunbers, it looks like 4th number is 3. So we would expect fib(4) to result in 3. We can write this as a test case: . ### Level 0 tests def test_fib_3(): assert fib(4) == 3 . Usually we don’t have many level 0 tests. We write level 0 tests just to check and make sure that the most basic funcationality works. If there is a syntax error, or if fib() does something unrelated to Fibonacci numbers, or if I forgot to write the code for fib(), then this test will catch that. All it does it make sure that the most normal, basic way of using the function works. Level 1: Full Range of Functionality and Edge Cases . Once the Level 0 tests are passing, we know that the basic function works. The next thing I do is write Level 1 tests. These tests look at the full range of functionality to try to identify what are the edge cases and different types of inputs that the function should handle. We should use our knowledge of the function to try to identify tricky cases, and test those to make sure they work. However, all of the Level 1 test cases should be valid cases, in that they ask the function to do things that it normally would be expected to do. For the fib() function, what are some tricky cases that it needs to handle? Well, the first two Fibonacci numbers are always tricky, because they are different than the others. The first number should be 1, and the second number should also be 1. Let’s write a couple of tests for those: . # Level 1 tests def test_fib_1: assert fib(1) == 1 def test_fib_2: assert fib(2) == 1 . Are there any other trick cases? Let’s pick a higher nunber, and make sure that it does calculations accurately. Looking at the Wikipedia page for Fibonacci numbers, the 10th number is 55. So let’s check that to make sure it calculates larger and more complicated numbers correctly: . def test_fib_10(): assert fib(10) == 55 . Ideally, you want to keep writing Level 1 tests until you’ve tests the full range of valid inputs – long inputs, short inputs, big numbers, small numbers, blanks, etc. Everything that is valid, you should write a test for to make sure that it works. Level 2: Error conditions . Almost all programs have invalid inputs – inputs that are considered to not be legitimate. However, sometimes the user ends up providing an invalid input. Good programs detect that the input is invalid, and handle it appropriately (for example, by displaying an error message). Level 2 tests test these invalid inputs. They intentionally provide invalid inputs to the program, and then check to make sure that the program does something reasonable with that input. For example, the fib() function only really produces sensible outputs for positve, whole numbers. If you enter a negative number, or if you give it a fraction, it doesn’t know what to do. What should it do? Often, when writing test cases, you realize that you don’t know what a program should do. If a bug is when what the program actually does is different than what the program should do, then it is a problem if you don’t know what the program should do! . This is surprisingly common, to not know what the program should do. This is another benefit of testing – it forces us to think through all of the things that can happen, and try to figure out what we want to the program to do in each of these situations. For the Fibonacci function, what do we want the program to do if it gets an invalid input? Let’s say that is should throw an IndexError any time it gets an invalid input. Now that we know what it should do, we can write some tests for some invalid inputs. We can use pytest.raises() to check and make sure that that error is raised. The test fails if it does NOT raise that error, and it passes if it does create that error: . # Level 2 tests def test_fib_negative(): with pytest.raises(IndexError): fib(-1) def test_fib_fraction(): with pytest.raises(IndexError): fib(2.5) def test_fib_string(): with pytest.raises(IndexError): fib(\"hi\") . If you run these tests with our fib() code above, you’ll see that these Level 2 tests fail! Uh oh! We have found some bugs in our code – it doesn’t handle error conditions very well. First, we need to decide if we care – is this a bug that is worth our time fixing? If it is, then we need to change our fib() code to make it do the right thing. Level 3: Performance and Scalability . Once all of the tests for Levels 0, 1 and 2 are passing, then the program mostly works correctly – it does what it is supposed to do. However, that’s not quite enough. There are usually other goals that programs have – for example, running fast enough that the user doesn’t get bored. Level 3 tests test these other, non-correctness features of programs. For example, it is a problem if it takes minutes to calculate our Fibonacci number. That’s not good. The computer should be able to calculate it in less than 10 seconds. So let’s write a test to check this: . # Level 3 tests def test_fib_speed(): start = datetime.datetime.now() out = fib(40) end = datetime.datetime.now() assert (end-start).total_seconds() &lt; 10 # It should take less than 10 seconds to compute . Example . You can download these examples here. This file contains the basic fib() function, and all of the tests listed above. To run it, use the command: . pytest fib.py . OR, alternatively, you can run it with . python3 -m pytest fib.py . When you run it, you should see that four of the test fail! Our fib() function only passes half of the tests. As an exercise, can you fix it so that all the tests pass? (Solution) . ",
    "url": "/testing/#types-of-tests",
    "relUrl": "/testing/#types-of-tests"
  },"118": {
    "doc": "Software Testing",
    "title": "Testing an Application",
    "content": "When testing a whole program or large application, there are some additional considerations. Specifically, it is really valuable to distinguish between unit tests and integration tests. Unit tests . Most programs are split up into smaller, logical units of functionality. A unit test tests a single, small unit of functionality. Often, we do this with functions; a unit test can test that a function works correctly. All of the tests we wrote above for the fib() function are unit tests – they test a small unit of functionality that is (most likely) part of a larger program. Unit tests are very common, and the majority of automated tests that are written are unit tests. Unit tests are great for catching regression bugs and for helping us to think through program and make sure that we cover everything it is supposed to be able to do. Integration tests . However, it is possible that all of the individual pieces work correctly on their own, but that they don’t fit together properly. That is where integration tests come in. Integration tests look at the program as a whole, and make sure that the pieces all fit together properly in a way that works. The most common way to create an integration test is a user script – write a script of what the user would do when using the application as a whole, and then annotate the script with what is expected to happen at each stage. User scripts can capture the overall functionality of a program in a way that unit tests don’t. Integration tests can be automated, and many good integration tests are. But often, we also do integration tests as manual tests, running through the application and making sure that it works as a whole. Exercise . You can try to complete the testing lab. ",
    "url": "/testing/#testing-an-application",
    "relUrl": "/testing/#testing-an-application"
  },"119": {
    "doc": "Home",
    "title": "MI 250: Introduction to Applied Programming",
    "content": "This course is a first introduction to computer programming, designed for students who will not become professional programmers but who will need to use technical skills or interact with programmers. That is, the course helps students understand how to think about programming computers, and builds some basic skills at getting computers to do what they want them to do, without an expectation that they go on to take large numbers of future programming courses or work professionally doing programming. Everyone can learn to program. Everyone. And understanding more about how computers work, how programmers work, and what is easy vs hard for computers are extremely useful skills. Those skills are valuable for people doing analytics, graphic design work, creating user experiences, building games, and almost anyone who works with computers as part of their job. This course is offered through the Department of Media and Information at Michigan State University. ",
    "url": "/#mi-250-introduction-to-applied-programming",
    "relUrl": "/#mi-250-introduction-to-applied-programming"
  },"120": {
    "doc": "Home",
    "title": "Fall 2023",
    "content": "Class meets on Tuesdays and Thursdays at 10:20am-12:10pm in Holden Hall, room C131. Course content can be found on this site and on Gitlab. D2L is used for turning in assignments and keeping track of grades. Useful links: . | Syllabus | Course schedule | Gitlab | D2L | . ",
    "url": "/#fall-2023",
    "relUrl": "/#fall-2023"
  },"121": {
    "doc": "Home",
    "title": "Home",
    "content": " ",
    "url": "/",
    "relUrl": "/"
  },"122": {
    "doc": "Lab",
    "title": "Pair Programming",
    "content": "In this class, all of the labs will be done through pair programming. You will be assigned to work with one other person as a “pair”. Pairs work following the mantra of “2 people, 1 computer”; that is, both people work together on a single computer to get the lab exercises done. You must do all of the lab exercises together. You’ll be randomly assigned into a pair for each lab. At any given time, each of you will have different roles. One person will be the “driver”, and the other person the “navigator”. Once you’re paired up, begin by deciding who will be the driver and who will be the navigator. Driver . The driver controls the computer. They are physically in front of their computer using the keyboard and mouse. The job of the driver is to get the computer to do the tasks assigned in the lab. The driver is ultimately responsible for what happens on the computer. Navigator . The navigator (also called the observer) watches the driver’s activities. They make suggestions, point out errors and problems, ask questions, and think more carefully about what is being done. Being a navigator does not mean being passive; you should be actively watching and trying to help out. Since laptop screens are small, it may be helpful if the navigator uses their laptop or another device to keep the lab instructions up or to look things up. It is very important that both members of the pair communicate regularly. The driver can ask questions and discuss issues, the navigator can ask that specific changes be made or specific code by typed in, and both members can stop what is going on to discuss anything they feel needs to be discussed. Periodically, both of you will switch roles. In some labs, we will switch roles when you complete specific parts of the lab (like today). In other labs, we will set times, and we will switch roles every 20 minutes or so. Everyone should be both a driver and a navigator at some point during the lab. ",
    "url": "/labs/installing_python.html#pair-programming",
    "relUrl": "/labs/installing_python.html#pair-programming"
  },"123": {
    "doc": "Lab",
    "title": "Get ready to work with Python",
    "content": "The goal of this lab is to get everything set up to run your first python program on both your own computer and your partner’s computer. I will give you a program, and you can both run it on your computers. For this section, the driver will do everything on their computer first with the other person acting as navigator. Later on in the lab you’ll switch places. Remember you’ll learn faster by working together! . Install Python . Python is a programming language, but is interpreted, which means that there is a separate program that reads the program that you write and “runs” it by interpreting it as instructions. That is, it is a program that runs other programs. The first thing we need to do is go install Python. Go to the main Python website at https://www.python.org. On that page, hover over the “Download” menu and you should see a button with Python 3.11.X on it. Click the button to download the program, and run the installer program. That will install the current version of the python interpreter on your computer. Important: While running the installer, be sure to click the “Add python to the PATH” checkbox. If you already have python installed on your computer, make sure you have the current version (3.11.X). If the version of Python you have installed is not the current version, then run the installer and it should replace the old version of Python with the current version. Use Command Line . Next, we want to make sure that Python is installed, and that it is installed correctly. To do this, we are going to use command line. We will be using command line for a lot of things in this class, including running code and saving code to the cloud. If you have Windows . In Windows, we are going to use the “PowerShell” command line interface. This comes built in to all recent versions of Windows. To access this, click on the search bar and type in “powershell”, and that should find it. Run it. It should open up a window with a bunch of white text at the top on a blue or black background. You’ll see a prompt with a blinking cursor in front of it, like this: . PS C:\\Users\\geier&gt; . The first thing we are going to do is to verify that we have python installed correctly. To do that, simply type python where the cursor is and hit enter. If it works, you should see something like this: . Python 3.11.5 (tags/v3.11.5:cce6ba9, Aug 24 2023, 19:29:22) [MSC v.1936 64 bit (AMD64)] on win32 Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. &gt;&gt;&gt; . The three arrows &gt;&gt;&gt; mean Python is in interactive mode. Try typing 2+2 and hitting enter. It should add the numbers for you. You can use this mode to try out short snippets of code to see if it works. We won’t be using it much in this class, though. To get out of Python’s interactive mode, type quit() and hit Enter. On Windows, you can also hit Control-Z and then Enter. Troubleshooting . If the Python install doesn’t work, you’ll get an error message (on older versions of windows), or it will open Python in the Microsoft store (on Windows 10 or 11). Try closing PowerShell and opening it again. If it still doesn’t work, it means Python isn’t properly installed. Run the Python installer again. If it is already installed, if will give you an opportunity to “modify” the python install. Do that. Click through the optional features, and then you should see a page of “Advanced Options”. On that page, click the checkbox next to “Add python to environment variables”. Then click install to finish it. After this, close PowerShell and open it again, then try the python command again. If you have Mac OS . On a Mac, we will use the Terminal app. Terminal gives us a command line that we can use to run things. On the launchpad or in the applications list, it is usually in the “Other” folder. Or you can click the spotlight search icon (the magnifying glass in the upper right) and type in “terminal”. Terminal should open up a window with a bunch of text in it, and a prompt with a blinking cursor next to it. It might look like this: . Last login: Mon Aug 28 23 16:57:43 on ttys000 geier-Macbook-Pro:~ geier$ . If you type, it should appear next to the prompt. Type the command python3 and hit enter. If it works, then you should see something like this appear: . Python 3.11.1 (default, Jan 13 2021, 11:08:38) [Clang 12.0.0 (clang-1200.0.26.2)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. &gt;&gt;&gt; . The three arrows &gt;&gt;&gt; mean Python is in interactive mode. Try typing 2+2 and hitting enter. It should add the numbers for you. You can use this mode to try out short snippets of code to see if it works. We won’t be using it much in this class, though. To get out of Python’s interactive mode, type quit() and hit Enter. On Mac, you can also hit Control-D. Important: Macs come pre-installed with a REALLY old version of Python (2.7). Many of the things we do in this class won’t run on that version of Python. If you just type python, it’ll run that really old version. If you are using a Mac, you should always type python3 instead of python to run python. That way, you’ll use the current version. Be sure to check the version number that is printed out to make sure it is correct. Troubleshooting . If you get an error message, that means python wasn’t installed properly. Try closing Terminal, opening it again, and then trying the python command again. If it still doesn’t work, try running the Python installer again. ",
    "url": "/labs/installing_python.html#get-ready-to-work-with-python",
    "relUrl": "/labs/installing_python.html#get-ready-to-work-with-python"
  },"124": {
    "doc": "Lab",
    "title": "Run your first program",
    "content": "Next, we are going to try to run our first python program. The program is called eliza.py - eliza is the name of the program, and the .py at the end means it’s a Python program. All python programs end with .py. Download eliza.py from Gitlab . Near the top of this webpage is a link to a Git repository on Gitlab (which is similar to Github, except administered by MSU). The repository contains the code for this week’s lab. Each week’s lab will have a Gitlab link at the top. When you go to Gitlab for the first time, you’ll need to log in. Click the “Okta” button (and check the “Remember me” box down below so you won’t have to log in everytime.) If you’re logged into an MSU system already, the site should load. Otherwise, it’ll ask you for the MSU netid and password. Once you’re in Gitlab, you should see a short list of files. Clicking on a file will show you the contents of the file. This repository only has two files in it: eliza.py and a file called README.md which says a bit about what’s in the repository. We want to download the eliza.py file. Click on the name of the file, and it should take you to a page where you can view the file. Near the top of the contents, there is a download link that looks like the bottom half of a box with a down arrow going into it. Click that, and download the file. It will either automatically go to the Downloads folder on your computer, or it will ask you where you want to download it to. Find the program using command line . Next, we want to run the file from the command line. Open up PowerShell (in Windows) or Terminal (in Mac OS). The most important thing to remember about command line is that it only will let you do things with files if it thinks it’s in the same location the file is. That means it has to be in the Downloads folder to interact with any of the files in Downloads. PowerShell will show you the directory tree you’re in, while Terminal will only show you your current folder. By default, both PowerShell and Terminal start in the top level Users/username directory when you open it up. Other directories like Desktop and Downloads are nested directly under the Users directory. The first thing we need to do is to change the current directory to the one where the file was downloaded. If you sent eliza.py to the Downloads folder, use the command cd downloads. cd is short for “change directory”. If that command works, it won’t print anything out; instead it will just give you a new prompt which will show you you’ve moved into that folder. On Windows, this looks like: . PS C:\\Users\\geier\\downloads&gt; . On Mac, it looks like: . geier-Macbook-Pro:Downloads geier$ . See how “downloads” is now in the prompt? You can always see where you are in the folder structure on your computer by looking at the command line prompt. You can go to different places on your computer, too. For example, if you created an “MI 250” folder on your desktop and saved eliza.py in there, you can get to your MI 250 folder in command line with this command: . cd desktop/\"MI 250\" . Note that whenever you have spaces in the name of a folder, you need to put quote marks (“”) around it when you navigate to it in command line. Once you think you’re in the right folder on command line, run the command ls. This will give you a list of files in that folder. Make sure eliza.py is in that list. If it is, you can run it! . Command line reference . There’s also a neat trick that works in both Windows and Mac OS to get to the folder you want to go to. | Type cd in command line - make sure there is a space after cd. | Open up the folder you want in File Explorer (Windows) or Finder (Mac OS) – the normal way of viewing folders. | Drag the folder over to the command line window. When you release your mouse on top of the command line window, that should put the full directory name after cd. | . A couple of other useful command line commands: . | You can get a list of the files in the current directory with the ls command | You can move up one directory (to the parent directory) with the command cd .. | If you start typing the name of a file or directory, you can it the Tab key and it will try to automatically finish typing the name of that file/directory for you. | When the space next to the prompt is empty (you haven’t typed anything yet), you can hit the “up” arrow on your keyboard - this will autopopulate the last command that was given. | . There’s more useful command line stuff in the Reference section on this site. Run the program . Once you are in the right directory, try to run the Eliza program you downloaded: . python eliza.py . If you’re on a Mac, remember to use python3! . The program should begin talking to you, and ask you for information about yourself. Play around with it, and answer some questions. Notice how it responds, and when it says the same things and when it says different things. When you are done, type “goodbye” to exit the program. Congrats! You have run your first python program by hand on the command line! Good work. We will be doing this many times over the course of the semester, but in the future it will mostly be programs that YOU write that you will be running. ",
    "url": "/labs/installing_python.html#run-your-first-program",
    "relUrl": "/labs/installing_python.html#run-your-first-program"
  },"125": {
    "doc": "Lab",
    "title": "Trade places and repeat",
    "content": "Change Drivers: At this point, the driver should have Python installed and running on their computer, and should have been able to run eliza.py. Now the driver and navigator should swap. Go back to the beginning of the Install Python section on this page and re-do these all of the above steps on the new driver’s computer. Make sure that you’ve got python installed correctly on both computers, and that both computers can run eliza.py. Some things will be easier the second time around, and sometimes you will encounter new problems. Work together with your partner to figure out how to get it working. ",
    "url": "/labs/installing_python.html#trade-places-and-repeat",
    "relUrl": "/labs/installing_python.html#trade-places-and-repeat"
  },"126": {
    "doc": "Lab",
    "title": "Edit the program",
    "content": "Congratulations on getting a Python program running on your computer. That is a big accomplishment, and is probably one of the hardest parts of this class. Command line, Python, downloading .py programs – this is all very weird and not the normal way we install or run programs on computers. There is a reason we do it this way – it turns out it will be easier in the future if we do it this way – but it is very weird and takes a while to get used to. That’s OK if it feels weird! It should. For the next step, we are going to edit the program. We are going to add some new features to the program, and then run it again. Install a text editor . To edit the program, the first thing we need it is a text editor. Computer programs are written as plain text files. This means we can’t open them up in Word or Google docs or similar programs. We have to open them in a text editor. There are lots of text editors out there that you can use, and they can get really complicated. The text editors I recommend for this course are: . | For Mac: BBEdit (free version works fine) | For Windows: Notepad++. | . But you are welcome to install any other text editor you like. If you have a text editor that you already use and like, that’s fine, too. I also sometimes use Visual Studio Code (both Windows and Mac). All of the options above are free to use. There are many others, including some specifically for Python, but not all of them are free and some get very complicated. I encourage you to experiment and find one that YOU like. Programming is a form of art, and each artist has their own preferences for tools. Look at the eliza program’s code . You downloaded the eliza.py program earlier in this lab. Our next goal is to edit this file. Go to the text editor that you choose, and open the eliza.py file from whatever folder you downloaded it to (probably downloads). First, look over the file. Read what it says. It is weird, and hard to read. The file roughly has three sections. The first section is only 2 lines. It looks like a header (basically, it is). Both lines start with the word import. We’ll learn more about imports later, but they allow the program to access specific functionality. The second section is labeled “list of inputs and possible responses”, and has a bunch of text in quotes. This contains the logic and intelligence for Eliza, our fictional person. The last section calls itself the “code that asks for user input and prints out a response”. This is a series of commands – think of them like the instructions you wrote to make pizzas earlier this week. It prints out information, then asks the user to type something in, and then chooses a response based on what was typed. Right now, the way Eliza works is that the computer looks for specific words in what the user types; words like “hello”, “mother”, or “I feel”, which the program calls prompts. Then, when it sees one of these prompts, it looks at the list of possible responses below the prompt, and picks one randomly to print out. So if the user enters “hello”, then it will randomly pick one of the 3 responses below it and print it out. Make a change to the code . We are going to make a change. We are going to allow Eliza to respond to questions. First, we should check whether she already does that. Run the eliza.py program with the command python eliza.py in command line. Enter a question, complete with a question mark at the end. What happens? She responds, but she doesn’t seem to acknowledge that it was a question. Now, let’s add an ability for her to respond to questions. If you look in the file, you should see code that looks like this: . (\"\", [\"Please tell me more\", \"Can you elaborate on that?\", \"I see\", \"How does that make you feel?\", \"How do you feel when you say that?\" ]), . That is the ‘default’ response; if she doesn’t know what else to say, she says that. Let’s put the question responses just above that. Add a new, blank line right above that. Then paste in this code: . (\"?\", [\"Why do you ask that?\", \"Why don't you tell me?\" ]), . Make sure not to leave out any parentheses (), square brackets [], or commas. Also make sure the indents look like how the next chunk of code is indented. Indents are important in Python. Great! You’ve just made your first changes to a python program. Good work. When you’re done, save the file by going to File -&gt; Save in your text editor. A quicker way to do this is Ctrl+S on Windows or Cmd+S on Macs. Files never save automatically; you have to remember to do it yourself every time. If your changes aren’t saved and you try to run the program, it will run the last saved version. Run again, and see if the changes appear . Now let’s see if your changes work. Go to the command line again, and run eliza.py using the command python eliza.py. Notice that this is how we always run a python program: we go to the command line, type the word python followed by the name of the program file we’ve been editing. (And again, remember to use python3 if you’re on a Mac!) . Eliza should appear again. Start interacting with her. Does she still behave normally? What happens now if you ask her a question? Does she do somethig different than she did before? . If she does, then your changes have worked! If she doesn’t, then go back to the file and try again. Make sure you saved the latest version, and take a look at the punctuation and indents in the code you added. Don’t worry (yet) about how that code works, or what exactly it does. We will learn that throughout the semester. By the end of the semester – actually, about half way through the semester – you should be able to read and understand (and possibly write) this program yourself. But for now, if you don’t understand it, that’s normal and OK. The important part is figuring out how to edit files in a text editor, and then run them on the command line. Take a screenshot . Once you’ve got the changes you made to eliza.py working, take a take a screen shot of Eliza working on your computer – preferably showing some of the new responses you’ve added – and submit it on D2L. The easiest way to do this is to put the window with your code editor and the window for Terminal or PowerShell side by side and take one big screenshot of both windows. ",
    "url": "/labs/installing_python.html#edit-the-program",
    "relUrl": "/labs/installing_python.html#edit-the-program"
  },"127": {
    "doc": "Lab",
    "title": "Trade places and repeat",
    "content": "In normal labs after this week, we won’t be repeating steps on both people’s computers. But for now, we want to make sure that both people’s computers are set up and working with Python correctly. So change drivers again, and go through the steps starting at Install a Text Editor again. Hopefully it will be easier the second time around. ",
    "url": "/labs/installing_python.html#trade-places-and-repeat-1",
    "relUrl": "/labs/installing_python.html#trade-places-and-repeat-1"
  },"128": {
    "doc": "Lab",
    "title": "Extra Challenges",
    "content": "At this point, both you and your partner should have Eliza.py with changes working on both of your computers. Labs every week will have one or more challenges at the end. If you finish all of the main exercises, start working on one of the challenges. If you finish one (or both!) challenges before class ends, let Caitlin or Jack know so we can check your work and answer any questions. Challenge: Other Python programs . Now that you’ve gotten your first Python program running, try to download a few more Python programs and get them running. Be sure to run them using the command line: . | Snowflake – draws a snowflake on the screen. (the “raw” button downloads the file) | Uno – play the card game uno | . Challenge: Add more responses to Eliza . You don’t necessarily understand how Eliza works, yet. You will later in the semester. But still, it is a good exercise to try to add additional responses to Eliza. Try to figure out how she works, and see if you can get her to respond in different ways than she does now. ",
    "url": "/labs/installing_python.html#extra-challenges",
    "relUrl": "/labs/installing_python.html#extra-challenges"
  },"129": {
    "doc": "Lab",
    "title": "Submit your work",
    "content": "When you and your partner are done for the day, submit your work! Today you’ll just need to turn in screenshots of Eliza working in command line and of the changes you made to the code. If you got to the challenges, take screenshots of those working, too. Next week you’ll start turning in your code as well. If you and your partner both finished everything and submitted your work before the end of class, you can leave early! Make sure you check in with Caitlin or Jack first. If you didn’t get everything done today, that’s OK. Sometimes you won’t be able to finish the entire lab, and that’s fine. For today, since we were installing stuff you’ll be using for the rest of the semester, let Caitlin and Jack know if you couldn’t finish the main part of the lab and how far you got. We’ll work with you after class on Thursday to make sure you have everything working. ",
    "url": "/labs/installing_python.html#submit-your-work",
    "relUrl": "/labs/installing_python.html#submit-your-work"
  },"130": {
    "doc": "Lab",
    "title": "Lab",
    "content": "Today we will start with our first programming lab. We’ll be getting Python set up and getting your computer ready for writing code, then we’ll practice working with code a bit. ",
    "url": "/labs/installing_python.html",
    "relUrl": "/labs/installing_python.html"
  },"131": {
    "doc": "Lab",
    "title": "Exercise 1 - Decide who’s driving and who’s navigating",
    "content": "You’ll be randomly divided into pairs. Find a place to sit where you’re next to your partner. Then decide who will be driving (typing) and who will be navigating (acting as support). Normally you’ll switch places partway through class so you each have a chance to drive and to navigate. This is a short exercise, so you won’t do that today. ",
    "url": "/labs/intro_to_class.html#exercise-1---decide-whos-driving-and-whos-navigating",
    "relUrl": "/labs/intro_to_class.html#exercise-1---decide-whos-driving-and-whos-navigating"
  },"132": {
    "doc": "Lab",
    "title": "Exercise 2 - Write instructions",
    "content": "The main task for today: with your partner, write out instructions for how to make a pizza. The driver will be doing all of the typing; the navigator will help by offering suggestions, looking things up, etc. You can use any resource you have available to you to help. Be as specific as possible! Assume that you’re writing instructions for someone who had never seen or had a pizza before. Also be creative! There are many different ways to make a pizza. ",
    "url": "/labs/intro_to_class.html#exercise-2---write-instructions",
    "relUrl": "/labs/intro_to_class.html#exercise-2---write-instructions"
  },"133": {
    "doc": "Lab",
    "title": "Exercise 3 - Be prepared to share with the class!",
    "content": "We’ll take some time to share our pizza making instructions out loud and see how different they all are. You and your partner don’t have to share, but be prepared to. ",
    "url": "/labs/intro_to_class.html#exercise-3---be-prepared-to-share-with-the-class",
    "relUrl": "/labs/intro_to_class.html#exercise-3---be-prepared-to-share-with-the-class"
  },"134": {
    "doc": "Lab",
    "title": "Exercise 4 - Take screenshots",
    "content": "For every lab and studio you do in this class, you’ll be expected to take screenshots showing the work you did. You’ll submit your screenshots on D2L. We’ll practice that today. Today, everyone will take a screenshot and submit it. The place you’ll turn them in on D2L is under “Assignments” and is called “Screenshot Practice Exercise”. Driver: Submit a screenshot of your written pizza instructions. Navigator: Submit a screenshot of an image of a pizza you’ve found through Google (or your search engine of choice). MacOS and Windows both have built-in applications for taking screenshots. If you need a refresher, here’s a reference for taking screenshots. (For the future, this can be found under “Reference” in the sidebar of this site.) . NOTE This “lab” is for practice and is ungraded! The first graded lab will be on Thursday. ",
    "url": "/labs/intro_to_class.html#exercise-4---take-screenshots",
    "relUrl": "/labs/intro_to_class.html#exercise-4---take-screenshots"
  },"135": {
    "doc": "Lab",
    "title": "Lab",
    "content": "Today is an introduction to the course and a discussion of what programming is. We’ll do a short “lab” today that will get you familiar with the format for the course. All labs in this class will be done using pair programming. Pair programming is based on the idea of “two programmers, one computer:” two programmers work together on the same code using one computer between them. One person is the driver: they are the person using the computer and typing the code. The other person is the navigator: they do the bigger picture thinking, look up relevant information, and help spot mistakes. In this class, students will switch roles on a regular basis. Students who participate in pair programming get stuck and frustrated less often than students working by themselves and are also able to practice teamwork and communication – which is why we practice it in this class! . ",
    "url": "/labs/intro_to_class.html",
    "relUrl": "/labs/intro_to_class.html"
  },"136": {
    "doc": "Lab",
    "title": "Install PyTest",
    "content": "Today, we will be writing automated software tests. Python comes built-in with a testing framework called unittest, but we aren’t going to use that. We are going to use a much better and easier to use system called PyTest. Before we can use it, we first need to install it. This only needs to be done once. On the command line, run the command . pip3 install pytest . It should download and install the latest version of pytest. Once it is finished, you should get your prompt back at the command line. Next, let’s check and make sure it is installed and working correctly. The fib.py program from the readings is in the git repository for this week. Run this command; it should run the tests and report 4 passes and 4 failures: . pytest fib.py . Note: You’ll need to make sure that fib.py is in the current directory . If it runs the tests (which may take a few seconds), and then prints out that there are 4 passes and 4 failures, then it is working. You can also run pytest fib_improved.py to see all of the tests pass. ",
    "url": "/testing/lab.html#install-pytest",
    "relUrl": "/testing/lab.html#install-pytest"
  },"137": {
    "doc": "Lab",
    "title": "Basic Testing",
    "content": "We are going to practice writing test cases for existing code. I am going to give you pre-written functions, and you will need to write one or more test cases – usually automated test cases – for those. Exercise 1: Basic (Level 0) Test for Cleanup . Let’s start by looking at the file cleanup.py. It contains a function – cleanup() – that takes a string and tries to clean up the langauge by replacing bad words with less bad words. Let’s begin by writing a basic test for this. There is a test function in the file – test_cleanup() – that right now does nothing. Let’s write a test case. In the test, call the cleanup() function, and give it the message “damn this shit to hell” – which of course has a lot of bad words in it. Save the output from the cleanup() function into a variable. Then use assert to check to see if that output has had the bad words replaced – it should now say “darn this poop to hades”. Once you get the test written, run pytest cleanup.py and see if it passes. You should make sure that your test passes correctly before moving on. Exercise 2: Basic (Level 0) Test for First Word . If you look at the file first_word.py, it contains a function called first_word(). This function takes a sentence as a string, and it returns the very first word in the sentence. Let’s write a test for this, to see if it works correctly. The file contains a single test called test_first_word(). Right now that function does nothing, so the test passes. Edit that function to test the first_word() function. Call the function, passing in the sentence “This is a test”. Save what the function returns to a variable. Then check that what the function returns is correct – it is the word “This”. Run your test. It should fail, because the first_word() function is broken. Exercise 3: Fix the bug in first_word . It is returning the wrong word! Fix the function so that your test now passes. Run pytest and verify that your test now passes correctly. ",
    "url": "/testing/lab.html#basic-testing",
    "relUrl": "/testing/lab.html#basic-testing"
  },"138": {
    "doc": "Lab",
    "title": "A Few More Tests",
    "content": "Exercise 4: Testing how to count letters – “HI” . Next, turn your attention to the count_letters.py file. This file counts a count_letters() function that takes a message and counts how many times each letter appears, and returns the dictionary with the letter counts. Write a test for this function that passes in the word “HI” and verifies that the function reports that the word has one “H” and one “I”. You will have to write our own test function for this. Note: You are allowed to have more than one assert in a single test. All asserts must pass for the test to pass. So you can separately check the counts for ‘H’ and ‘I’ are correct. Exercise 5: Test repeats (Level 1 test) . Add a second test to this file that tests repeated letters. Pass in a string that has at least one letter repeated more than once. Then verify that this correctly counts the number of times that letter appears. Exercise 6: Test empty (Level 1 test) . What happens if you pass in the empty string – \"\"? Add a test case that passes the empty string to count_letters() and verifies that it returns a reasonable answer. Exercise 7: Test missing (Level 2 test) . Add one more test case to count_letters.py. Pass in a word to count_letters(). Verify that it correctly counts at least one of the letters. But also pick a letter that is NOT in that word, and verify that that that letter is NOT reported in the dictionary that is returned. By this point, you should have 4 separate tests in count_letters.py that all pass when you run it with pytest. Hint: You can do assert key in dict or assert key not in dict – in general, anything you would use in an if statement, you can also do in an assert. ",
    "url": "/testing/lab.html#a-few-more-tests",
    "relUrl": "/testing/lab.html#a-few-more-tests"
  },"139": {
    "doc": "Lab",
    "title": "Testing Output",
    "content": "Much of the code we’ve written so far in class has been creating output – for example, the print() statements for our choose-your-own adventure program or our conversational agent program. We can test this code by “capturing” the output from the print statements into variables, and then checking whether that output is what we expect it to be. To capture output, we use the capsys functionality of pytest. We add a parameter to our test called capsys, which will cause pytest to capture all print statements. Then we can retrieve that output by saying captured = capsys.readouterr(). THen we can access the actual output with captured.out. He is an example test that just prints the word hello, and verifies tht it prints correctly: . def test_print(capsys): print(\"hello\") captured = capsys.readouterr() assert capured.out == \"hello\" . Exercise 8: 99 bottles . If you look in the file bottles.py you’ll see a function that prints out one verse of the song 99 bottles. Write a function that tests this by picking a verse number (e.g. verse 75), calling the bottles function, capturing the output, and the verifying that the output looks like what it is supposed to look like. Exercise 9: 9 bottles . The bottles function does something different for verses less than 10. Write another test to verify that a verse less than 10 (e.g. 9) prints out the alternate version of the song. ",
    "url": "/testing/lab.html#testing-output",
    "relUrl": "/testing/lab.html#testing-output"
  },"140": {
    "doc": "Lab",
    "title": "Testing Input",
    "content": "We also write a lot of code that gets inputs from users. How do you test that? . The easiest way to test that is to replace the input() function with another function that returns a pre-specified string. This way, when your program calls input(), it won’t actually ask the user; instead, it will just pretend the user typed something in and return what you tell it to. This is called mocking the input. To do that, we use a feature in pytest called monkeypatch. Put one line at the beginning of your test to replace input with whatever you want it to be: . def test_input(monkeypatch): monkeypatch.setattr('builtins.input', lambda x: \"Rick Wash\") name = input(\"What is your name? \") assert name == \"Rick Wash\" . Exercise 10: Test the Flashcard . The file flashcard.py has a function that contains a single flashcard, much like the flashcards you made in week 2 studio. It asks the user a riddle, waits for the user to respond, and then returns either the word “Correct” or “Incorrect” based on what the user entered. Test that this flashcard works correctly. If the user enters “mountain” (the correct answer), then the function should return “Correct”. If the user enters anythign else, it should return “Incorrect”. You will need at least two tests to test this – one that tests a correct answer, and one that tests an incorrect answer. ",
    "url": "/testing/lab.html#testing-input",
    "relUrl": "/testing/lab.html#testing-input"
  },"141": {
    "doc": "Lab",
    "title": "Testing Your Own Code",
    "content": "It is easier to write tests once you have a program working. But which comes first, the test or the program? If you google this question, you’ll get thousands of very long, heated discussions online. This is a subject of much debate among programmers. Still, this is something you will need to deal with. So for this next exercise, you will need to write BOTH the main function code, and the test code. Exercise 11: Nth word . Write a function that extracts the nth word from a sentence. That is, if I give you the sentence “this is a sentence” and ask for the 4th word, it should return “sentence”. If I ask for the 2nd word, it should return “is”. Look at the code in first_word.py as a good place to start. Also, then write one or more tests for your nth word function to verify that it works correctly. It is up to you whether you write the test first, write the main code first, or do them both at the same time. Think about which way makes most sense to you. Do you write the code first, and then test it to make sure it works? OR, do you write the test first, so you know what it needs to do, and then write the code so that it matches what the test says it should do? . Hint: Start by making a list of what kinds of things you can test. Then write your “nth word” function to be easy to test in that way. Focus on Level 0 and Level 1 tests. Try to find ways that the function is supposed to work correctly, and test that it does. ",
    "url": "/testing/lab.html#testing-your-own-code",
    "relUrl": "/testing/lab.html#testing-your-own-code"
  },"142": {
    "doc": "Lab",
    "title": "Manual Test Cases for Turtle Graphics",
    "content": "We’ve now written a lot of automated tests, spread across a bunch of different files. Run the command . pytest bottles.py cleanup.py count_letters.py fib_improved.py first_word.py flashcard.py . It will go through all of the files that have tests in them, and then run ALL of the tests you’ve written. Very hand way to check all of your code. However, there’s one thing we’ve done a lot of in this class that we haven’t written tests for: turtle graphics. It is actually pretty hard to write tests for turtle graphics, because the output is on the screen. Instead, we usually do manual tests for turtle graphics programs. So far, you’ve just run the program over and over and see if you like what is looks like. Let’s be more rigorous than that. Let’s create some very specific manual tests where the program draws something, and then we explicitly write down what we expect it to draw. That way, someone can look at the expected output and decide, for each drawing, whether it “passes” or “fails”. Challenge: Stars . In your folder for this week, there is a star.py program. That program contains a function that draws a star of different sizes and colors. Create 3 manual tests for this star function. One test should be a Level 0 test – give it a reasonable size and color, and see if it works. The other two tests should be Level 1 tests – give it a different size, and a different color, and see if it draws the star appropriately. For each test case, explicilty write down what parameters to give the function, and what you expect the program to draw. They should be paired – so these parameters should draw this output. It is OK to write this on a piece of paper – just take a photo of it with your phone to turn it in. Then modify the program to draw the 3 test cases on the screen. Then run your test manually – look at the output, and decide for yourself whether what it drew matches what you expected it to draw. Write down whether each test cases passes or fails. Challenge: Level 2 tests for nth_word . As a second challenge, try to write one or more tests for your nth_word() function that tests errors – aka Level 2 tests. Think about inputs to your nth_word() function that might be invalid. What happens if someone asks for the 5th word in a sentence that only has 4 words? What happens if someone asks for the ‘a’th word instead of the ‘1’st word? What happens if someone asks for the ‘-1’st word? (is that actually an error?) . In each of those cases, think about what you think should happen, and then write the test to test whether that actually happens or not. If it doesn’t happen, it could be because the function is broken. Or it could be because your understanding is incorrect, and the test is helping you to see what is wrong. ",
    "url": "/testing/lab.html#manual-test-cases-for-turtle-graphics",
    "relUrl": "/testing/lab.html#manual-test-cases-for-turtle-graphics"
  },"143": {
    "doc": "Lab",
    "title": "Lab",
    "content": " ",
    "url": "/testing/lab.html",
    "relUrl": "/testing/lab.html"
  },"144": {
    "doc": "Lab",
    "title": "Names, names, and more names",
    "content": "Exercise 1: Add your names to a list . Start by running the program names.py. This prints out a list with the names of the instructor and the course assistant for this class. Add both your name and your partner’s name as separate items to the end of the list. Run the program and make sure it prints out all four names correctly. Exercise 2: Adding another name . You have hard coded a set of names into the list. However, you can also get Python to add more things to a list that already exists using .append(). For example, say you have a variable called fruit that contains a list of different kinds of fruit, and you want to add “apple” to that list. You can do that like this: . fruit.append(\"apple\") . If “apple” were stored in a variable call new_fruit, you could also append it to the fruit list using the variable: . fruit.append(new_fruit) . Modify your program to ask the user for another name with input(). Then .append() that name to your list, and print out the full list with 5 names on it. Exercise 3: Alphabetical order . The function .sort() will sort any list you have. If the list is made up off numbers, it will sort from lowest to highest. If the list is made up of works, it will sorts things alphabetically, with words that are capitalized coming before words that are lowercase. So if you have a variable fruit that contains a list, then you can say fruit.sort() to sort that list into alphabetical order. The names program should print out 5 names now. Modify the program to sort the names, and print out the list of names in alphabetical order. Test your program by entering in different names, and seeing if it sorts them differently. Exercise 4: Beginning of the Alphabet . In your program, you can retrieve specific items from the list using []. So, to get the 2nd item from the list stuff, you can say stuff[1]. (Note: Lists in Python always start at 0, so 0 is the first item, 1 is the second, and so on.) . Modify your program to print out only one name: the name that comes first in alphabetical order. Exercise 5: End of the Alphabet . The folks who have last names that start near the end of the alphabet always end up waiting longer. So let’s show some love to the end of the alphabet. Change your program so it prints out the person’s name who appears last in alphabetical order. Hint: There are two ways to do this: find out how long the list is and call the last item in it, or sort the list in reverse alphabetical order to call the first item. Refer to this week’s readings for help with the second option. ",
    "url": "/labs/lists.html#names-names-and-more-names",
    "relUrl": "/labs/lists.html#names-names-and-more-names"
  },"145": {
    "doc": "Lab",
    "title": "Flipping Coins",
    "content": "Next, we are going to use the random package to build a couple of useful tools to help us make choices. As a reminder, before you can use the random package, you need to add import random at the beginning of your program. Exercise 6: Heads or tails . Open up coin.py. This program is supposed to flip a coin - but the program isn’t finished yet. Right now it just generates a random number between 1 and 2, stores it in the variable num, and prints out the number it generates. Run it to see how it works - the number it prints should change if you run it enough times. Edit the program so it prints out “Heads” if num is 1, and “Tails” if num is 2 (or if it isn’t 1). Exercise 7: Coin flipper bias . The coin.py program flips a single coin and prints out either heads or tails. Let’s test to see if this program is biased. Modify the program to flip the coin 20 times and print out the results of each flip. Hint: You will need to use a loop for this. Look back at the lab on loops for help. Exercise 8: Coin flipper counter . Modify your coin flipping program to count how many heads and tails it gets. At the end of the program, it should print out the counts – how many heads came up, and how many tails came up. Hint: You can use a counter to do this (which is sometimes known as an “accumulator”). You create a variable, and then set it to zero as a place to start. Then, each time through a loop, you add 1 to it. It looks something like this: . counter = 0 while looping: counter = counter + 1 print(counter) . Hint 2: you’ll likely need two counters: one for heads, and one for tails. Where should the counter for tails go in the code if you only want it to go up whenever the coin is tails? . Exercise 9: Coin flipper user input . Modify the program to ask the user how many times it should flip the coin. Then have the program flip a coin that many times, and count how many heads and tails it gets. At the end of the program, it should print out the counts – how many heads came up, and how many tails came up. Hint: Remember the difference between strings and integers. When a user enters a response to input(), it is stored as a string. If you want to use it as a number, you need to convert it to one using int(). ",
    "url": "/labs/lists.html#flipping-coins",
    "relUrl": "/labs/lists.html#flipping-coins"
  },"146": {
    "doc": "Lab",
    "title": "Choosing a restaurant",
    "content": "It is always difficult to choose where to go for lunch when you are with a bunch of friends. We are going to build a restaurant choosing program to help with the choice. Let’s start by looking at restaurant.py and running it. It should ask the user for 3 restaurants, and then print out the list of restaurants. Exercise 10: User experience of counting . Python counts starting a zero: 0, 1, 2, 3, etc. Regular human beings, on the other hand, start counting at 1: 1, 2, 3, 4, etc. Right now, the program asks for “restaurant 0” first. Modify the program so that it looks like human beings would expect, starting with 1. Hint: the program should still ask for 3 restaurants. Hint 2: In for i in range(3), i is a variable that changes value each time the loop is run. Where is that value showing up in what prints out as the program runs? Note where i is being used inside the for loop. Exercise 11: Random Choice . The function random.choice() will pick a random item out of a list, and return that item. So if you have a list of stuff, you can say random.choice(stuff) to get a random thing out of that list. Modify the restaurant program to use this to randomly choose a restaurant for lunch, and print out which restaurant the computer chose. Note: Remember to import the random library (import random) at the beginning of your program. Exercise 12: More (or less) than 3 . This is where lists really shine. Lists are great because you don’t have to know ahead of time how many items are going to be in the list. They get bigger or smaller as needed. Right now, the restaurant.py program always asks for exactly 3 restaurants. In programmer terminology, we say that “3” is “hard-coded” into the program. Modify the program to ask the user how many restaurants they are thinking about for lunch, and then have it ask them for that many restaurant names, and then pick a random restaurant from that list. So if they say they are thinking about 5 restaurants, your program should ask them for 5 names of restaurants, and then pick from among those 5. If they say 2, it should only ask them for 2 restaurant names. Here is a potential use of the program: . How many places are you thinking about for lunch? 4 Enter the name of restuarant 1: Jimmy Johns Enter the name of restuarant 2: Chipotle Enter the name of restuarant 3: Five Guys Enter the name of restuarant 4: Noodles and co. You should go to Noodles and co. Hint: Remember the difference between strings and integers. When a user enters a response to input(), it is stored as a string. If you want to use it as a number, you need to convert it to one using int(). Hint 2: Notice that I made the program a little more user friendly by printing out the words “You should go to” in addition to the final choice. It is always a good idea to try to make things easier for your users to use and understand. ",
    "url": "/labs/lists.html#choosing-a-restaurant",
    "relUrl": "/labs/lists.html#choosing-a-restaurant"
  },"147": {
    "doc": "Lab",
    "title": "Challenges",
    "content": "If you finish with the exercises above, try at least one of the challenges below. The challenges are starting to give a little less direction - as you get further into programming, you get fewer and fewer directions for how to do things, and have to do more work to figure it out yourself. Challenge 1: Unlimited Restaurant Options . Modify your program so that it doesn’t need to ask ahead-of-time for the number of restaurants. The user should be able to just keep entering restaurants until they type “done” or just hit enter or something. Then it will randomly choose one of the ones they entered and print it. The program should still accept as many restaurants as they want. Here is an example output: . Enter the name of a restuarant: Culvers Enter the name of a restuarant: Chipotle Enter the name of a restuarant: Jimmy Johns Enter the name of a restuarant: No Thai! Enter the name of a restuarant: Potbellys Enter the name of a restuarant: You should go to No Thai! . Hint: while True: will loop forever. You can break out of a loop with the break command. An elegant way to break out of a loop with user input is to only have the break command run if the user enters a specific word, like “quit”. Challenge 2: Infinite coin flipper . Make a copy of your coin program and call it infinite.py. Modify the program so that it keeps flipping coins as long as the user wants it to. It should flip a coin, and then ask the user if it should continue. If the user says “yes”, it should go and flip another coin, and then ask the user again. It should keep doing that until the user says “no”. As a bonus, have the program print out the percent of coin flips that have come up “heads”. To get this, you can divide the number of “heads” by the total number of coin flips (heads + tails), then multiply the result by 100. Don’t forget to add this program to your git repository. Hint: while True: will loop forever. You can break out of a loop with the break command. An elegant way to break out of a loop with user input is to only have the break command run if the user enters a specific word, like “quit”. Heads Should I continue? yes You have flipped 1 coins 1 have come up Heads Which is 100% Tails Should I continue? yes You have flipped 2 coins 1 have come up Heads Which is 50% Heads Should I continue? yes You have flipped 3 coins 2 have come up Heads Which is 66.66666666666666% Heads Should I continue? yes You have flipped 4 coins 3 have come up Heads Which is 75% Tails Should I continue? no . Challenge 3: Song list randomizer . Start a new program called songs.py that asks the user for several songs they want to listen to, then present the list of songs in a random order. Don’t forget to add this program to your git repository. Hint: random.shuffle(list) will randomly re-order a list. Picture in your head putting each item in your list on a separate index card, and then shuffling the deck of index cards. Hint 2: you can ask the user how many songs they want in the list ahead of time, OR you can let them keep adding songs until their song list is complete. If you do the second option, you could use a while loop. ",
    "url": "/labs/lists.html#challenges",
    "relUrl": "/labs/lists.html#challenges"
  },"148": {
    "doc": "Lab",
    "title": "Lab",
    "content": " ",
    "url": "/labs/lists.html",
    "relUrl": "/labs/lists.html"
  },"149": {
    "doc": "Readings",
    "title": "Readings",
    "content": "Lists . | Automate the Boring Stuff: Chapter 4 - Lists | How to Think Like a Computer Scientist: Lists | . Randomness . | Random Numbers in Python - this reading might look familiar. Does it make more sense this time around? | The Random Module | . ",
    "url": "/readings/lists_and_randomness.html#readings",
    "relUrl": "/readings/lists_and_randomness.html#readings"
  },"150": {
    "doc": "Readings",
    "title": "Summary",
    "content": "For the summary this week, think about what we’ve done in class already. Summary prompt: Summarize your thoughts about lists, and about using randomness with lists. Focus on ways they would make what we’ve already done in class easier (or harder?). ",
    "url": "/readings/lists_and_randomness.html#summary",
    "relUrl": "/readings/lists_and_randomness.html#summary"
  },"151": {
    "doc": "Readings",
    "title": "Question",
    "content": "As per usual, your question can be one of three types: . | Confusion: what didn’t you understand in the readings? | Curiousity: what do you want to know more about? | Connection: how does this topic connect to your own experiences? | . Submit your summary+question on D2L under Quizzes before class starts on Tuesday. ",
    "url": "/readings/lists_and_randomness.html#question",
    "relUrl": "/readings/lists_and_randomness.html#question"
  },"152": {
    "doc": "Readings",
    "title": "Readings",
    "content": "This week we’re learning about lists and revisiting the random module, which we started using a couple weeks ago. ",
    "url": "/readings/lists_and_randomness.html",
    "relUrl": "/readings/lists_and_randomness.html"
  },"153": {
    "doc": "Readings",
    "title": "Readings",
    "content": "The readings for this week cover three topics. First, we will learn a bit more about strings and about the print() function, which outputs strings. We’ve been using both in class already. Second, we’ll learn about two kinds of loops – while loops and for loops. And third, we’ll learn a bit about using random numbers in Python. Strings and Print() . | Automate the Boring Stuff, Chapter 6: Manipulating Strings – Stop reading at “Project: Password Locker” | The print() function in Python – Stop reading at “Printing Custom Data Types” | . Loops . | Loops in Python | . Randomness . | Random Numbers in Python | . ",
    "url": "/readings/loops.html",
    "relUrl": "/readings/loops.html"
  },"154": {
    "doc": "Readings",
    "title": "Summary",
    "content": "For the summary this week, focus on loops and randomness. Think about similar things you have encountered before. Summary prompt: How would you describe loops and randomness in your own words, and what do you think each thing might be used for in programs? . ",
    "url": "/readings/loops.html#summary",
    "relUrl": "/readings/loops.html#summary"
  },"155": {
    "doc": "Readings",
    "title": "Question",
    "content": "As per usual, your question can be one of three types: . | Confusion: what didn’t you understand in the readings? | Curiousity: what do you want to know more about? | Connection: how does this topic connect to your own experiences? | . Submit your summary+question on D2L under Quizzes before class starts on Tuesday. ",
    "url": "/readings/loops.html#question",
    "relUrl": "/readings/loops.html#question"
  },"156": {
    "doc": "Readings",
    "title": "Readings",
    "content": "Please read the following: . | Think Python, Section 14.9 – Writing Modules | Working with Modules in Python | Modules Tutorial – don’t read 6.4 on Packages | . All of these readings describe ways to break up a python program into multiple different source files, called “Modules”, instead of putting all of the code into a single python file. Breaking up programs into multiple modules is important for scale – as your programs get bigger and better, putting it all in one file gets complicated quickly. Think about the programming work that you’ve done so far, and what you might do in the future. How many files will you use? What goes in each file? We usually try to put related code in files together – so all the code that does drawing might go in one file, and all the code that accesses twitter might go in another file, and so on. In your summary for this week, think about and try to come up with a strategy for deciding when to break up a program into multiple files, and how to decide what goes in what file. Then, write down a question. It can be a point of confusion or a needed clarification about anything in the readings, or it can be something interesting that you thought about while you were reading that goes beyond the reading. Or it can be an example you thought about, or a connection you made between the concepts here and other parts of your life. But write down a good question or example based on what you were thinking about while reading. The summary + question for this week can be submitted on D2L. ",
    "url": "/readings/modules.html",
    "relUrl": "/readings/modules.html"
  },"157": {
    "doc": "Studio",
    "title": "Advice",
    "content": "Reuse Code . Last week in Studio 11 you wrote code to create a word cloud from a file. This studio is similar. Try to see if you can reuse any of the code you wrote last week to help with this week’s studio. Last’s weeks instructions also include examples of word clouds to help you with inspiration. Finish the Lab . If you didn’t finish this week’s lab, you should make sure that at least one person in your group finished through Exercise 8 – getting TMDB API access working. If not, go back and do Exercise 8, and possibly all of the exercises. Specifically, you should make sure that you can retrieve and print out movie information from TMDB first. If not everyone in your group finished the lab, ask the student(s) who got the furthest to show the code from the lab to the others in your group and explain how it works. That will help everyone be on the same page as you work on the studio today. How much data do you need? . Think about how much data do you need to draw your word cloud? Only getting 1 actor probably isn’t enough to be meaningful. Getting 1000 actors seems like a lot. How much data do you want to use? You might want to limit the size of your cloud. Visual Size . You can do things to make your visualization more interesting. For example, TMDB has a “popularity” score for each actor that indicates how popular she/he is. You could sort the list by popularity, and/or draw more popular actors in a larger font. Expand to Actor Cloud . Rather than just displaying a word cloud for a movie, can you make a version that takes an actor’s name, and displays his/her movies? Each movie has a popularity score also that you could sort by or use to control the font size. Movies also have budget information, so you could make movies with bigger budgets have a larger font? Be creative. Improve the wordcloud and the layout . You made word clouds last week also. You can and should definitely re-use that code for this week’s studio. But think about how you can make it better. Can you make the layout of the words on the screen better? . You’ve got a movie that you are representing visually. Another way of thinking of the “movie cloud” is as a text-based movie poster. Have your program draw a poster-like representation of the movie on the screen with turtle. Does that shift in mindset give you ideas for how it might look? . Challenge: User Input . Once you get a movie cloud drawn, try to accept user input. Allow the user to type in the name of a movie. Get the list of actors for that movie, and draw them on the screen in a movie cloud. Try it out; can you make it work for multiple different movies? . ",
    "url": "/studios/movie_cloud.html#advice",
    "relUrl": "/studios/movie_cloud.html#advice"
  },"158": {
    "doc": "Studio",
    "title": "Studio",
    "content": "For this studio, you should write a program that creates a Movie Cloud. A movie cloud is a word cloud, but about a movie. Your program should ask the user for the name of a movie. Then it should search that movie in The Movie Database, and get the list of actors in the movie. Using turtle, it should draw the the name of the movie in big letters, and then the list of the top actors in the movie. That’s it. Get a movie name, query TMDB, draw a word cloud of actors . Have fun with it. Be creative. What follows is just advice for doing it. You don’t have to follow my advice. Do whatever you want. This is just my experience in doing this, and you might want to do it differently. ",
    "url": "/studios/movie_cloud.html",
    "relUrl": "/studios/movie_cloud.html"
  },"159": {
    "doc": "Lab",
    "title": "Organizing your Program",
    "content": "As you begin to write longer and more complex programs, it becomes more important to stay organized as you work. Earlier in the semester, you would put all of the code in one file, with no line breaks or other ways of organizSing the code. Today, we are going to practice a few skills that will make it easier to stay organized. Exercise 1: Refactoring – Red stripes . Run the program refactor.py in this week’s git repository. It should draw something that resembles a US flag. The program is over 250 lines long! And there is a LOT of repetition in that program. We can better organize our code in a way that will make it easier to read, shorter, and work better. So let’s try to do that. This is called “refactoring” – rewriting code so that it does exactly the same thing, but the code is easier to read, makes more sense, and hopefully will be easier to use in the future. Start by reading the code in refactor.py. Think about what it does. As you read it, you’ll find yourself mentally organizing the code in your head – “OK so this part draws the first red stripe. Then this part moves the turtle down to the next stripe.” and so on. Pay attention to that. The logical sections that appear in your head should become sections or functions in the code. Let’s start with those first two blocks of code. The first block draws a red stripe. The second block moves the turtle to be ready to draw the next stripe. Your exercise is to create functions for those. Take the code for the red stripe, and put it into a function called red_stripe(). Now go through the code, and every time it draws a red stripe, replace the the code with a call to the red_stripe() function. That is, delete the extra copies of the current code that draws a red stripe, and replace it with a call to your res_stripe() funtion. There are 7 red stripes in the US flag, so there should be 7 calls to red_stripe(). Exercise 1.5: Move Next . Next, look at the 2nd block of code. It moves the turtle to be ready to draw the next stripe. Put that code into a move_next() function. Go through the code and every time it tries to move the turtle for the next stripe, replace it with move_next(). Since there are 13 stripes in the flag, there should be 13 calls to move_next(). When you run the program, it should still draw exactly the same flag as it did when you began. But the program should be much shorter now. Exercise 2: Refactoring – Generalize to stripe() . The first exercise involved copy-and-pasting code into functions, and then calling those functions. This is a really common part of refactoring, and it is important. Just giving sections of code a name can make the code easier to read and understand. But once you give it a name, you often realize that it can do more than just one thing. We only replaced the red stripes. THe program also draws white stripes, with almost exactly the same code. For this exercise, change the red_stripe() function to just be stripe(), and add a parameter that allows you to specify what color you want the stripe to be. That is, you should be able to say stripe(\"red\") or stripe(\"white\") to get either a red stripe or a white stripe. Now, see if you can replace more of the code with this stripe() function. You should be able to replace all of the code that draws all 13 stripes with calls to this function. When you run the program, it should still draw exactly the same flag as it did when you began. Exercise 3: Refactoring – Generalize to colored_rectangle() . OK, we’ve done a good job of making our program much, much shorter. It is also easier to read and understand now. Let’s keep going. We’ve got a bunch of code that draws a blue box on top of our red-and-white stripes. We could copy-and-paste this code into a blue_box() function. But, looking at the code, it looks surprisingly similar to the code for the stripes we had before, doesn’t it? . Let’s see if we can add some more parameters to our stripe() function to allow us to draw a blue box. We already can specify the color of the box. But right now, stripe() always draws a rectangle that is 300 by 10. Let’s add some more parameters to our stripe() function to specify how far across and how far up the rectangle should be. ALso, since we are logically changing what this function does, we should also rename the function to better reflect what it does. How does the name colored_rectangle() sound? So, we could call colored_rectangle(\"red\", 300, 10) to draw a red strip, and colored_rectangle(\"blue\", 100, 70) to draw the blue box. Modify the flag code to make this happen. When you run the program, it should still draw exactly the same flag as it did when you began. Exercise 4: Refactoring – Moving helper functions to a module . If you look at your code now, it is really in two parts. First, there are a couple of helper functions – colored_rectangle() and move_next(). And second, there is the main code, that calls these functions. Let’s move these helper functions to a separate python file. Create a new file called flag.py, and move these two functions into that new file. Since you use turtle commands in this file, you will need from turtle import * at the top of the flag.py file. Then, back in your main file, delete these functions. Instead, you should be able to import flag – which will import these functions from this “helper” file into your main file for use. You can then call them by saying flag.colored_rectangle() or flag.move_next(). This allows you to separate your code into parts. The drawing helper file contains a small set of functions that help out, and then the main file uses those functions, but is much shorter and easier to read. When you run the program, it should still draw exactly the same flag as it always did, but now, it should be much easier to read and modify the program. Hint: If you import flag, then you have to say flag.function(). If, instead, you say from flag import *, then you can use the functions directly as function(), without having to say flag.. ",
    "url": "/labs/organizing_your_program.html#organizing-your-program",
    "relUrl": "/labs/organizing_your_program.html#organizing-your-program"
  },"160": {
    "doc": "Lab",
    "title": "Separating Content and Logic",
    "content": "Next, turn your attention to the program flashcards.py. Run that program. It should print out a set of questions about state capitals, and ask you for the answers. It will tell you if you get it right, and then at the end tell you how many you got right. Let’s see if we can refactor this program also. Read the code in flashcards.py. It is very repetitive, isn’t it? Let’s see if we can make it easier to read and understand. Exercise 5: Refactoring – Write a flashcard function . Each of the flashcards has a set of code that displays a prompt and then checks what the user inputs against an answer. The only thing that varies between flashcards is the prompt, and the correct answer. Let’s refactor this code into a flashcard() function. The function can accept two parameters – a prompt, and an expected answer. Move code for displaying a question, getting the answer from the user, and then checking to see if it is correct or not into the function. Then modify the main part of the program to call the flashcard function 4 times, to ask the same 4 questions as it currently does. When you run the flashcard program, it should look the same to the user as it currently does. Exercise 6: Refactoring: Moving the content into a dictionary . Right now, the content of the flashcards – the questions and answers – is mixed with the logic of the flashcard program. The logic controls what order the flashcards should be displayed, when the user should be asked for an answer, what counts as a correct answer, etc. Mixing the content of the flashcards with the logic of the program makes it hard to update either. If you want to add new flashcards, you have to understand how the program works to know what to change. If you want to change how the program works, you have to work around all of the content of the flashcards in doing so. Let’s try to separate the logic of the program from the content in the program. Let’s put all of the content in a single dictionary, where each key is a prompt for the user, and the value associated with that key is the expected answer. This dictionary should be hard-coded at the top of the file, and will contain the same 4 questions as we asked before. Remember that you can hard-code dictionaries: . cards = {} cards['Wyoming'] = 'Cheyenne' ... OR . cards = { 'Wyoming': 'Cheyenne', ... } . Once we have the content of the flashcards in a dictionary (which I call cards), then we can loop through the dictionary to display the flashcards – something like this: . for prompt, answer in cards.items(): flashcard(prompt, answer) . When you run the program, it should do the same thing as before. But the content of the flashcards should be in a dictionary. If you want to add a new flashcard, you shouldn’t have to change the code at all. Instead, you should just add a line to the dictionary. Try this; add one additional flashcard about another state capital to the dictionary, run the program, and verify that you can add new flashcard content without changing the main code. Note: If a dictionary only contains state names and capitals, then the rest of the prompt needs to be included as part of the input statement inside flashcard(). Inside an input statement, you can’s use comma’s like in print, but you can use +: . user_entry = input(\"What is that capital of \" + prompt + \"? \") . Note 2: If you want to make it easy for users, make everything lowercase. You can use .lower() on the user’s input to convert it to lowercase. You’ll also want to convert the state names/titles to lowercase with .lower(): . if cards['Wyoming'].lower() == user_entry.lower(): . A good way to remember this is if you are using .lower(), then both sides of the equal sign should use .lower() so everything that you are comparing is always lower case. Exercise 7: Moving the content into a separate file . The previous exercise talked about separating content and program logic – but the content is still being specified in a python dictionary. That means that to update the list and add new flashcards, whoever is doing that has to understand the syntax for python dictionaries. If you are working on a team, some of your teammates (who might be content experts but not programmers) will find this hard. Let’s make it easier for them. Let’s read in the list of state capitals from a file, and then generate flashcards from that. That way, if they want to update it, they can just edit that file and not have to edit code. I’ve put the list of 4 state capitals in a text file called capitals.txt in the lab repository. You’ll also need a function that reads in the state capitals and puts them into a dictionary. Try to write that code. But, if you want, you can also look in the file read_cards.py. In it is a function that reads in the state capitals and returns a dictionary that looks exactly like the one in Exercise 6 – they key of the dictionary is the prompt, and the value is the answer. Copy-and-paste the function into your program. Instead of manually specifying the states and capitals in your code, call this function to read in the cards from a file: . cards = read_cards(\"capitals.txt\") . This dictionary should basically look exactly the same as the dictionary from Exercise 6. Except this time, it is being read in from a file instead of being hard-coded in the python file. This way, instead of manually specifying flashcards in your program, you fully separate the content and the program logic. The program logic is in the flashcards.py file, and the content of the flashcards is in the capitals.txt file. The flashcards.py program should still do exactly the same thing that it always did, but now, the python file doesn’t actually contain any actual content. Exercise 8: Put helper functions in a separate file . The flashcards.py program should basically contain two parts – a couple of helper functions to display a flashcard and read information from a file, and the main part that loops through the dictionary displaying flashcards and counting results. This is a very similar structure to what we had for the flag.py program above – a couple of helper functions and a main program. Let’s organize the code the same way we did above. Put all of the helper functions into a separate file. Then, in the main flashcards.py file, import that other code and use it. Exercise 9: Create 50 flashcards for all 50 states . The file capitals-all.txt contains the capital cities of all 50 US states, one per line. Modify your program to test the user’s knowledge of all 50 capital cities, and report whether they get each one right. If you did this right, this should be REALLY easy – you should just change the filename that is being read in, and the program should automatically adjust and handle it correctly. See how easy it is to add new flashcards once you’ve separate content and program logic? . Exercise 10: Change the flashcards to sports . For the next exercise, let’s really push and see how easy it is to add new flashcards. Modify your program to ask the user which team certain players play for. Create a new text file that contains a list of player names and the name of the team that they play for. Have your flashcard program load in that file instead of the state capitals file. Hopefully, this should be pretty easy. You just put the names in a text file, and your same flashcards.py program should work with minimal modifications. Hint: The file currently contains information in the form capital, state. That is, the answer is first, followed by a comma, then the question. If you want to change that to something else, then it is a good idea to maintain the same answer, question format. Challenge 1: More Refactoring of the flag . The code in the first two files (flag.py) still seems to contain a bunch of redundancy and repetition. Are there other ways that you can continue to refactor the code? Can you create additional helper functions in flag.py? Can you move things to for loops to make it clearer and easier? Should move_next() be called at the end of colored_rectangle()? Or maybe, we should create a stripe() function that calls both colored_rectangle() and move_next()? What do you think would be the easiest-to-understand way of organizing the code? . Challenge 2: Randomize the order of the flashcards . Now that we’ve separated the content from the program logic, it is also easier to make changes to the program logic. Modify your program to randomize the order that it asks users the flashcards. Verify that it works by using it with the 50 state capitals, and with your sports players file. Hint: cards.keys() will give you a list of all of the prompts. Once you have a list, you can use random.shuffle() on that list to reorder that list into a random order. You can then use a for loop to loop through that new order of prompts. Given a prompt, you can use cards[prompt] to figure out the expected answer. Challenge 3: Refactoring – Handling the count correctly . Now that we have moved the question-and-answer code into a flashcard() function, we need to create a way for the function to tell the main code whether the person got it right. Really, though, all the main code cares about is how many the user got right. And since the flashcard() function only asks one question, for that function, the answer is either 0 or 1. Let’s have the flashcard() function return either a 0 or a 1 to indicate whether the user got it right. Then the main code can add up the number of 1’s to figure out the total, like this: . count_right = 0 count_right += flashcard(\"What is the capital of North Dakota? \", \"Bismark\") count_right += flashcard(\"What is the capital of Wyoming? \", \"Cheyenne\") ... See if you can use this to add functionality that counts how many the user gets right. And it should also print out the number correct at the end of the flashcards. Hint: You can use len(cards) to get the total number of entries in a dictionary. ",
    "url": "/labs/organizing_your_program.html#separating-content-and-logic",
    "relUrl": "/labs/organizing_your_program.html#separating-content-and-logic"
  },"161": {
    "doc": "Lab",
    "title": "Lab",
    "content": " ",
    "url": "/labs/organizing_your_program.html",
    "relUrl": "/labs/organizing_your_program.html"
  },"162": {
    "doc": "Lab",
    "title": "Code Reading",
    "content": "For each of the following exercises, your goals is not to write code. It is to read the code and write comments. You should not need to modify the code at all. Instead, you will need to read through the code and figure out what it does. You are going to use the python timer program on the command line. For each exercise, I will give you an amount of time. Set your timer for that amount of time, and then work on reading the code. Only after your timer goes off can you run the code to see what it does. Your first job is to figure out what the code does without running it. After the timer goes off, run the code, and then go back to the code and use what you now know about the program to try to figure out how it does it. As you work, think out loud. You are working with a partner. Think out loud, and work with your partner to try to figure out what the program is doing. You should be spending a LOT of time talking to each other during this lab. One person (the ‘driver’) should pull up the code on their computer, and then both of you can talk about what it is doing and how it is doing it. As you figure out what the code does, you will need to add comments to the code that describe what is happening. As a reminder, if you put a # symbol in the code, python ignores everything that comes after that symbol (which we call a ‘comment’). For each line of code, add a comment to the code that explains what that line is doing. Do this for each line of code in the program. You are done with the exercise when you have a comment for every line of code, and also an comment at the top describing the program as a whole. Like this: . # Purpose: this program keeps asking the user if they want to stop, and stops when they say so while True: # Keep looping forever, until \"break\" answer = input(\"Do you want to stop? \") # Ask the user if they want to stop, and store the result in answer if answer == \"yes\": # Check if what the user typed in is the word \"yes\", all lowercase break # if it is \"yes\", then break out of the while loop # End of the loop, go back to the top of the while loop print(\"Done looping!\") # Print message AFTER loop is broken out of to let the user know the break was successful . Important: As you finish two to three exercises, before you move on to the next one, ask the instructor or TA to come over and look at your comments to make sure that they aren’t missing anything. This is important; often we will ask you questions that reveal that you might not have fully understood the program. Hint: Use print . After the timer goes off, if you are still trying to figure out what the program does, you should use print(). Add print() statements to the program and run it again to print out the contents of variables (or lists or dictionaries) so you can see what is stored in them. This will help you think about what the program does and how it works. Exercise 2 . Set your timer for 2 minutes. Look at the program in ex2.py. Read the code, and write comments for each line of code as described above. What does this program do? . After your timer goes off, you are allowed to run the program to see and help you. But don’t run it before the timer goes off. Try to read the code and figure out what it does before the timer goes off. Exercise 3 . Set your timer for 5 minutes . Look at the program in ex3.py. Read the code, and write comments for each line of code as described above. What does this program do? . After your timer goes off, you are allowed to run the program to see and help you. But don’t run it before the timer goes off. Try to read the code and figure out what it does before the timer goes off. As a reminder, every non-blank line of code should have a comment describing what it is doing, and also why that line is needed as part of the program. Once you are finished with exercises 2 and 3, ask the instructor or TA to check your comments before moving on. Exercise 4: . Set your timer for 5 minutes . Look at the program in ex4.py. Read the code, and write comments for each line of code as described above. What does this program do? . After your timer goes off, you are allowed to run the program to see and help you. But don’t run it before the timer goes off. Try to read the code and figure out what it does before the timer goes off. Exercise 5: . Set your timer for 5 minutes . Look at the program in ex5.py. Read the code, and write comments for each line of code as described above. What does this program do? . After your timer goes off, you are allowed to run the program to see and help you. But don’t run it before the timer goes off. Try to read the code and figure out what it does before the timer goes off. Once you are finished with exercises 4 and 5, ask the instructor or TA to check your comments before moving on. Exercise 6: . Set your timer for 8 minutes . Look at the program in ex6.py. Read the code, and write comments for each line of code as described above. What does this program do? . After your timer goes off, you are allowed to run the program to see and help you. But don’t run it before the timer goes off. Try to read the code and figure out what it does before the timer goes off. Once you are finished, ask the instructor or TA to check your comments before moving on. Exercise 7: . Set your timer for 7 minutes . Look at the program in ex7.py. Read the code, and write comments for each line of code as described above. What does this program do? . After your timer goes off, you are allowed to run the program to see and help you. But don’t run it before the timer goes off. Try to read the code and figure out what it does before the timer goes off. Once you are finished, ask the instructor or TA to check your comments before moving on. Exercise 8: . Set your timer for 10 minutes . Look at the program in ex8.py. Read the code, and write comments for each line of code as described above. What does this program do? . After your timer goes off, you are allowed to run the program to see and help you. But don’t run it before the timer goes off. Try to read the code and figure out what it does before the timer goes off. Once you are finished, ask the instructor or TA to check your comments before moving on. Don’t forget to add, commit, and push all of your comments to your git repository. Challenge: Eliza . Also in the git repository for this week is the Eliza program that you ran the very first week of the semester. Do this same code reading exercise on that program: for each line of the program, put a comment next to it describing what that line does and how it works. Pay particular attention to the responses variable. What is stored in that variable? It is a list. But a list of what? How does that work? How does it get used? . ",
    "url": "/labs/practice_reading.html#code-reading",
    "relUrl": "/labs/practice_reading.html#code-reading"
  },"163": {
    "doc": "Lab",
    "title": "Lab",
    "content": "You have spend almost all of the lab and studio sessions writing code for this class. Writing code is relatively straightforward – you enter code into the text editor, you run the code, see if it does what you want it to, and then change it until it does. One aspect of this is that you don’t always have to really understand what the code it doing – sometimes you get lucky and it just works. The goal for today is to practice reading code. Reading code is harder than writing code. Reading code requires you to think more carefully about what each line of a program is doing. It requires you to keep track of what is stored in variables, and what variables contain what information. It requires you to think through options for if statements, to try to understand why they are there. You are going to practice reading today, to try to get better at doing so. Reading code is one of the best ways to become a better programmer, once you have the basics down. But reading code is a skill that requires practice, just like all other skills. Exercise 1: Timer . Start by looking at the file timer_seconds.py. Run it. What does it do? . Open up the code for timer_seconds.py and see how it works. time.sleep() waits a specified number of seconds. So if you say time.sleep(10), it will wait 10 seconds. If you say time.sleep(20), it will wait 20 seconds. If you wanted to wait for minutes instead of seconds, how would you do that? Think about how you might want to modify this program if you wanted to ask the user for how many minutes the user wants to wait. Then have the program wait that many minutes. Remember, if you have a number of minutes, you can calculate how many seconds that is by multiplying by 60 (since there are 60 seconds in a minute). Now look at the program timer.py. Is that how you would have done it? . Check and make sure the timer program works; run it, ask it for a 2 minute timer, wait two minutes, and see if it tells you to stop at the end of that minute. ",
    "url": "/labs/practice_reading.html",
    "relUrl": "/labs/practice_reading.html"
  },"164": {
    "doc": "Lab",
    "title": "Using Functions with Parameters",
    "content": "Today, we are going to write code to build a checkboard using turtle, and writing some of our own functions. Today’s lab is focused on learning more about how functions are actually used in real programming. You are always welcome to revisit past labs to refresh your memory. Exercise 1: Squares . The file board_1.py wants to draw a game board, but it is missing the code for its square function. The square function takes two parameters – how big the square should be, and what color the square should be. Fill in the code for this function. Test this. Does it work? It should draw a large black square on the screen. You can also test this by going down to the line where square(400, 'black') is called, and change the number to a different size. Does it draw a different size square? (It should.) This is generally a good idea when working with functions. Run the program a couple of different times, putting different values in the parameter to make sure that the function does what it is supposed to do. Don’t forget to put it back to the way it started (400, \"black\") when you are done testing it. Exercise 2: Red Squares . The file board_1.py draws a large black square. Let’s change this to draw a large red square. If you wrote your function well, then all you should need to do is change one line near the bottom to say 'red' instead of 'black'. Try that: . square(400, \"red\") . Test this. Does it work? It should draw a large red square on the screen. If it does, then great! You finished this exercise. If it doesn’t – if it still draws a black square – then your function isn’t working the way it is supposed to. Go back to your function and modify it so that it draws whatever color square is specified on that line at the bottom of the program. Exercise 3: Row of Squares . The file board_2.py continues our work toward building a game board. Copy-and-paste the code for your square function into this file. You should see another function, called row. It wants to draw a row of squares. Write the code to do this. You should build on your square function; that is, you should repeatedly call your square function to draw a row of squares all the same color. As you do this, think carefully about side effects. When you a call a function, it has side effects. For turtle, the side effects include moving the turtle and changing the direction the turtle is facing. If your function has side effects, that can cause problems if you call the function multiple times, or if you call other functions after it. To deal with this, it is a good idea to try to make sure our functions are predictable – they always leave the turtle in the same place it started and facing the same direction it started. So, make sure that all of the right() or left() turns in the function always turn a total of 360 degrees. If your square function from Exercise 1 has side effects, you might have to modify it to make it work in the row. Hint: You should use a for loop with a range() parameter to draw the row; for i in range(number): . Hint 2: You shouldn’t need to write turtle code for drawing a square again. Just call your square() function to draw the square! . Hint 3: The hard part about this execise is understanding parameters of functions. It might help to go back to the readings and look at how they talk about parameters. Remember that parameters are variables; they get filled in with whatever is passed into the function when it is called, and you use them like normal variables, but only inside the function. Hint 4: No hard-coded numbers are needed for the row() function. ",
    "url": "/labs/practicing_functions.html#using-functions-with-parameters",
    "relUrl": "/labs/practicing_functions.html#using-functions-with-parameters"
  },"165": {
    "doc": "Lab",
    "title": "Return Values",
    "content": "In Python, functions can return values that they figure out. For example, you’ve already used the input() function, which does 2 things: it prints out a prompt, and then it returns whatever the user enters. You then store that returned value into a variable when you say variable = input(\"prompt\"). Exercise 4: Next Color . Look at the file color.py. It contains a function called next_color that returns a value – a string containing the name of a color. Right now, it always returns \"black\" as the next color. Run the program, and you can see what it does. The program has a variable called col that stores the current color, and prints out what it thinks the current color is. Then it calls next_color, and It changes the current color from red to black. Then it repeats that again – calling next_color and printing out what the current color is. However, since next_color always returns \"black\", the current color always stays black. next_color takes a parameter of what the current color is. Modify the next_color function to use an if statement to return different colors. If the current color is “red”, return black. If the current color is “black”, return red. What happens when you run this program now? . Exercise 5: Checkerboard . Let’s combine the last 3 exercises to see if we can get python to draw a checkerboard pattern on the screen. Copy and paste your code from the previous three exercises into the board_full.py files. Then you should modify the row() function so that after it draws each square, it changes the color to whatever is returned from next_color. This should hopefully allow you to draw a checkerboard pattern on the screen. Reminder: If you put speed(0) at the top of your file, turtle will draw much faster. Hint: If you are having trouble getting it to work, try reading the code under draw_board() that calls next_color() to see how it is used. Exercise 6: Draw a Rainbow . Let’s take a detour from our board game. The program rainbow.py is designed to draw a rainbow. However, it currently only draws a weird orange box with a red stripe on top. It needs you to implement the function is next_color(). This function is interesting. It takes one parameter – the current color – and then figures out what the next color should be. That next color is then returned from the function. This is really similar to the next_color function from the previous exercise. Except this time, it needs to needs to handle more than just back-and-forth. Finish writing this function. Once you finish writing this function, the program should draw a rainbow on the screen. Note: The colors of the rainbow, in order, are usually red, orange, yellow, green, blue, indigo, and violet. OR, maybe, red, orange, yellow, green, cyan, blue, violet if you prefer. Exercise 7: Rainbow Checkerboard . You’ve now got a nicer next_color function. You should be able to put that into the checkerboard file (replacing the black-and-red one) and produce a rainbow checkerboard! . Start by opening board_full.py and doing a File –&gt; Save As and saving a new copy as rainbow_board.py. You should be able to do this by only replacing the next_color function. Hint: You might need to make it cycle; make it so that the next color after the last color in the rainbow is the first again. ",
    "url": "/labs/practicing_functions.html#return-values",
    "relUrl": "/labs/practicing_functions.html#return-values"
  },"166": {
    "doc": "Lab",
    "title": "How are functions used?",
    "content": "So far, you’ve written functions that take parameters and do different things based on those parameters, and also functions that return values. But why do we separate things into functions? What is the point? . In this section of the lab, we will try to understand the idea of abstraction: we can use functions to make programming easier by abstracting away the difficulties. Let’s take our checkerboard for example. What if we wanted to put a checker on one of the spots of the board. How would we do that? Right now, you’d have to do a lot of work to figure out where on the screen it should go, and sizes, etc. Let’s see if we can make that simpler by writing a couple functions… . Exercise 8: Draw a Circle on a square . Go back to board_full.py. When you run it, the turtle stopped at the upper-left square of our checkerboard. Add a new function called draw_piece that draws a red circle on that square. It should take no parameters, and draw a piece on whatever square the turtle currently is on. Hint: The whole checkerboard is 400 pixels across, and there are 8 squares acrosss. So each square is 400/8 pixels. You don’t need to do the math; the computer can do it for you. Just specify 400/8 to get the right size. Reminder: Turtle has a circle() function that draws a circle counterclockwise. It takes one parameter – the size (radius) of the circle. Use it (along with begin_fill() and end_fill() to draw a filled in circle. Note that the radius should be half of the size of a square – so if 400/8 is the size of a square, the radius of the circle should be 400/8/2. Hint 2: Don’t hard-code locations using goto(). That might work for this exercise, but it will make it hard to do the next exercises where we move the pieces to different locations on the board. Reminder 2: Don’t forget to call your draw_piece() function at the end of the file. Exercise 9: Goto a square . We can give the squares numbers. Let’s start in the upper left, where the turtle is and where you just drew a piece. Let’s call that square (1,1). The one just to the right of it then will be (2,1) (and (3,1), (4,1), etc.). The one just below it will be (1,2). The lower right corner square is (8,8). I’ve written a function called goto_square(), located in the file goto_square.py. It takes two parameters – the square number coordinates. It then moves the turtle to the upper left hand corner of that square on the checkerboard. Copy-and-paste that function into your checkerboard program. Exercise 10: Place a piece on square (5,6) . Combine these two functions. Use the goto_sqaure() function to goto square (5,6) on the board. Then use your draw_piece() function to draw a circle in the middle of that square. Exercise 11: Place a piece on a square the user specifies . For the final exercise today, ask the user which square to put a piece on (using textinput(), which is very similar to input() and we used in Week 5). You’ll have to ask twice – once for the row, and once for the column. Do you see how functions make this easier? Now, instead of having to do that complicated math each time you want to draw something on a square, you just call your goto_square() function which does the thinking for you. You just tell it which square to draw on. This is one way functions are really useful. They provide an abstraction – now that you have the goto_square() and draw_piece() functions, you don’t need to think about circles, lines, and fills. All you need to do to play checkers is to goto a specific checkers square, and draw a piece there. Because of the functions, you can think about checkers pieces and not about turtle lines/fills. ",
    "url": "/labs/practicing_functions.html#how-are-functions-used",
    "relUrl": "/labs/practicing_functions.html#how-are-functions-used"
  },"167": {
    "doc": "Lab",
    "title": "Challenges:",
    "content": "Challenge 1: Checkerboard function . Take the code that I wrote and put it into its own function that draws a checkerboard. Modify the function to accept a new parameter – the number of squares across on the board. Right now, it does an 8x8 checkerboard. Use your new function to draw a 10x10 checkerboard. Note: You don’t have to make the piece drawing work for this. Challenge 2: Multiple pieces . Use a loop to ask the user for multiple locations, and place a piece at each location they tell you to. Challenge 3: Remove a piece . How would you remove a piece from the board? Write a function to remove a piece from a specific square. ",
    "url": "/labs/practicing_functions.html#challenges",
    "relUrl": "/labs/practicing_functions.html#challenges"
  },"168": {
    "doc": "Lab",
    "title": "Lab",
    "content": " ",
    "url": "/labs/practicing_functions.html",
    "relUrl": "/labs/practicing_functions.html"
  },"169": {
    "doc": "Readings",
    "title": "Readings",
    "content": "Please read these readings: . | Automate the Boring Stuff, Chapter 15 – Time (stop at Multithreading) | https://spin.atomicobject.com/2017/06/01/how-to-read-code/ | https://selftaughtcoders.com/how-to-quickly-and-effectively-read-other-peoples-code/ | . Also, please skim through the following: . | Automate the Boring Stuff, Chapter 2 – Starting with “While Loops” and going to the end | Automate the Boring Stuff: Functions: Functions | Think Python: Chapter 10: Lists | Automate the Boring Stuff: Chapter 5 – Dictionaries and Structuring Data | . Yes, you read those before. Skim through them again. Now that you’ve spent some time working with these ideas (for loops, lists, dictionaries, functions), they should make sense in a different way. When you read through these again, you’ll see the ideas in a completely new and different way. As you re-read these, what new things do you notice that you didn’t last time? Is there anything that makes more sense this time through than last time? Summarize what new things you learned by re-reading these readings again and thinking about them after having written code using these concepts. Submit this summary on D2L. Then, write down a question. It can be a point of confusion or a needed clarification about anything in the readings, or it can be something interesting that you thought about while you were reading that goes beyond the reading. Or it can be an example you thought about, or a connection you made between the concepts here and other parts of your life. But write down a good question or example based on what you were thinking about while reading. The summary + question for this week can be submitted on D2L. ",
    "url": "/readings/reading_code.html",
    "relUrl": "/readings/reading_code.html"
  },"170": {
    "doc": "Lab",
    "title": "Word Counter",
    "content": "For this series of exercises, we are going to build up a program that counts words in a file (how many times each word appears) and prints the results. ",
    "url": "/labs/reading_files.html#word-counter",
    "relUrl": "/labs/reading_files.html#word-counter"
  },"171": {
    "doc": "Lab",
    "title": "Using dictionaries to count",
    "content": "Dictionaries are useful any time you have key/value information – you want to associate one thing (the ‘key’) with another thing (the ‘value’). So far, we have always stored words in a dictionary. Let’s do something new: let’s store a number in the dictionary (as the ‘value’, or the ‘definition’). That number can represent how many times we’ve seen a word. Exercise 1: Ducks and Sheep . Consider the phrase “duck duck goose”. The word “duck” appears twice, and the word “goose” appears once. The program count.py specifies a dictionary that stores these counts and prints them out. It says that there are 2 ‘ducks’ and one ‘goose’. Each word is used as a key for the dictionary, and then the value for that key is the number of time that word appears. Once we are done making the dictionary, each key is a word and the value for that key is the count of the number of times the word appears in “duck duck goose”.. Modify the program to instead report counts for the phrase “Baby, Im just gonna shake, shake, shake, shake, shake”. You should use the same program structure: setdefault() each possible word to 0 at the top, and then use a single line to increment the counter for each word of the phrase. Hint: += is used to add to an existing number. So . var += 10 . is the same as saying . var = var + 10 . Exercise 2: Print out one letter at a time . You can use a for loop to pull each letter out of a string and loop through the letters in a string. So, for example, if you write: . for letter in \"Hello\": print(letter) . Then it will loop through each letter of the string “Hello”, put it in the variable letter, and then print out the letter. Then it will put the next letter of “Hello” into letter, and print out that letter. And so on. Create a new program to print out each letter of the phrase “Baby, I’m just gonna shake, shake, shake, shake, shake”, one letter per line. Hint: This exercise does NOT use dictionaries at all. Exercise 3: Letter Count . The next exercise is to modify the program to automatically count how many times each letter appears in the phrase, by combining the two previous exercises. Using the same for loop from exercise 2, instead of printing out the letters, count them like we did in Exercise 1. Use a dictionary to count how many times each letter appears in the phrase. The keys should be the letters, and the values should be the counts. Your goal here is to add each letter that’s in the phrase to the dictionary, and as you go through the phrase with the for loop, instead of printing out the letter, you add one to the count for that letter so that the program counts how many times that letter appears. When you are successful, your counting program should print out the letter counts for that phrase: . {'B': 1, 'a': 7, 'b': 1, 'y': 1, ',': 5, ' ': 8, 'I': 1, '’': 1, 'm': 1, 'j': 1, 'u': 1, 's': 6, 't': 1, 'g': 1, 'o': 1, 'n': 2, 'h': 5, 'k': 5, 'e': 5} . Note: You will need to handle what happens if the letter isn’t already in the dictionary. You may want to use the setdefault() function. To do this, you say: . my_dictionary.setdefault('word', 'default_value') . The way this works is that it looks in the my_dict dictionary. If word already exists in the dictionary, it does NOTHING. If it doesn’t exist, then it creates an entry in the dictionary for word and sets its value to default_value. That is, it is the same as saying: . if 'word' not in my_dictionary: dict['word'] = 'default_value' . The way we normally use this is in combination with +=. You first setdefault(), which makes sure that key exists in the dictionary and set it to a default value (like 0) if needed. Then you +=. On future loops, the setdefault() doesn’t do anything because the key already exists, and only the += happens: . for i in range(10): dict.setdefault('word', 0) dict['word'] += 1 . Using setdefault() is safe. If there isn’t anything in the dictionary, then setdefault() will make sure there is soemthing in the dictionary. But if there already is something in the dictionary for that keyword, then it doesn’t touch the dictionary. If you don’t do this, then the increment line will cause an error if the word isn’t already in the dictionary. Exercise 4: Letter counts for the whole song . Here is the whole refrain to the Taylor Swift song: . ‘Cause the players gonna play, play, play, play, play And the haters gonna hate, hate, hate, hate, hate Baby, I’m just gonna shake, shake, shake, shake, shake I shake it off, I shake it off Heartbreakers gonna break, break, break, break, break And the fakers gonna fake, fake, fake, fake, fake Baby, I’m just gonna shake, shake, shake, shake, shake I shake it off, I shake it off I shake it off, I shake it off I, I shake it off, I shake it off I, I shake it off, I shake it off I, I shake it off, I shake it off . Modify your program to count how many times each letter appears in this song. Here is what I got: . {'\\n': 14, '‘': 1, 'C': 1, 'a': 56, 'u': 3, 's': 29, 'e': 47, ' ': 91, 't': 24, 'h': 31, 'p': 6, 'l': 6, 'y': 8, 'r': 11, 'g': 6, 'o': 18, 'n': 14, ',': 35, 'A': 2, 'd': 2, 'B': 2, 'b': 8, 'I': 17, '’': 2, 'm': 2, 'j': 2, 'k': 34, 'i': 12, 'f': 30, 'H': 1} . Hint: In python, hard-coded strings normally all appear on one line: \"hello\". If you want a string to be more than one line long (like the lyrics above), you can use triple double-quotes around it. So something like this: . lyrics = \"\"\" These are the lyrics to a song that span more than one line and don't rhyme \"\"\" . Exercise 5: Word Count . Python has a really useful function calles split(). The split function takes a string and divides it into a list of words. So if I have a string: . s = \"I shake it off\" . and I run s.split(), then it will split it into a list of words: . [\"I\", \"shake\", \"it\", \"off\"] . Modiy your program to run split() on the full song lyrics above and print out the result. What does split() do? . Exercise 6: Word Count, pt 2 . After splitting, you can use the same type of program as exercise 4 to count words. Modify your count program to count how often each word appears in the song from exercise 6, rather than each letter. How many times does the word “shake” appear in the refrain of the song? . Hint: You can loop through the list of words the same way you looped through letters: for word in s.split(): . Exercise 7: Pretty print . You’ve got a really nice counting program at this point. However, the way that python prints out dictionaries is really annoying and hard to read – its all on one line! . Modify your program to loop through all of the words in the dictionary, and print out the count for each word on a separate line. You can do this by calling dict.keys() – which returns a list of all of the keys (words) in the dictionary. You can then use a for loop to loop through that list. ",
    "url": "/labs/reading_files.html#using-dictionaries-to-count",
    "relUrl": "/labs/reading_files.html#using-dictionaries-to-count"
  },"172": {
    "doc": "Lab",
    "title": "Working with Files",
    "content": "Exercise 8: Print out a file’s contents . If you look in the repository, there is a file there called “wordcount.py”. It contains the beginning of a program. Right now it just opens a file and reads it one line and prints it out. Notice that it uses the with() command. With allows you to open a file, and then everything in the with block – everything indented below the with command – has access to the file. As soon as a line runs that isn’t indented, then python closes the file, and you no longer have access to it. Also, remember that with is NOT a loop; it only runs once (like if). Modify this program to read in the whole file, one line at a time, and then print out that file one line at a time. You will need to ADD a loop to the program. There are two ways to read in a file. Choose one, and try to get it working: . | One way is to put the f.readline() function inside a while loop. It returns \"\" (the blank string) when it gets to the end of the file, so you can break out of the loop when you see a blank string (e.g. while line != \"\"). | The other way is to use a for loop – for line in f:. If you use this, then the for loop implicitly does a readline() behind the scenes, saves each line in the variable line, and automatically stops at the end of the file. (You do NOT need readline() if you use a for loop; you should remove that line if you choose to use a for loop.) . | . Either way will work. Pick one, and modify the program to print out the whole file. Hint: When you open files, you might end up with some weird looking characters. That happens sometimes (especially on Windows). This is called an “encoding” problem. You can solve that by including encoding = 'utf-8' in your open command: . with open(filename, \"r\", encoding = 'utf-8') as f: ... Exercise 9: Print line numbers . Right now, the program is really basic; all it does is print out the contents of the file. But once you have the contents of the line in a variable, you can have your program do more interesting things. We will start with something simple: adding line numbers. Modify your program to print out the line number, and then the contents of the line. So the output should look something like this: . 1 All the world‘s a stage, 2 and all the men and women merely players. 3 They have their exits and their entrances; 4 And one man in his time plays many parts . Hint: To do this, you’ll have to keep track of which line you are on in a variable, and then add one to it ever time you read a new line in. Exercise 10: Print out the total number of lines in the file . Modify the program to print out how many lines are in the file at the very end. This should be pretty easy if you finished the previous exercise. The total number of lines is the line number for the last line, right? . There are a total of 4 lines in this file . Exercise 11: Count the total number of words in the file . Modify the program to count the total number of words in the file. Your program should take each line, split it into separate words, and count the words in the file. Your program should print out the total count after it is finished reading the whole file in. Remember, if you have a variable that contains a string, you can split that into separate words using the .split() function. words_list = line.split() . Once you have them in a list, you can then count them: len(list) returns the length of list (the number of items in that list). number_of_words_in_line = len(words_list) . Exercise 12: Change the file you read from . Right now, the program always reads the same file – ‘short.txt’. Modify the program so that when you run it, it instead reads in the file ‘medium.txt’, prints it out with line numbers, and calculates information for that file instead. ",
    "url": "/labs/reading_files.html#working-with-files",
    "relUrl": "/labs/reading_files.html#working-with-files"
  },"173": {
    "doc": "Lab",
    "title": "Make the program do more interesting things",
    "content": "Exercise 13: Count how many of each word . In all of the exercises you have done so far, you should just be counting the total number of words. For this exercise, modify your program to instead count how many times each word appears. You should have a separate count for each word. You already wrote code to count words in a string in Exercise 6. Use that here to count how frequently each word appears in a file. Your program should print out a dictionary that has the count of the number of times each word appears in the file, and print out that dictionary. When I run mine on “short.txt”, these are the counts I get: . {'All': 1, 'the': 2, \"world's\": 1, 'a': 1, 'stage,': 1, 'and': 3, 'all': 1, 'men': 1, 'women': 1, 'merely': 1, 'players.': 1, 'They': 1, 'have': 1, 'their': 2, 'exits': 1, 'entrances;': 1, 'And': 1, 'one': 1, 'man': 1, 'in': 1, 'his': 1, 'time': 1, 'plays': 1, 'many': 1, 'parts': 1} . Exercise 14: Move to Long . Look at the file long.txt in the repository. It is the play “Twelfth Night” by William Shakespeare. Yes, the entire play. Modify your program to count how many of each word is present in that play. Also, modify your program to “pretty print” the results, so it is easier to read. You can use pprint() for this. ",
    "url": "/labs/reading_files.html#make-the-program-do-more-interesting-things",
    "relUrl": "/labs/reading_files.html#make-the-program-do-more-interesting-things"
  },"174": {
    "doc": "Lab",
    "title": "Challenges",
    "content": "Challenge 1: Sort the words by frequency . Modify your program to only print out most common words that appear in the input file, with the most common words first. You can do this by sorting the dictionary and looping through your sorted dictionary, and then print out the word and the count. Make sure the output looks nice and is easily readable by humans. Dictionaries are stored in python in a random order. It is not possible to actually sort a dictionary like you can sort a list. However, you can loop through the dictionary in a specific order. Here are some options: . Sort by key . for key in sorted(dict): print(key, dict[key]) . Sort by value . for key in sorted(dict, key=dict.get): print(key, dict[key]) . Reverse sort (highest first) . for key in sorted(dict, reverse=True): print(key, dict[key]) . Combined (reverse sort by value) . for key in sorted(dict, key=dict.get, reverse=True): print(key, dict[key]) . Choose one of these options and use it to sort your dictionary and print out the the words in order by how common they are. When I print out most common words in “medium.txt”, this is what I get: . and: 5 thou: 4 shall: 3 to: 3 of: 3 fair: 3 a: 2 summer’s: 2 more: 2 the: 2 ... Hint To get the same counts as I did, you will need to get the program to ignore capitals / lowercase issues. The way I did that is I converted all the words to lowercase using .lower() . Challenge 2: Top 10 most common words . Modify your program to only print out the 10 most common words that appear in the input file. You should be able to do this by keeping a separate counter, and then using break to stop the loop after you’ve printed out 10 words. Challenge 3: Stop List . Modify your program to run on “long.txt”. When you run your program on “long.txt” and look at your top 10 list, you’ll notice that many of the top words are obvious – I, of, to, a, etc. Let’s try removing the really common, obvious English words to see if we can get a list of the more unique words in the files. This is called making a stop list. Create a list at the top of your file that contains common English words. Then, when you are reading in the file, if you see a word in that list, skip that word. Once you have the stop list working, run your word counting program on “long.txt”. What are the 10 most common words in Shakespeare’s Twelfth Night, not counting really common boring words? . Hint: Python supports not in a list. If you have a list of stop_words, you can say . if word not in stop_words: ... Challenge 4: Top 10 words in a different Shakespeare play . Pick a different Shakespeare play that you like, and use your program to figure out the most common words in that play. You can find plain text copies of Shakespeare’s plays on Project Gutenberg. Pick a play, download the “plain text” version of the play, and then run your program on that file. If you do this right, you shouldn’t have to change your code at all; you should just be able to specify the filename on the command line. ",
    "url": "/labs/reading_files.html#challenges",
    "relUrl": "/labs/reading_files.html#challenges"
  },"175": {
    "doc": "Lab",
    "title": "Lab",
    "content": " ",
    "url": "/labs/reading_files.html",
    "relUrl": "/labs/reading_files.html"
  },"176": {
    "doc": "Studio",
    "title": "Advice",
    "content": "Pick any studio . Pick any studio to work on and refactor. It is OK if you didn’t actually finish and get it working when you were originally working on it. If so, then this is your opportunity to finish it. It is also OK if you got it working and all you want to do is refactor the code so it works better. It is up to you which studio to refactor. My recommendation is to pick the studio you liked the best and spend your time working on that; you always do your best work (and learn the most) working on something you care about. Use Functions . Code is much easier to read and work with when it is organized into functions. In addition to grouping lines of code together, functions also give that group of commands a name. Using that name then makes things easier to read and make more sense. Think about what you kinds of things you can group together into functions. Ideally, you will most most of your code into functions, and have a relatively short ‘main’ section that just calls the appropriate functions in the right order. Look for opportunities to refactor . Go back to Monday’s lab for ideas how to refactor. When we looked at our existing code, we looked for a couple of things to identify opportunities for refactoring: . | Add comments. You are going back and reading code that you wrote weeks or possibly months ago. Some of it will feel pretty obvious what it is doing. But some of it won’t. Anything that you feel you had to stare at for more than a few minutes to figure out what it is doing is probably something that isn’t obvious. Once you figure out what it does, add a comment to that describes what it does, so it is easier to remember in the future. | Look for comments. If you have written a comment to yourself about what this set of lines do, then that is a good opportunity to pull those lines into a separate function that has a name. Giving code a name makes it easier to read. | Look for repeated code, or places where the exact same code is repeated multiple times. Pull them together into a function. | Look for similar code — places where code that isn’t exactly the same, but is similar, is repeated multiple times. That is a good candidate for putting into a function with a parameter. Small differences can be controlled with the parameter (like the color parameter to the rectangle function). | Look for opportunities to generalize. Just like we went from red_strip() to stripe(color) to colored_rectangle(...), look for places where you take an existing function, and make it more useful by making it slightly more general than it currently is. (Emphasis on slightly; if you make things too general, then they become less useful). | Remove unneeded code. As you look at the code, you might find things that aren’t needed anymore. Remove them from the file so they don’t get in the way of the more important things. | . Think about the User Experience . Refactoring is a gread opportunity to make minor changes to improve the user experience of running your program. Put yourself in the shoes of someone else running your code. What would make it easier to use? Some things I’ve seen groups do in class so far include: . | Adding spaces in appropriate places (e.g. at the end of an input() prompt) so things don’t run together. | Adding additional text (print() statements) to help explain what the program does and what the user is supposed to do. | Moving the turtle at the beginning of the program up and to the left, so whatever it draws is centered on the screen. | Changing the font or the color or the line thickness so whatever is being drawn by the turtle is easier to see | Speeding up the turtle (with the speed() function) so you don’t have to wait as long for things to draw. (OR have it speed up and slow down at different times as it draws for dramatic effect.) | . Enough with it! . If you think you’ve done enough refactoring with a studio, call for help from either Jack or me and talk us through the changes you made. If we don’t have additional ideas, then you can move on and work on refactoring another studio. ",
    "url": "/studios/refactor_old_studio.html#advice",
    "relUrl": "/studios/refactor_old_studio.html#advice"
  },"177": {
    "doc": "Studio",
    "title": "Studio",
    "content": "Your goal today is refactoring. The task for today is to go back to one of the previous studios that you did, read through the code, and then re-write the code. Your goal in re-writing the code is to make it easier to read, easier to understand, more reusable, and to work better. Much like you did on Monday, you don’t need to change what the program does. You just should revise and rewrite the code to make it do what it already does better. For today’s studio, it is up to you whether you work by yourself or whether you work in a group. You do not have to be working with the same group that you did for the original studio; it is OK to refactor code that others wrote. That’s it. That’s the whole of the instructions – choose a past studio, optionally form a group to work with, and revise the code to work better. Have fun with it. What follows is just advice for doing it. You don’t have to follow my advice. Do whatever you want. This is just my experience in doing this, and you might want to do it differently. ",
    "url": "/studios/refactor_old_studio.html",
    "relUrl": "/studios/refactor_old_studio.html"
  },"178": {
    "doc": "Readings",
    "title": "Readings",
    "content": "TBD . ",
    "url": "/readings/refactoring.html",
    "relUrl": "/readings/refactoring.html"
  },"179": {
    "doc": "Reference",
    "title": "Reference Materials",
    "content": "These materials are here as quick references for students to refer to in and outside of class. ",
    "url": "/reference.html#reference-materials",
    "relUrl": "/reference.html#reference-materials"
  },"180": {
    "doc": "Reference",
    "title": "Reference",
    "content": " ",
    "url": "/reference.html",
    "relUrl": "/reference.html"
  },"181": {
    "doc": "Lab",
    "title": "Requests",
    "content": "We are going to begin by using a simple API that just gives us some current information. To do this, we need to install the requests library. Using the command line, run the command: . pip3 install requests . (If you use VS Code’s built-in python, you’ll need to install requests through VS Code.) . Requests is a library that makes it easy to access APIs through web requests. Exercise 1: Who is on the International Space Station? . There is an API available on http://api.open-notify.org/ that provides information about the people who are currently in space. One of the things that it can do is tell you who is currently present on the space station. To get that, we use the astros.json endpoint. Use the requests library to retrive the list of current astronauts on the International Space Station and print out what the API returns. To query the API, you can use the requests.get() function, and tell it which endpoint you want to query. If you save the results of that query into a variable called people, then you can print out people.text to see what it sent back. (You will need to import requests at the top of your file to load the library.) . Start by looking at the file iss.py in the lab repository. It has the correct URL for the API. Call the requests.get() function (after importing requests) and pass in the URL for ISS information. Then save the results into a variable called people.. people = requests.get(astronauts) . The results is a complex variable with many parts. You want to print out the .text part of that variable to see who is on the ISS. print(people.text) . Exercise 2: Parse the JSON response . You will notice that the response is actually quite complex. It is in a data structure called “JSON”. Fortunately, python makes it pretty easy to convert something from JSON to normal python dictionaries and lists. We can use the json library and use the json.loads() function to convert from JSON to python: . import json info = json.loads(people.text) . Once you have loaded the json into a python dictionary, use pprint() (from the pprint library) to pretty print out the whole dictionary. When working with APIs, I have found that using pprint() to pretty print the resulting dictionary is important for helping me to see the structure of the data that I get from the API. Hint: You will probably need to from pprint import pprint for this exercise. Hint 2: We use pretty printing back in the lab where we talked about complex python data structures – week 8. Exercise 3: Human Readable Output . Once you have converted into a python dictionary, then you can use the normal python tools like for loops and [] to access it. For example, asking for info['number'] will return the number of people currently in space, and info['people'] will return a list of dictionaries about the people currently in space. Note each person is represented by a dictionary with multiple keys, include 'name'. Convert the response of this API to python dictionaries, and then write code to make the output easier to read; something like this: . Number of people in space: 3 Andrew Morgan Oleg Skripochka Jessica Meir . Hint: It is almost always best to go through a list with a for loop: . for person in response['people']: # The person variable now containts a dictionary for a person . Hint 2: The people currently in space frequently changes as people launch and land. You might not get the same number or same people as it was when I wrote this. That’s one of the coolest parts of APIs; they can be current and up-to-date. ",
    "url": "/labs/requests.html#requests",
    "relUrl": "/labs/requests.html#requests"
  },"182": {
    "doc": "Lab",
    "title": "APIs with Parameters",
    "content": "You can think of an API request like you are calling a function – except that function is somewhere else across the internet. Like functions, you can add parameters to the request to tell it more what you want to do. You can add parameters to a request by putting the parameters in a dictionary, and passing it to the requests.get() API call. Exercise 4: Find words that rhyme with your name . Datamuse has a nice, easy to use API that will give you words that are related to other words in various ways. One thing you can do with this API is request words that rhyme (sound like) a word that you provide. To do that, you pass a parameter called rel_rhy (for “related” to by “rhyme”) to the datamuse words API, and set that paramter equal to the word you want to rhyme. You can add parameters to a requests.get() call by putting them into a dictionary and then passing that dictionary as a second parameter: . parameter = {\"rel_rhy\": \"stuff\"} rhyming = requests.get(datamuse, parameter) . The file rhyme.py in the lab has the Datamuse API endpoint. Create a dictionary with one item in it – rel_rhy as the key, and your last name as the value. Then call the API, and print out what it returns. Printing out the raw JSON is fine; don’t convert it or parse it yet. Hint: You’ll need to remember to import requests to use the requests library. Hint 2: Remember, to get the JSON data out of the result of the API call, you need to use .text like you did in the previous exercises. Exercise 5: Pretty print the JSON response . The raw JSON that is returned by DataMuse is complicated and hard to read. This is unfortunately pretty normal for APIs – they give you a LOT of information, and you need to pick through it to get what you want out. The first step is understanding what they give you back. For this exercise, your goal is to pretty print the results from the previous exercise. You will need to first convert the results from JSON to a python dictionary using json.loads(). Then you can use the pprint() function to print it out in a readable form. Hint: You will probably need to import json and from pprint import pprint for this exercise. Hint 2: We use pretty printing back in the lab where we talked about complex python data structures – week 7. Exercise 6: Accept user input, . Let’s make this rhyme finding program more user-friendly. Modify the program to accept user input. Ask the user what word they want to find a rhyme for, and then pass that word into the API. You can do this the same way you have all semester by using the python input() command. Hint: You will need to modify the dictionary you pass to the api to include the word input by the user. Exercise 7: Print out the top 5 rhymes . The API returns the a complicated JSON thing. You already converted the JSON to a python dictionary using json.loads(). Now then print out the top 5 rhyming words (and only 5) that match. Only print out 5 words, no more and only print out the words (no scores or anything else in the dictionary). For example, if I want to rhyme the word ‘time’, I could run the program and get: . What word do you want to rhyme? time paradigm sublime rhyme prime crime . ",
    "url": "/labs/requests.html#apis-with-parameters",
    "relUrl": "/labs/requests.html#apis-with-parameters"
  },"183": {
    "doc": "Lab",
    "title": "APIs with authentication",
    "content": "Both the Astronauts API and the Datamuse API can be used by anyone, without needing an account. Most APIs are not that open, though. Most APIs require you to have an account and to authenticate (prove who you are) before you are allowed to make queries. This is more complicated for APIs than it is on normal websites; they don’t just use a username and password. Instead, they use more complicated setups like OAuth or APIKey to do the authentication. For today’s lab, we are going to access the API at The Movie Database (TMDB). TMDB uses an access key for access. You have to create an account on TMDB’s website, and ask it to generate an access key for you. Then you need to include that access key with every request you make, so they know it is you. Exercise 8: Sign up for TMDB, Create a new app, and retrieve the access key. In order to be able to access TMDB’s API, you need to have a TMDB account. If you do not already have a TMDB account, go to https://www.themoviedb.org/signup and sign up for an account now. You will need to verify your email address before you can move forward. Only one member of your pair needs to do this. To access all of the TMDB developer features, use their developer portal: https://developers.themoviedb.org/3/getting-started/introduction. Once you have signed in, you will see a profile icon next to the search icon in the upper right hand corner. Click on that profile icon and it will bring up a menu. Choose choose “Settings”. On the settings page, there is an option on the left called “API”. Click that. You will see a list of all “Apps” that you have created. For an API, an App is a program that you are writing that needs permission to access the API. As a developer, you can create more than one app (if you want). Most likely, you have no apps there right now. Click on “Create” to create a new “App” for the program we are writing, and then choose “Developer” option.. Accept the terms of service, and then TMDB will then present you with a form about that app that asks you for a lot of information. Fill it the form – give your app a name, provide a description, etc. You can use this website (http://mi250.cas.msu.edu) for the required website. Make it a personal app. Once you create the app, you will be taken to the App page that shows the information you just submitted. On that page you should see the API key and the access token. These keys identify which app you are using, so TMDB (the company) can tell which program’s API access is being used. Copy-and-paste those into the appropriate places in the file “movies.py” in our lab. Once you’ve done this, you have everything ready to start access TMDB’s API. Let’s test it. Run the program “movies.py” with your API key. If you get an API key error, then it didn’t work. If you get a bunch of information about a movie, then it worked! . Congrats! You now can access TMDB with a program! . Exercise 9: Pull out important movie information . When you run “movies.py”, the TMDB API returns a data structure – a complicated dictionary that contains lots of information about the movie. Right now, all the program does is print out the whole dictionary. While this has some useful information, it also prints out a ton of information that isn’t needed. Let’s improve our movie information program by only having it print out the important information. Modify “movies.py” to only print out the title, tagline, and overview (in that order): . Black Panther: Wakanda Forever Forever. -------------- Queen Ramonda, Shuri, M’Baku, Okoye and the Dora Milaje fight to protect their nation from intervening world powers in the wake of King T’Challa’s death. As the Wakandans strive to embrace their next chapter, the heroes must band together with the help of War Dog Nakia and Everett Ross and forge a new path for the kingdom of Wakanda. Exercise 10: Print out the genres also . Modify your movie program to print out the movie’s genres also. Notice that a movie can be in more than one genre, and that TMDB gives you the genre in a list. You’ll have to use a for loop to loop through that list and print out the name of each genre: . Black Panther: Wakanda Forever Forever. -------------- Queen Ramonda, Shuri, M’Baku, Okoye and the Dora Milaje fight to protect their nation from intervening world powers in the wake of King T’Challa’s death. As the Wakandans strive to embrace their next chapter, the heroes must band together with the help of War Dog Nakia and Everett Ross and forge a new path for the kingdom of Wakanda. - Action - Adventure - Science Fiction . Exercise 11: Print out the stars also . Next, we are going to modify out movie program to get the list of people who starred in the movie, and print out their names. Notice that the data we get back from TMDB doesn’t actually include the names of any of the actors (the ‘cast’) in the movie. Instead, we are going to need to make a second request of the API. Copy and paste the code that makes the API request, and change the URL to instead use the movie_credits URL. Look closely at that URL; it is the word movie followed by the ID number of the movie (24426) we want, followed by the word credits. This should give you a second set of results. It has two entries: cast is a list of actors in the movie, and crew is a list of the production crew of the movie. We only want to print out the cast for this exercise. Once done, you should print the names of the cast members (at least the top 5 or 10): . Black Panther: Wakanda Forever Forever. -------------- Queen Ramonda, Shuri, M’Baku, Okoye and the Dora Milaje fight to protect their nation from intervening world powers in the wake of King T’Challa’s death. As the Wakandans strive to embrace their next chapter, the heroes must band together with the help of War Dog Nakia and Everett Ross and forge a new path for the kingdom of Wakanda. - Action - Adventure - Science Fiction Starring: * Letitia Wright * Lupita Nyong'o * Danai Gurira * Winston Duke * Dominique Thorne * Tenoch Huerta * Angela Bassett * Florence Kasumba * Michaela Coel * Mabel Cadena . Hint: You will probably need to change the printing code back to just pretty print the dictionary returned by the credits API so you can see what it looks like. Hint 2: The credits request returns a LOT of information. So much that powershell or terminal might not be able to display it all; when you scroll back you might not get all the way back to the beginning. To deal with this, you can limit how deep into the data structure you pretty print. pprint(info, depth=1) only prints the top level dictionary. pprint(info, depth=2) prints the top level and one level underneath it. That can help you see parts of the dictionary when the data structure is REALLY big. Exercise 12: Change to a Different Movie . Let’s change our program to request information about a different movie. Hopefully this should be pretty easy. Let’s get information about the movie with TMDB ID number 600583. What movie is that? . Exercise 13: Searching the Database . For all of the previous exercises, you need to know the exact movie ID number in order to get information about a movie. That isn’t all that helpful if you don’t already know the ID numbers. So instead, we can search the database by name. To do that, we need to use the API slightly different. We need to specify a search query. We do that as a parameter to the API call. We are already passing one parameter – our api_key. We need to add a second parameter called query by adding it as an additional item in the parameter dictionary. We can then use it to search for a movie by name. parameter = {\"api_key\": api_key, \"query\": \"Avengers\"} result_json = requests.get(movie_search, parameter) . For this exercise, create a new program – call it search.py. Make your program to search TMDB for movies with the word “Avengers” in the title. You can and should copy code from your movies.py program as needed. Hint: You will probably need to change the printing code back to just pretty print the resulting dictionary so you can see what it looks like, since the search results dictionary looks different than the movie dictionary or the credits dictionary. ",
    "url": "/labs/requests.html#apis-with-authentication",
    "relUrl": "/labs/requests.html#apis-with-authentication"
  },"184": {
    "doc": "Lab",
    "title": "Challenges",
    "content": "Challenge 1: Print Information About the Top Search Result . When you search for a movie by name using the search API, most likely the first result is the movie you were looking for. Let’s assume that it is. Combine the results of your last two programs / exercises. Search for the movie “Harry Potter”. The first movie in the list of results is probably the first Harry Potter movie. In the dictionary that you get back from the API, you should be able to find the ID number of that movie. Then fill that ID number in to the URLs to get the movie name, tagline, and overview, and also into the URL to get the cast. Print out all of that information in a human-readable form like you did in exercise 11. This program in total should make 3 API queries in total: search, movie, and credits. Challenge 2: Movie Search Progarm (aka user input) . Take the program you wrote for challenge 1, and modify it to accept the search query as an input. That is, your program should ask the user what movie they want to know about. It will then search TMDB for that movie. It will assume that the first result is the movie the user is looking for, and remember the ID number for that movie. Then it will use the API to get inforamtion about the movie such as its full name, tagline, overview, and list of stars, and print out all of that information. This is creating a movie search tool. You type in the name of a movie, and is prints out a bunch of information about that movie. ",
    "url": "/labs/requests.html#challenges",
    "relUrl": "/labs/requests.html#challenges"
  },"185": {
    "doc": "Lab",
    "title": "Lab",
    "content": "There is a limit to what you can do with python alone. But the Internet has a wide range of additional services, and you can use python to access them through APIs. Today we are going to explore how to do this. ",
    "url": "/labs/requests.html",
    "relUrl": "/labs/requests.html"
  },"186": {
    "doc": "Readings",
    "title": "Readings",
    "content": "Please read the following about functions: . | Think Python: Functions | Automate the Boring Stuff: Functions – Stop reading at “Local and Global Scope” | . Yes, you read these before. Now that you’ve worked with functions, read them again. Functions are one of the most important concepts in programming. This time, specifically focus on the ideas of “parameters” and “return values”. You will learn new things when you read them again. Also read: . | Think Python, Chapter 6: Fruitful Functions (Just read section 6.1) | . This week’s readings are about functions. We’ve used functions in the past as ways of simplying naming sections of code. But they are more interesting that than. They can accept parameters that modify what they do, and they can return values. As you read about these features of functions, try to understand how you might use them. Summarize 1) what is a parameter to a function and when might you want to use one; and 2) what is a return value from a function and when might you want to use it? . Then, write down a question. It can be a point of confusion or a needed clarification about anything in the readings, or it can be something interesting that you thought about while you were reading that goes beyond the reading. Or it can be an example you thought about, or a connection you made between the concepts here and other parts of your life. But write down a good question or example based on what you were thinking about while reading. The summary + question for this week can be submitted on D2L. ",
    "url": "/readings/revisiting_functions.html",
    "relUrl": "/readings/revisiting_functions.html"
  },"187": {
    "doc": "Studio",
    "title": "Using Git to share code for the studio",
    "content": "Unlike labs, you will generally start from scratch with studios. That means there’s no existing GitLab repository for you to fork. Instead, you’ll create your own. First, nominate one member of your group to create the repository. You only need one repo for the whole group. | From your projects page in GitLab (this is the main landing page when you first log into Gitlab), click the blue “New Project” button | Choose the “Create blank project” option | On the Create blank project page, give your project a name (Studio 3 works fine, but you can name it whatever you want). Keep all the other options on that page as-is and click the blue “Create project” button at the bottom. | Add your groupmates to the project as members. Also add Caitlin (geierac) and Jack (waierjac). For a reminder of how to do this, see the Git reference page. | . At this point, everyone in the group should check that they have access to the repository, and then use git clone to make a copy of it on their computers. The repo will only have a README file in it when it’s first created, so when you use git clone, it will create a new folder on your computer with just the README file it in. Choose who will start the story - that person should create a new file in the folder that git clone just created. Name it whatever you want, just make sure you add .py to the end of the filename. It’s also good practice not to put spaces in the filename for a program and use dashes or underscores instead, like this: my-new-program.py. The file you create will be the program that you all will take turns working in. You’ll be using Git to pass control of the code from one person to the next. When it’s your turn to write part of the story, here’s what you’ll do: . | before you make any edits, use git pull to bring changes from GitLab down to your computer. | add code to your group’s program and test it by running the program to make sure it works. It’s good practice to make sure your code works as intended before you push it back up to GitLab; otherwise your teammates will have to fix your code before they can run it! | push your changes back up to GitLab using git add, git commit, and git push. | . Once you’ve pushed your code, then it’ll be ready for the next person to pull it down. ",
    "url": "/studios/round_robin.html#using-git-to-share-code-for-the-studio",
    "relUrl": "/studios/round_robin.html#using-git-to-share-code-for-the-studio"
  },"188": {
    "doc": "Studio",
    "title": "Advice",
    "content": "Here’s my advice. You don’t have to take it; I’ve included here to give you ideas of what you can do for this project. The main goal is for you to get comfortable using Git and passing code from one person to the next, and to tell a story together while you’re practicing. Decide how long each person’s “turn” will be . Writing a round robin story means you will be taking turns writing pieces of the story. You can figure out together what you want the story to be about in a broad sense, but each individual piece of the story will be written by one person. Each of you will take turns writing a small bit of the story and code for it and then pass it on to another person in your group using Git. Before you start writing, talk as a group and figure out how much text and code each person will be writing before passing the story on to the next person. Maybe two sentences? Maybe one branch of a story path? Maybe set a timer for 5 minutes? Figure out what makes sense for your group and the story you want to tell. Everyone’s turn should last about the same amount of time so that each person can contribute equally to the story. Make it interactive . You can just write a story using print statements if you want. But you know how to do a few other things with code. For example, last week you learned how to: . | ask for user input | give your story branching paths | replace words with user input Decide as a group what features you want to include in the story - should it be a choose your own adventure, like last week? Should it be some other kind of interactive story where users can add text to it while running the program? Remember you’re not only writing a story, you’re writing a program - what other things can you do that can make the story more interactive? | . Work together! . You will each be writing your own chunks of the story, but that doesn’t mean you shouldn’t be working together. You all have a responsibility to each other to make sure that everyone understands the code that the others are writing. If you get stuck, ask your teammates for help. If your teammate gets stuck, see what you can do to help them. Maybe your code keeps giving you errors, maybe Git isn’t working right, maybe you have writer’s block - all of these are places where your teammates can help you out. Caitlin and Jack are always around to help you get unstuck, too. Include ASCII art . Not everyone loves writing, and that’s okay. If you completely run out of ideas or want to leave the writing to your groupmates, you can make your part of the story visual instead. One very easy way to add images is to use ASCII art - that’s art made by using letters and symbols. In Python, you can use print() statements to print out ASCII art so it shows up in command line. The ASCII Art Archive is a great place to find ASCII art that others have made, or you can make your own. Hint: ASCII art usually takes up multiple lines and it can be a pain to use print() for every single line. Another way is to use triple quotes before and after a block of text (or symbols), like this: . print(\"\"\" stuff stuff stuff \"\"\") . This method will preserve the line breaks of whatever you put inside. Be aware that Python sees the backslash symbol - \\ - as something special, even when it’s in a string. Your text editor might highlight these as a different color. You can “escape” a backslash by adding a second backslash after the first - doing this means you’re telling Python to print the first backslash. ",
    "url": "/studios/round_robin.html#advice",
    "relUrl": "/studios/round_robin.html#advice"
  },"189": {
    "doc": "Studio",
    "title": "Studio",
    "content": "Today’s studio is a creative exercise aimed at get you used to sharing code with other people using Git. You’ll be practicing what’s called round robin storytelling - this is when one person starts a story, then passes it on to the next person who adds to it, and then to the next person, who adds even more, and so on. You’ll be using Git to share code this week - and also to write the story. The first person will start writing the story and building the code around it, then will push it up to GitLab so the next person can pull it down and start writing a new part of the story/program. ",
    "url": "/studios/round_robin.html",
    "relUrl": "/studios/round_robin.html"
  },"190": {
    "doc": "Schedule",
    "title": "Course Schedule",
    "content": ". | Week | Topic / Readings | Lab | Studio | . | Week 1 (Aug 29 / 31) | Course Introduction | Intro to Class | Getting Started with Python | . | Week 2 (Sept 5 / 7) | Variables, Flow | Control Flow | Choose your own adventure | . | Week 3 (Sept 12 / 14) | Version Control | Git and GitLab | Round Robin | . | Week 4 (Sept 19 / 21) | Loops and Variables | Counting and Loops | Flashcards | . | Week 5 (Sept 26 / 28) | Drawing | Turtles | Country Flag | . | Week 6 (Oct 3 / 5) | Lists and Randomness | Using Lists | Guestbook | . | Week 7 (Oct 10 / 12) | Functions | Drawing with Functions | | . | Week 8 (Oct 17 / 19) | Dictionaries | | | . | Week 9 (Oct 24 / 26) | Modules | NO CLASS - fall break | | . | Week 10 (Oct 31 / Nov 2) | Revisiting Functions | | | . | Week 11 (Nov 7 / 9) | Reading Code | NO CLASS - election day | | . | Week 12 (Nov 14 / 16) | Files | | | . | Week 13 (Nov 21 / 23) | Refactoring | | NO CLASS - Thanksgiving | . | Week 14 (Nov 28 / 30) | APIs | | | . | Week 15 (Dec 5 / 7) | Creativity | | | . ",
    "url": "/schedule.html#course-schedule",
    "relUrl": "/schedule.html#course-schedule"
  },"191": {
    "doc": "Schedule",
    "title": "Schedule",
    "content": " ",
    "url": "/schedule.html",
    "relUrl": "/schedule.html"
  },"192": {
    "doc": "Taking screenshots",
    "title": "Mac OS",
    "content": "Full screen: cmd + shift + 3 Your screen will flash and the screenshot will automatically save. Portion of screen: cmd + shift + 5 Your cursor will look like a crosshair. Click and drag your mouse to select the part of the screen you want to screenshot. When you let go, the screenshot will save. Screenshots usually save to the desktop. ",
    "url": "/reference/screenshots.html#mac-os",
    "relUrl": "/reference/screenshots.html#mac-os"
  },"193": {
    "doc": "Taking screenshots",
    "title": "Windows",
    "content": "Full screen: Windows key + Print Screen (PrtScn) Your screen will flash and the screenshot will automatically save. Portion of screen: open the built-in Snipping Tool with Windows key + Shift + S. Your screen will go dark and your cursor will look like a plus sign (+). Click and drag your mouse to select the part of the screen you want to capture. Screenshots usually save to Pictures -&gt; Screenshots. You can also use the Snipping Tool to take full screen screenshots, to annotate screenshots, and to specify where you want your screenshot to be saved. Search for “snipping tool” using the search bar next to the Windows logo to find and open the application. ",
    "url": "/reference/screenshots.html#windows",
    "relUrl": "/reference/screenshots.html#windows"
  },"194": {
    "doc": "Taking screenshots",
    "title": "Taking screenshots",
    "content": "Each week, students will need to turn in screenshots of the work they’ve done in class. The best times to take screenshots are: . | For labs: after each completed exercise | For studios: at the end of the studio | . Screenshots should show the code working. If it’s just code, take a screenshot of the code running successfully in command line (Terminal on Mac or Powershell on Windows). If it’s visual (using Turtle), take a screenshot of the turtle window after the code has drawn. ",
    "url": "/reference/screenshots.html",
    "relUrl": "/reference/screenshots.html"
  },"195": {
    "doc": "Studio",
    "title": "Advice",
    "content": "What follows is just advice for doing it. You don’t have to follow my advice. Do whatever you want. This is just my experience in doing this, and you might want to do it differently. One function per emoji . Functions work best when they comprise a logical, coherent thing. You want each function to make sense on its own, and to do one “logical” thing. When functions try to do too much in one function, it gets confusing. So, you can create a function smiley() that draws a smiley face emoji. It should do everything that is needed for the smiley face. Also, you don’t want it to do things other than what the name implies. So, a smiley() function should only draw a smiley face. It shouldn’t also move the turtle around to other places, or change the turtle colors, or anything like that. If the function has side effects, then it gets confusing when you should use the function and when you shouldn’t. Try to avoid your functions having side effects. Create your own emoji . Everyone knows the standard smiley face emoji. People have come up with hundreds of new emoji. I encourage you to create your own emoji that capture ideas or feelings that you have! You can use an existing emoji if you want, but it is much more fun to create your own emoji. Keep your emoji simple . Emoji are supposed to be simple pictograms. Work hard to keep them simple. Don’t spend hours tweaking your emoji to get it just right. Start simple and get the basic emoji working. You can always make it more complex later. Besides, sometimes simple things can convey ideas more effectively than complex things. Divide and conquer . Split up the emoji between team members. One of the nice things about functions is that it is really easy to divide up the work. One person can work on one function, and another person can work on the other. This makes it easy to divide up the work in a reasonable, logical way. Also, if you are each working on different functions, git can usually merge the changes easily. Just make sure that you are all working in a clone of the same git repository. If you want to avoid potential git conflicts, you can also each create your own file for each emoji and assign one team member to combine the code into a single file towards the end of class. Finish each emoji at the start . Remember for the bar() function in the lab, the code was set up to draw a bar, then move the turtle in advance of the next bar, then draw the next bar. But this only worked well if the turtle finished drawing the bar in the same place and orientation where it started from. So if the turtle started at the top left of the bar and facing to the right, it should be at the position both at the start of the bar() function and at the end. You’ll want to do something similar with emojis - draw an emoji, move in prep to draw the next emoji, then draw the next emoji. It’s much easier to do this if, in each emoji function, you include code so that the turtle ends up exactly where it started after the emoji is done drawing. Then the code to move to where the next emoji starts can be the same between every emoji. Following this principle makes it much easier to collaborate, too! If everyone in your group is working on a different emoji, it’s easier to put them together into one program at the end if you know that each emoji drawing will end where it started. Support functions . In addition to having a separate function for each emoji, you might want to create a function or two to help with other things that you need to do. For example, could you create a next() function that moves the turtle to the right and gets it ready to draw the next emoji? . Look for common features . As you work on your emoji, you might notice that you have common features. For example, if you are drawing both a smiley face and a frowning face, both of them will have the same circular face. That is an opportunity to create a support function. You could in this case create a function that draws a blank face (a circle of the appropriate color). Then your smiley function could call the blank face, and then draw the eyes and mouth. Your frowning face could also call the blank face function first, and then draw a different eyes and mouth. Creating support functions for common features like this is a great way to avoid lots of copy-and-pasting of code. It also makes it easier if you want to change something later on. If you want to change the skin color, for example, you only need to change it in the one place (blank face), rather than find all the places in your code that have a skin color. ",
    "url": "/studios/speak_in_emoji.html#advice",
    "relUrl": "/studios/speak_in_emoji.html#advice"
  },"196": {
    "doc": "Studio",
    "title": "Challenge",
    "content": "If you get the basic emoji sentence working and you have time left in the studio today, try this challenge: . The emoji sentence that your program draws is “hard-coded” – it always draws the same sentence (the same emoji in the same order) every time. Instead of hard coding a sentence, modify your program to allow the user to specify which emoji should be drawn in which order. For example, your program could work like this: . This program has the following emoji: 1. Smiley face 2. Frowney face 3. Winking face 4. Sticking out tongue (enter 0 to stop) Which emoji should be first? 1 Which emoji should be next? 1 Which emoji should be next? 2 Which emoji should be next? 4 Which emoji should be next? 3 Which emoji should be next? 0 . And then it prints out the emoji sentence specified by the user. ",
    "url": "/studios/speak_in_emoji.html#challenge",
    "relUrl": "/studios/speak_in_emoji.html#challenge"
  },"197": {
    "doc": "Studio",
    "title": "Studio",
    "content": "Emoji are graphical representations of ideas and concepts – basically, they are pictograms. It is possible to convey complex concepts and ideas using nothing but emoji. Smiley face emoji are particularly interesting because they often convey emotions better than words do. Emoji are especially powerful when you put one after the other to form emoji “sentences”. Your goal for today is to write a set of functions that draw emoji using turtle graphics. Each function should draw one emoji. Then use those functions to draw out an emoji “sentence” on the screen that conveys some complex feeling or idea. As usual, work in groups of 2-4 people. ",
    "url": "/studios/speak_in_emoji.html",
    "relUrl": "/studios/speak_in_emoji.html"
  },"198": {
    "doc": "Syllabus",
    "title": "MI 250: Intro to Applied Programming - Syllabus",
    "content": ". | Fall 2023 Time and Location | Instructors | Course Description | Required Technology . | In-class technology usage | . | Course Structure . | Pair Programming | . | Coursework . | Homework | Labs | Studios | Final project | Turning in work | Extra credit | Honors option | . | Coursework Expectations and Grading . | Grading scale | . | Communication Policies . | Announcements | . | Attendance / Absence Policy . | Illness | Exceptions | . | Other Policies . | Accommodations for disabilities | Spartan Code of Honor | Academic honesty | Mental health | Technical assistance | Tolerance and civility | . | . ",
    "url": "/syllabus.html#mi-250-intro-to-applied-programming---syllabus",
    "relUrl": "/syllabus.html#mi-250-intro-to-applied-programming---syllabus"
  },"199": {
    "doc": "Syllabus",
    "title": "Fall 2023 Time and Location",
    "content": "Tuesdays and Thursdays, 10:20am-12:10pm Holden Hall C131 Synchronous, in person – no hybrid options available . ",
    "url": "/syllabus.html#fall-2023-time-and-location",
    "relUrl": "/syllabus.html#fall-2023-time-and-location"
  },"200": {
    "doc": "Syllabus",
    "title": "Instructors",
    "content": "Instructor: Caitlin Geier (she/her/hers) Email: geierac@msu.edu Office hours: Monday and Tuesday afternoons, by appointment: book a time Office: Room 525, Communication Arts and Sciences . Course assistant: Jack Waier Email: waierjac@msu.edu Office hours: by appointment - email or talk to after class to find a time . ",
    "url": "/syllabus.html#instructors",
    "relUrl": "/syllabus.html#instructors"
  },"201": {
    "doc": "Syllabus",
    "title": "Course Description",
    "content": "This course is an undergraduate course aimed at students who have little to no programming experience and who don’t intend to be programmers. There are many roles in the tech industry today which don’t involve programming, but which work alongside programmers. The goals of this course are to teach students enough to be “dangerous” at programming, to learn about computers and programming environments, and to practice skills around talking about programming, co-learning, and collaboration. These skills are incredibly useful not only for programmers, but also for other media and technology roles, such as user experience, graphic design, game design, digital storytelling, and more. This course is NOT appropriate for students with programming experience; for example, students who have taken CSE 231 or similar courses in the past. This is a required course for multiple majors and minors in media and information, but the requirement can be waived in many cases for students who have taken other programming courses or have demonstrated experience. ",
    "url": "/syllabus.html#course-description",
    "relUrl": "/syllabus.html#course-description"
  },"202": {
    "doc": "Syllabus",
    "title": "Required Technology",
    "content": "All students are REQUIRED to bring a laptop computer to class running either MacOS or Windows. Linux is not supported in this class. Every student will be creating a development environment on their own computer in the first 2 weeks of class. Every student will be required to practice writing and running code on their own computers. If you need a new computer, the MSU Tech Store sells both Apple and Windows laptops at discounted prices for students. If your laptop breaks or is temporarily unavailable during the semester, talk with Caitlin about accommodations. MSU also has a Laptop Loan program which students who have a temporary need for a laptop can apply for. All course materials can be found on: . | The course website (this website, https://mi250.dev) | D2L (d2l.msu.edu) | Gitlab (gitlab.msu.edu) | . You will not be required to purchase any software for this course. The course will be using the Python programming language, Git, and related tools, all of which are open source and/or freely available. You do not need to install anything ahead of time – we will be doing all of that work in class. In-class technology usage . Students are expected to use their laptops in class for in-class work, and should bring their laptops to every class. Smartphone and tablet usage is fine so long as they are being used for class purposes (like taking notes, looking things up, etc). Phone calls in class are prohibited. If you need to make or receive a phone call, step outside of the classroom first. Talking on your phone in class is disrespectful to the instructors and to your classmates and will result in a lower grade for the day. ",
    "url": "/syllabus.html#required-technology",
    "relUrl": "/syllabus.html#required-technology"
  },"203": {
    "doc": "Syllabus",
    "title": "Course Structure",
    "content": "This course has 4 main elements: . | Homework: reading / watching content and summarizing / asking questions about content in ways that relate to students’ own lives (every week, due before the first class of the week). | Labs: set exercises for learning and practicing concepts in programming, done in class with partners (usually on Tuesdays) | Studios: open-ended creative exercises for practicing and applying programming concepts, done in class in groups of 2-4 (usually on Thursdays) | Final project: a two week project at the end of the semester started in class and due during the class’s final exam period (12pm, Thursday Dec. 14). | . This course does NOT have any quizzes or exams. Aside from the final project, which students have the option of working on outside of class, all programming work will be done IN CLASS. It’s therefore very important to attend class as much as possible. Pair Programming . Students in this course will practice a concept called pair programming, which originated with programmers at tech companies. Pair programming is based on the idea of “two programmers, one computer:” two programmers work together on the same code using one computer between them. One person is the driver: they are the person using the computer and typing the code. The other person is the observer, also known as the navigator: they do the bigger picture thinking, look up relevant information, and help spot mistakes. In this class, students will switch roles on a regular basis. Students who participate in pair programming get stuck and frustrated less often than students working by themselves and are also able to practice teamwork and communication – which is why we practice it in this class! . In labs: students will be randomly assigned in pairs at the beginning of class. You’ll likely work with someone different every week. You will practice pair programming for every lab. In studios: students can choose who they work with and can work in groups no smaller than 2 people and no larger than 4. We encourage you to practice pair programming in whatever way makes sense for your group rather than all working on your own computers. You should be talking with your group members frequently. ",
    "url": "/syllabus.html#course-structure",
    "relUrl": "/syllabus.html#course-structure"
  },"204": {
    "doc": "Syllabus",
    "title": "Coursework",
    "content": "Homework . Every week students will be asked to read or watch a few articles and videos about programming and to submit a “Summary + Question” on D2L which is due before the first class of that week (usually Tuesday). These are under Quizzes on D2L and are labeled by week and are graded based on the check/check-plus/check-minus rubric. Homework should take you between 30 minutes and 1 hour each week. All readings and videos are available for free and are linked on the readings page for each week (found in the Topics/Readings column on the course schedule). You will not be required to purchase any textbooks or other materials to complete the homework. Summary: one paragraph max (at least 3 sentences). These will always be guided summaries rather than just repeating facts. There will be a prompt on the readings page for each week which will usually ask you to explain what you’ve learned in your own words and to apply it to your own experiences. If your summary is too short or too long, or doesn’t answer the prompt, you may be marked down for it. Question: one question relating to that week’s topic. The question can be about one of these things: . | Confusion: something you didn’t understand and want clarification on | Curiosity: something you want to learn more about | Connection: apply one of the concepts from the week’s topic to your own life or work (this might be a statement rather than a question; that’s okay) | . If your summary + question is missing either a summary or a question, OR if it’s turned in late (after class starts), you will get a 0. We use your summaries and questions to understand what students are having trouble with so we can talk about it at the beginning of class on Tuesdays, so it’s important to turn them in on time. Labs . Labs will usually be on Tuesdays. Labs cover one or more specific concepts relating to the topic of the week; their goal is to give you a chance to put the concepts in practice. Programming is very hard to learn through reading alone, which is why we practice it in class with partners. Each lab has a series of small, structured exercises that you and your partner will go through together using pair programming. Partners for labs are assigned randomly at the beginning of class. Labs are graded using the check/check-plus/check-minus system. Grades are based on: . | Effort (did you work on the lab for the entire class?) | Attendance (did you attend the whole class OR did you complete all of the exercises satisfactorily?) | Teamwork (did you help others?) | . Labs are NOT graded based on how much you complete or how “good” your code is. Studios . Studios will usually take place on Thursdays. Unlike labs, studios are more open-ended exercises that allow you to practice – and be creative with – the concepts you learned in the lab that week and over the course of the semester. Studios are done in groups of 2-4 people; you can choose who you work with for studios. Studios are also graded using the check/check-plus/check-minus system. Grades are based on: . | Effort (did you work on the studio for the entire class?) | Attendance (did you attend the whole class?) | Teamwork (did you collaborate consistently with your group?) | . Studios are NOT graded on how “good” your code is or whether everything works as intended at the end of class. Final project . The final project is a long-form studio done with a group starting the last week of the semester. Unlike a normal studio, students will be expected to work on the same project over multiple class periods (the full last week of class will be devoted to this project) and also outside of class if the project can’t be completed during class. Final projects are due at the end of the final exam period: 12pm (noon) Thursday, December 14, 2023. There is no final exam for this class. Turning in work . In-class work will be turned in via a combination of D2L and Gitlab. You will turn in homework individually on D2L. Work from in class activities will be turned in by at least one person in each partnership/group through D2L (screenshots and other evidence of work) and Gitlab (code) at the end of each class. Extra credit . There will be two extra credit opportunities this semester – a take-home assignment on November 3rd (election day) and an in-class activity on November 21st (the week of Thanksgiving). Honors option . This course does have an honors option for students in the honors college. If you want to do an honors option, talk with Caitlin within the first two weeks of class. ",
    "url": "/syllabus.html#coursework",
    "relUrl": "/syllabus.html#coursework"
  },"205": {
    "doc": "Syllabus",
    "title": "Coursework Expectations and Grading",
    "content": "Grades in this class are mostly based on attending class and making an honest effort to engage with the material, both in and outside of class. The final project is the only work in which students will be graded on the programming skills they’ve developed over the semester. Grades are broken down in this way: . | Homework (summary + question) | 20% | . | In class exercises (labs and studios) | 60% | . | Final project | 20% | . Grades will be input on D2L and are calculated continuously – you will always know where your grade stands for the class by looking at D2L. Most all grades (except for the final project) are based on a check / check plus / check minus rubric: . | Check = 9/10. You showed up and did the work. This is the base grade for everybody. (You didn’t do anything wrong if you get a check!) | Check plus = 10/10. You showed up, did the work, and impressed us: maybe you worked particularly well with your partner that day, or had a particularly insightful question. | Check minus = 7/10. You showed up, but didn’t honestly engage with the work. Maybe you were late to class with no excuse, or maybe you spent half the class cruising Insta or not talking with your partner or group at all. | . Final projects will be graded in two parts: . | Normal studio requirements – graded based on effort, attendance, and participation during the two class periods in the final week of class | The content of the project – graded based on whether the program works as intended, and on a combination of demonstrating programming skills and creativity. | . A rubric for the final project will be released at the beginning of the final week of class. Grading scale . | 90% | 4.0 | . | 85% | 3.5 | . | 80% | 3.0 | . | 75% | 2.5 | . | 70% | 2.0 | . | 65% | 1.5 | . | 60% | 1.0 | . | Below 60% | 0.0 | . ",
    "url": "/syllabus.html#coursework-expectations-and-grading",
    "relUrl": "/syllabus.html#coursework-expectations-and-grading"
  },"206": {
    "doc": "Syllabus",
    "title": "Communication Policies",
    "content": "Caitlin and Jack are happy to respond to student questions after class, or via email. Caitlin also holds office hours on a weekly basis, both in person and on Zoom: book a time. Jack can also meet with students outside of class as needed - email him or ask him in class. If you have questions about anything course-related, please get in touch! . Email policy: we will respond to email within 24 hours on weekdays, or within 72 hours on weekends. Don’t expect us to see any email sent before or during class until after class has ended. Announcements . Announcements about the course will be posted on D2L. Make sure you have allowed D2L to send announcements to your MSU email. You can also have D2L emails forwarded to different email accounts - see instructions to do this in the MSU D2L documentation. ",
    "url": "/syllabus.html#communication-policies",
    "relUrl": "/syllabus.html#communication-policies"
  },"207": {
    "doc": "Syllabus",
    "title": "Attendance / Absence Policy",
    "content": "This class is very heavily based on attendance and participation – it’s very important that you attend class every week as each week’s content builds on the previous week. If you miss too many classes, you WILL fall behind. It’s also very important to attend the ENTIRE class – arriving late or leaving early means you will have less time to practice coding, and it will make class more difficult for your partner / groupmates for the day. Your grade for the class will be reduced if you are late or leave early. That said, life happens. The 4 lowest grades for in class activities (labs and studios) will be dropped, as will the 2 lowest grades for homework. You can miss up to two weeks of class total without it affecting your grade at all. You do not have to explain why you’re missing class to us. This policy covers the vast majority of absences you might need to take. Illness . If you are sick with something contagious (like COVID or the flu), PLEASE PLEASE PLEASE be considerate of your instructors and classmates and STAY HOME! Remember you can miss up to 4 classes with no penalty and no excuse needed. For long-lasting illnesses, see “exceptions” below. If you have or think you might have COVID and aren’t sure what to do, see MSU’s COVID guidance page. If the instructor is sick, class may be cancelled. Exceptions . The “drop 4” policy for in class activities will cover nearly all absences for nearly all students. It is meant to be flexible. If you find yourself needing to miss more classes than that, we will try to work with you to help you keep up with the class. IF you are beyond 4 absences already AND any of the below circumstances apply, we may be able to exempt you from certain classes or homework. Talk to Caitlin first and foremost! . Note that missing more than two weeks of class will make it harder for you to keep up, and also harder for you to earn good grades because you won’t be able to participate as much in class. If you need to miss extra class, talk with Caitlin or Jack and we will help you determine what you might need to do to keep up with the class. All of the exceptions below will be taken into account if you go beyond 4 absences. Adding the class late – if you added this class to your schedule at the end of the first week of the semester, you may have missed the first graded homework and the first graded in class activity. Talk to Caitlin as soon as possible to catch up on the work, and to be exempted from those activities. Illness lasting more than 2 weeks – COVID is still a thing, and there are all sorts of other illnesses people can have that affect their ability to attend class. Contact Caitlin as soon as possible to discuss potential accommodations and what kind of documentation may be necessary. Grief absences – If you have experienced the death of a family member or someone close to you, or you are experiencing emotional distress from a similar tragedy, you may request a grief absence. To request a grief absence, visit the Grief Absence Request Form found on the Student Information System under Resources –&gt; Grief Absence. See the grief absence policy for more information. Once your grief absence is approved, we will exempt you from the in-class activities for the approved dates. This means those classes won’t count towards your grade at all, and also won’t count as part of your 4 dropped grades. Religious holidays – If you wish to be absent from class to observe a religious holiday, please make arrangements in advance. Student athletes – If you must miss a class to participate in an officially-sanctioned athletic game, you must provide adequate advanced notice beforehand, such as a team schedule or written authorization from the faculty member of the other course or a university administrator. Required activity – If you must miss a class to participate in a university-sanctioned event, you must provide the instructor with adequate advance notice and written authorization from a university administrator. ",
    "url": "/syllabus.html#attendance--absence-policy",
    "relUrl": "/syllabus.html#attendance--absence-policy"
  },"208": {
    "doc": "Syllabus",
    "title": "Other Policies",
    "content": "Accommodations for disabilities . Michigan State University is committed to providing equal opportunity for participation in all programs, services and activities. Requests for accommodations by persons with disabilities may be made by contacting the Resource Center for Persons with Disabilities at 517-884-RCPD or on the web at rcpd.msu.edu. Once your eligibility for an accommodation has been determined, you will be issued a verified individual services accommodation (“VISA”) form. Please present this form to Caitlin in the first two weeks of the semester and/or two weeks prior to the accommodation date (test, project, etc). Requests received after this date will be honored whenever possible. Spartan Code of Honor . As a student at MSU, you will be expected to abide by the Spartan Code of Honor Academic Pledge: . “As a Spartan, I will strive to uphold values of the highest ethical standard. I will practice honesty in my work, foster honesty in my peers, and take pride in knowing that honor in ownership is worth more than grades. I will carry these values beyond my time as a student at Michigan State University, continuing the endeavor to build personal integrity in all that I do.” . See the Spartan handbook for more details. Academic honesty . Michigan State University and the Department of Media and Information both have policies about academic dishonesty. Basically, make sure that everything you turn in with your name on it is your own work, and don’t cheat or lie. If it feels like cheating, it probably is; if you are unsure please ask. Students caught cheating or plagiarizing will receive a 0 for the assignment and be reported to the university. Working together with other students in this class and other classes, however, is encouraged. Make sure that everything you turn in with your name on it is original work of yours. For classes that involve complex thinking and no right answers like this, we strongly encourage you to work together and ask each other for help. Indeed, this course requires you to work with others. Often when you have a problem or something confuses you, the best place to go for help is your colleagues who are also working on similar things. The Internet is also a fantastic source of information when you are stuck. Use these resources! However, make sure that you personally write and understand all of the work that you turn in. Directly copying text that you don’t understand from the Internet or from others is academically dishonest. Mental health . Mental health concerns or stressful events may lead to diminished academic performance or reduce a student’s ability to participate in daily activities. If you’re struggling, we encourage you to seek support. Services are available to assist you with addressing these and other concerns you may be experiencing. You can learn more about the broad range of confidential mental health services available on campus on the Counseling &amp; Psychiatric Services (CAPS) website. Technical assistance . Asking your peers in class and your instructor is a great source for technical assistance. This is particularly true with the technologies we are learning in class (python, git, etc.). For MSU-provided technologies, you can visit the MSU Help site, the Desire2Learn Help Site or email the MSU IT Service Desk. Tolerance and civility . MSU strives to build an academic community with living and learning environments that expects tolerance of viewpoints and civility toward others, whether at public forums, athletic events, in residential communities, classrooms or laboratories. We call upon all who participate in university events to promote tolerance and civil behavior and to hold themselves to high standards that reflect the university’s commitment to respect viewpoints that may be different from their own. Only by respecting individuals with diverse perspectives and ideas can we build an environment of civility that is conducive to advancing knowledge and transforming lives. ",
    "url": "/syllabus.html#other-policies",
    "relUrl": "/syllabus.html#other-policies"
  },"209": {
    "doc": "Syllabus",
    "title": "Syllabus",
    "content": " ",
    "url": "/syllabus.html",
    "relUrl": "/syllabus.html"
  },"210": {
    "doc": "Software Testing",
    "title": "Software Testing",
    "content": " ",
    "url": "/testing.html",
    "relUrl": "/testing.html"
  },"211": {
    "doc": "Software Testing",
    "title": "Exercise: What is a bug?",
    "content": "Software testing is the process of finding and eliminating bugs in software. Take a minute and write down your answer to the question “What is a bug?”. Go ahead; I’ll wait. Computer programs are written with goals in mind; the program is supposed to do something specific. A bug is anytime that the program doesn’t do that. That is, a bug is anytime there is a difference between what the program is supposed to do and what the program actually does. As computer programs get more complicated, so do the bugs. A simple computer program often only does one thing. If it does that then, then great; it works. When you make computer programs more complicated, they have to work in a wider variety of different settings. Different people might enter in different inputs. The program has to work with different types of data. The program has to work on different computers (Mac vs. Windows) with different size screens and other differences. Bugs may appear only in some circumstances but not others – it may work fine for you on your computer, but not for me on my computer. But still, that’s a big problem for me! (AND, also, a problem for you if you want me to pay you for the computer program….) . Fixing Bugs . When people write programs, they often think that they should try to write programs that don’t have bugs. But, that’s impossible! They also think that programs aren’t done until they are bug-free. That’s also impossible! Microsoft Windows shipped with millions of known bugs that were not fixed. People still bought it and use it on a regular basis. Fixing every bug is hard, and often not worth the time and effort. If a bug is any time what the program actually does is different than what the program is supposed to do, then there are two ways to fix a bug: . | Change what the program actually does. Modify the code so that the program does what it is supposed to do. | Change what the program is supposed to do. Change your idea of what the program is supposed to do and what kinds of things it can and can’t do. (and, if applicable, change the written specification) | . Both are entirely reasonable ways to fix a bug. Also, it is reasonable to choose to not fix a bug; just acknowledge that it exists but that it isn’t worth fixing. ",
    "url": "/testing.html#exercise-what-is-a-bug",
    "relUrl": "/testing.html#exercise-what-is-a-bug"
  },"212": {
    "doc": "Software Testing",
    "title": "Why Test?",
    "content": "Computer programs do not always work as the programmer intends them to. Often, I write code that I think does one thing, and then when I run it, I find out that it does something else. This is a very normal thing to happen, and every programmer experiences it on a daily basis. Testing is really an attempt to understand what your program actually does. Testing is a way to better understand the program that you’ve written and what it can and cannot do. Testing is the process of trying to find bugs. Testing does not necessarily involve fixing bugs. Instead, you test your program to try to learn about the bugs that exist. This gives you the information you need to decide whether it is worth fixing the bugs or not. Automated vs. Manual testing . There are two major ways of doing testing: manually testing the program by running it and entering inputs on your own, and automated testing by writing a 2nd program that tests your 1st one. You are already familiar with manual testing. You do it all the time. You write code, and then you run the code and see what happens. You have some idea in your head about what the program should do, and then you run the program and see what the program actually does. Often, this isn’t a very structured or formalized process, but you still do it all the time. You run your program over and over, adding code and trying different inputs, to see what happens. This is manual testing. It is possible, and not uncommon, to do more structured manual testing. Rather than just ad-hoc running your program, you could think carefully about what kinds of inputs your program might get, and then write down a list of possible inputs. Then you could think about, for each input, what should the program do? Write that down next to the input. Rather than having some vague notion about what the program should do, you now have explicitly written down the expected output. Now you can run the program multiple times, and see if what the program does matches what you wrote down that it should do. This structured, manual testing is quite common in the real world. Large companies pay people to run these structured manual tests and figure out if the program does what it is supposed to do. Some things, like user interfaces, are difficult to test automatically, and mostly are tested this way. However, running through these tests manually is hard and boring work – especially if you have to do it frequently. So, programmers often do what they are good at – they write a computer program to automatically run tests and check if the program does what it is supposed to do. Automated testing invovles using one computer program to test another, and is an extremely common way to do testing. As programs get bigger and bigger, automated testing becomes more important. Regression bugs: bugs that appear later, breaking previously working code. As you work on writing computer programs, one thing that you notice is that you change things in one place, and it affects other parts of the program. That is, it is possible (and common) that one part of the program works fine NOW, but later on you change something else and now that part no longer works. When this happens, it is called a “regression bug”. Regression bugs are really nasty, because they mean that you tested the program and it worked, but then later on it stopped working. The only way to catch regression bugs is to re-run all of your tests again, to make sure that the program still does everything it is supposed to. But doing that is a real pain. That’s one of the big reasons that we automate tests; it is much easier to re-run tests if they are automated and can be run with a single keystroke. ",
    "url": "/testing.html#why-test",
    "relUrl": "/testing.html#why-test"
  },"213": {
    "doc": "Software Testing",
    "title": "Test Cases and Automating Tests",
    "content": "In order to think about how to test software, we break our program down into test cases. Each case tests one specific feature or function of a program, and a single input to that part of the program. To test a program you’ve written, you will normally have many different test cases that test different parts of the program with different inputs. Basically, test cases break the job of software testing into discrete, managable parts. What is a test case? . A test case is a well-specified set of inputs and expected outputs. Above, I talked about how you could write down an input to your program, and then also specify what the output should be. That is a single test case. The trick with test cases is to be very specific. You are testing a very specific, logical piece of functionality of your code with a well-defined input and well-defined expected output. If your test case is specific enough, then it should be easy for anyone to tell whether the actual output matches the expected output; that is, you can tell whether the test case “passes” or “fails”. Automated test cases: Easy to run over and over . When we are writing automated tests, we usually break our tests into test cases. One function executes exactly one test case, and then decides whether that test passes or fails. For example, let’s pretend we have a really simple function called add() that takes two numbers and adds them together. If I add 1 and 2 together, I would expect to get 3, right? We can make that into a test case – if I call add(1,2), then I would expect the result to be 3. To do testing, we use the assert command in Python. Assert means to test and see if the result is what is expected. So, a really simple automated test case for the add() function would be: . def test_add(): result = add(1,2) assert result == 3 . In this case, the code is a test because the function name starts with test_. It runs the add() function with 1 and 2 as parameters, and then stores the actual result that is calculated in a variable called result. Then it checks (asserts) that this result is equal to 3 – the expected output. If it is equal, then we say that the test case “passes”, and the result is what we expect. If it is not equal, then we say that the test “fails” because it is not what we expected. This is a single test case. If I wanted to test a different set of inputs, that would be a separate test case. So if I also wanted to check that adding 0 and 0 results in 0, here is a second test case: . def test_add_zero(): result = add(0,0) assert result == 0 . Testing harness: runs a collection of test cases and produce output reports . Now we have more than one automated test case. What if we want to run all of these tests, and collect the results into a single output that is easy to read? That is the job of a test harness: a program that runs automated tests for us and reports on their results. In python, a common test harness that is built in is called UnitTest. There are other ones that are commonly used also, such as pytest or nose. ",
    "url": "/testing.html#test-cases-and-automating-tests",
    "relUrl": "/testing.html#test-cases-and-automating-tests"
  },"214": {
    "doc": "Software Testing",
    "title": "Types of Tests",
    "content": "Most software has a large number of tests associated with it. It is not uncommon for the test code to be more lines of code than the code that is being tested. Now, the next question is what kinds of test cases should we create? How do we think about what to test? . What follows is one way to think about what to test. It is not the best way, and it is certainly not the only way. But it is a useful way to organize your thinking. To help illustrate, I will be writing tests for a function that generate Fibonacci numbers – a sequence of numbers that goes 1, 1, 2, 3, 5, 8, 13, 21, 34… Each number in the sequence is the sum of the two previous numbers. The function takes as a parameter which number in the sequence it should generate (the 1st number, or 3rd number, or what), and it returns that number. Here is an implementation of that function: . def fib(n): if n &lt;= 2: return 1 return (fib(n-1) + fib(n-2)) . For the first two numbers (n=1 and n=2), it returns a hard coded 1. For each number after that, it calculates the two previous numbers and adds them together. This is just an example function. We could write tests for almost any function we create. Level 0: Basic Functionality . The first types of test cases that I write are called “Level 0” tests. These test the most basic functionality; if these fail then the function is hopelessly broken and needs to be fixed. Level 0 tests should test the one or two most common use cases of a function to make sure that it works correctly with completely normal input. For the Fibonacci function, a very normal use is to ask it for the 3rd or 4th number. Let’s pick one – the 4th number. Looking at the Wikipedia page for Fibonacci nunbers, it looks like 4th number is 3. So we would expect fib(4) to result in 3. We can write this as a test case: . ### Level 0 tests def test_fib_3(): assert fib(4) == 3 . Usually we don’t have many level 0 tests. We write level 0 tests just to check and make sure that the most basic funcationality works. If there is a syntax error, or if fib() does something unrelated to Fibonacci numbers, or if I forgot to write the code for fib(), then this test will catch that. All it does it make sure that the most normal, basic way of using the function works. Level 1: Full Range of Functionality and Edge Cases . Once the Level 0 tests are passing, we know that the basic function works. The next thing I do is write Level 1 tests. These tests look at the full range of functionality to try to identify what are the edge cases and different types of inputs that the function should handle. We should use our knowledge of the function to try to identify tricky cases, and test those to make sure they work. However, all of the Level 1 test cases should be valid cases, in that they ask the function to do things that it normally would be expected to do. For the fib() function, what are some tricky cases that it needs to handle? Well, the first two Fibonacci numbers are always tricky, because they are different than the others. The first number should be 1, and the second number should also be 1. Let’s write a couple of tests for those: . # Level 1 tests def test_fib_1: assert fib(1) == 1 def test_fib_2: assert fib(2) == 1 . Are there any other trick cases? Let’s pick a higher nunber, and make sure that it does calculations accurately. Looking at the Wikipedia page for Fibonacci numbers, the 10th number is 55. So let’s check that to make sure it calculates larger and more complicated numbers correctly: . def test_fib_10(): assert fib(10) == 55 . Ideally, you want to keep writing Level 1 tests until you’ve tests the full range of valid inputs – long inputs, short inputs, big numbers, small numbers, blanks, etc. Everything that is valid, you should write a test for to make sure that it works. Level 2: Error conditions . Almost all programs have invalid inputs – inputs that are considered to not be legitimate. However, sometimes the user ends up providing an invalid input. Good programs detect that the input is invalid, and handle it appropriately (for example, by displaying an error message). Level 2 tests test these invalid inputs. They intentionally provide invalid inputs to the program, and then check to make sure that the program does something reasonable with that input. For example, the fib() function only really produces sensible outputs for positve, whole numbers. If you enter a negative number, or if you give it a fraction, it doesn’t know what to do. What should it do? Often, when writing test cases, you realize that you don’t know what a program should do. If a bug is when what the program actually does is different than what the program should do, then it is a problem if you don’t know what the program should do! . This is surprisingly common, to not know what the program should do. This is another benefit of testing – it forces us to think through all of the things that can happen, and try to figure out what we want to the program to do in each of these situations. For the Fibonacci function, what do we want the program to do if it gets an invalid input? Let’s say that is should throw an IndexError any time it gets an invalid input. Now that we know what it should do, we can write some tests for some invalid inputs. We can use pytest.raises() to check and make sure that that error is raised. The test fails if it does NOT raise that error, and it passes if it does create that error: . # Level 2 tests def test_fib_negative(): with pytest.raises(IndexError): fib(-1) def test_fib_fraction(): with pytest.raises(IndexError): fib(2.5) def test_fib_string(): with pytest.raises(IndexError): fib(\"hi\") . If you run these tests with our fib() code above, you’ll see that these Level 2 tests fail! Uh oh! We have found some bugs in our code – it doesn’t handle error conditions very well. First, we need to decide if we care – is this a bug that is worth our time fixing? If it is, then we need to change our fib() code to make it do the right thing. Level 3: Performance and Scalability . Once all of the tests for Levels 0, 1 and 2 are passing, then the program mostly works correctly – it does what it is supposed to do. However, that’s not quite enough. There are usually other goals that programs have – for example, running fast enough that the user doesn’t get bored. Level 3 tests test these other, non-correctness features of programs. For example, it is a problem if it takes minutes to calculate our Fibonacci number. That’s not good. The computer should be able to calculate it in less than 10 seconds. So let’s write a test to check this: . # Level 3 tests def test_fib_speed(): start = datetime.datetime.now() out = fib(40) end = datetime.datetime.now() assert (end-start).total_seconds() &lt; 10 # It should take less than 10 seconds to compute . Example . You can download these examples here. This file contains the basic fib() function, and all of the tests listed above. To run it, use the command: . pytest fib.py . OR, alternatively, you can run it with . python3 -m pytest fib.py . When you run it, you should see that four of the test fail! Our fib() function only passes half of the tests. As an exercise, can you fix it so that all the tests pass? (Solution) . ",
    "url": "/testing.html#types-of-tests",
    "relUrl": "/testing.html#types-of-tests"
  },"215": {
    "doc": "Software Testing",
    "title": "Testing an Application",
    "content": "When testing a whole program or large application, there are some additional considerations. Specifically, it is really valuable to distinguish between unit tests and integration tests. Unit tests . Most programs are split up into smaller, logical units of functionality. A unit test tests a single, small unit of functionality. Often, we do this with functions; a unit test can test that a function works correctly. All of the tests we wrote above for the fib() function are unit tests – they test a small unit of functionality that is (most likely) part of a larger program. Unit tests are very common, and the majority of automated tests that are written are unit tests. Unit tests are great for catching regression bugs and for helping us to think through program and make sure that we cover everything it is supposed to be able to do. Integration tests . However, it is possible that all of the individual pieces work correctly on their own, but that they don’t fit together properly. That is where integration tests come in. Integration tests look at the program as a whole, and make sure that the pieces all fit together properly in a way that works. The most common way to create an integration test is a user script – write a script of what the user would do when using the application as a whole, and then annotate the script with what is expected to happen at each stage. User scripts can capture the overall functionality of a program in a way that unit tests don’t. Integration tests can be automated, and many good integration tests are. But often, we also do integration tests as manual tests, running through the application and making sure that it works as a whole. Exercise . Choose an application you wrote recently. Write an integration test case – a script for a user going through a process, and the detailed output expected. ",
    "url": "/testing.html#testing-an-application",
    "relUrl": "/testing.html#testing-an-application"
  },"216": {
    "doc": "Studio",
    "title": "Studio",
    "content": "Thanksgiving break at MSU in 2023 is November 23-24 (Thursday and Friday). Enjoy your break! . ",
    "url": "/studios/thanksgiving.html",
    "relUrl": "/studios/thanksgiving.html"
  },"217": {
    "doc": "Studio",
    "title": "Advice",
    "content": "Work as a team . There are lots of parts of tic-tac-toe. There’s the user input side – asking for where to move next. There is the drawing side. There is the figuring out of someone has won. Spread out the work across the team. Have different people do different parts. Use functions to capture the different parts of the program. Use git to share code. This project is much easier if you break it into parts, and then do the parts separately, and then put them together. Make sure to leave time to put them together; its not as easy as it sounds. Think about program structure . Think about how you want to structure your program. At a high level, what are the logical things that the program needs to do? How do they fit together in the program? What information needs to be send from one logical thing to the next? As you get started, draw a diagram that describes what those pieces are, and what information need to move from one to the next. Break the program into pieces (functions) . This type of program is MUCH easier if you can write some functions to do it. It really helps if you can think ahead-of-time about what functions you will want in your program. This is called “organizing” your program. Once you figure out the logical structure of your program, then use that to break the program into functions. If you try to write one big program that does this whole game, you will find it is really difficult. Each time you find yourself thinking you need the program to do something, write a function for that something. Need it to draw a symbol? Write a function for that. Need it to move the turtle to a new place? Write a function for that. It is pretty much impossible to have too many functions. For example, you could write a draw_board() function that draws the intiial board. You could write a draw_x function and a draw_o function that draws either an X or an O at the correct place. And you could write a function to get user input of a location and draw the appropriate symbol on the board. Use code you’ve written before . You’ve done a lot of programming already in this class. Use that! If you’ve already written code to draw a smiley face for a previous lab or studio, then go find that code and modify it. If you’ve already written code to ask for user input, go look it up and use it. There is no reason to write things from scratch when you’ve already written a lot of code. Test each function as you go . It is MUCH easier to figure out if a single function works than if the whole program works. As you write each function, write some throwaway code to see if it works. WHen you write the draw board function, run it and see if the board looks right. When you write a function to draw an X on the board, run it to see if it works. Run it to draw X’s in different places. Challenge: New Symbols . This is the easier challenge. X’s and Os are very boring. Instead of using X’s and O’s, draw different symbols. Maybe do a game of pizza-and-sandwiches? Or a game of smileys and frowns? Be creative (and/or use your emojis from Week 7’s studio. In addition to different symbols, can you change the board up to make it more interesting? Create a theme for the board? Use colors? . Challenge 2: When is the game done? . Your goal for this studio is just to allow users to play tic-tac-toe. Your program doesn’t need to detect when someone has won the game (3 X’s or O’s in a row) or when the game has ended in a stalemate. This is actually not easy to do. As a challenge, if you finish your Tic-Tac-Toe game early, try to figure out how you can tell if someone has won the game. To do this, you’ll have to figure out how to store moves in a variable (like a list or a dictionary), and then you’ll have to figure out how to look through that variable to see if there are 3 in a row. Detecting a stalemate (tie) is easy – if there have been 9 valid moves, but no one has won yet, then the game is a stalemate. Don’t work on this until you get the main tic-tac-toe program working successfully. ",
    "url": "/studios/tic_tac_toe.html#advice",
    "relUrl": "/studios/tic_tac_toe.html#advice"
  },"218": {
    "doc": "Studio",
    "title": "Studio",
    "content": "For the studio today, you are going to make a game of Tic Tac Toe. You should draw an initial board (two vertical lines and two horizontal lines). Then ask the user where they want to move. Draw either an X or an O in the place they say. Let the user(s) continue until the whole board is full, or until the user decides someone has won. That’s it. That’s the whole of the instructions – form a group, write a tic-tac-toe program. Have fun with it. What follows is just advice for doing it. You don’t have to follow my advice. Do whatever you want. This is just my experience in doing this, and you might want to do it differently. ",
    "url": "/studios/tic_tac_toe.html",
    "relUrl": "/studios/tic_tac_toe.html"
  },"219": {
    "doc": "Turning in work",
    "title": "Homework",
    "content": "Every week, you will have a small amount of homework. Homework consists of: . | completing readings (articles and/or videos) | responding to what you’ve read / watched | . Readings for each week are located on the schedule in the ‘readings’ column. They shouldn’t take more than 30 minutes to go through each week. Responses take the form of a summary+question, to be turned in each week under ‘Quizzes’ on D2L. They have two parts: . | Summary: follow the prompt on the readings page for that week to summarize what you’ve read | Question: ask a question about what you’ve read See the syllabus[link] for more details. | . Make sure to turn this in before the first class of each week. ",
    "url": "/reference/turning_in_work.html#homework",
    "relUrl": "/reference/turning_in_work.html#homework"
  },"220": {
    "doc": "Turning in work",
    "title": "Code and screenshots for labs",
    "content": "Every week, usually on Tuesdays, we’ll have a lab. Labs are done in pairs. At least one person in each pair will need to turn in: . | code | screenshots showing code working | . Screenshots are turned in on D2L under ‘assignments’ - the assignment will be marked as a lab with the appropriate week (like “Week 1 Lab”). Rule of thumb: every time you complete an exercise, take a screenshot of the code you wrote working. In the first two weeks, everyone (including code files) will be turned in on D2L. Starting in week 3, code is turned in on Gitlab. Both partners should be members of the Gitlab repository for the lab. Using Gitlab for labs . Each lab has an associated Gitlab repository. Starting in the 3rd week of class, you’ll be using Git to clone (make a copy of) the repository on your own computer, which you can then use to send changes back up to the repository in Gitlab. For every lab, follow these steps before you start working: . | one person will fork the lab, which creates new version in Gitlab under their username | the person who forked the lab should add their partner and also Caitlin (geierac) and Jack (waierjac) as administrators to the newly forked repository | the person who will be driving first clones the repository onto their own computer using git | . When trading places between driver and navigator: . | the driver should push all of the code they changed to the Gitlab repo before the navigator becomes the driver | the new driver (who used to be the navigator) either clones the repository onto their computer OR uses git pull to bring all of their partner’s changes down onto their own computer. Only use git pull if there’s already a cloned repository on your computer | . ",
    "url": "/reference/turning_in_work.html#code-and-screenshots-for-labs",
    "relUrl": "/reference/turning_in_work.html#code-and-screenshots-for-labs"
  },"221": {
    "doc": "Turning in work",
    "title": "Code and screenshots for studios",
    "content": "Most weeks on Thursdays, we’ll have a studio. Studios are done in groups of 2-4. At least one person in the group will need to turn in: . | code | screenshot(s) showing code working | . Screenshots are turned in on D2L under ‘assignments’ - the assignment will be marked as a studio with the appropriate week (like “Week 3 Studio”). The best time to take screenshots is at the end of the studio when everything is working. If you’re not sure you’ll be able to get something working, take screenshots as you go. Using Gitlab for studios . For every studio, follow these steps before you start working: . | one person in the group will create a new repository in Gitlab, named the same as a the studio | the person who created the repository should add everyone in their group and also Caitlin (geierac) and Jack (waierjac) as administrators to the newly forked repository | . ",
    "url": "/reference/turning_in_work.html#code-and-screenshots-for-studios",
    "relUrl": "/reference/turning_in_work.html#code-and-screenshots-for-studios"
  },"222": {
    "doc": "Turning in work",
    "title": "Avoiding Git conflicts",
    "content": "If multiple people are making changes to a repository at the same time, sometimes there can be conflicts. This especially happens in studios, where different people might be working on different aspects of the studio at the same time. A few tips for avoiding conflicts: . | Always use git pull before you start working on a file to make sure you have the most updated version. | When you’re done working on a file, always add, commit, and push your code to Gitlab. | For studios, talk at the beginning of class about how you might split up the work. If it makes sense to have multiple people writing code at the same time, try each using different files to work on small pieces and combining your code into one file later. Keep talking with everyone in your group so that everyone knows what the others are working on and in what files. | . Don’t worry if you run into a conflict; Caitlin and Jack are always around to help you resolve them! . ",
    "url": "/reference/turning_in_work.html#avoiding-git-conflicts",
    "relUrl": "/reference/turning_in_work.html#avoiding-git-conflicts"
  },"223": {
    "doc": "Turning in work",
    "title": "Turning in work",
    "content": "This course uses D2L and Gitlab for turning in work. Almost every week, students will be responsible for three turn-ins: . | Homework (individual) | Code and screenshots for labs (partners) | Code and screenshots for studios (group) | . ",
    "url": "/reference/turning_in_work.html",
    "relUrl": "/reference/turning_in_work.html"
  },"224": {
    "doc": "Lab",
    "title": "Draw some things",
    "content": "When I refer to “the turtle” in these exercises, I mean the arrow in the turtle drawing window. Think of it as a small turtle that crawls around on the screen, leaving a trail behind it. Exercise 1: Finish the square . In the Git repository, you should see a program called square,py. This program is supposed to draw a square on the screen that looks like this: . However, the program isn’t finished! Run the program with python square.py (or python3 square.py on Mac) and see what happens. Edit the program to finish drawing the square. Remember that the right() and left() commands turn the turtle in degrees – 360 degrees turns the turtle all the way around so it is facing the same way it started. 90 degrees is a quarter of the way around (a right angle). 180 degrees turns the turtle around to face the opposite direction is started. Exercise 2: Finish the stick figure . In the git repository you should see a program called person.py. This program begins to draw a stick figure using turtle. Run the program to see what it does. It should start to draw a stick figure, and then wait for you to close the window. Python will keep running the program (even if it’s not doing anything) until you close the Turtle drawing window. Write the code to finish drawing the stick figure. The person.py file contains some comments (text with # in front of it) for what you’ll need to write to finish it. Don’t try to do this all at once. Start by drawing on a piece of paper without lifting up your pen: what do you need to do with the pen? (You can use the whiteboard in the classroom for this too, if you want.) Next, write one or two commands, and then run the program to see what happens. Write more commands, and see what happens. Once it is finished the person should look something like this: . Note: Pay attention to the direction the arrow is facing. After drawing the code that I wrote, it is facing down. That means if you turn right, it will end up facing left (because if you facing down and turn right, that’s where you end up). Exercise 3: Pen Up and Down . Next, we are going to do a bit of writing with our turtle. Create a new program, called MI.py, that writes the two capital letters “MI” next to each other. The two letters should not be touching each other. It should probably look something like this: . To do this, you can use the penup() and pendown() functions to lift up the pen after drawing the “M” and put it back down before starting the “I”. Before you can use any of the turtle commands, you need to remember to import the turtle library. Importing brings in additional functionality into python that it normally doesn’t have. The turtle library doesn’t come preloaded into Python, so we have to import it to be able to use it. To import the turtle library, put this line at the top of your program: . from turtle import * . Notice, both of the previous programs did that, too. Also, for turtle programs, it helps to end the program with done() - put it in the last line of the program. This causes the program to keep the turtle window open after it’s done drawing. Don’t forget to save this file into the git repo on your computer, so you can then add, commit, and push it to your git repository on GitLab. Exercise 4: Names, squared . For the next exercise, create a new program called names.py. This program should use the write() function to print out both your name and the name of your partner for the lab. It should also draw a red box around those names. Here is mine: . Note: you can change the color of the pen with pencolor(\"red\"). You can also change the font and size if you want to. If you want to try this, look through the turtle documentation (linked at the top of this lab) to figure out how to do it. (Hint: you can add more things inside the write() function!) . Hint: Remember to add from turtle import * to the beginning of your names.py program and done() to the end. ",
    "url": "/labs/turtle.html#draw-some-things",
    "relUrl": "/labs/turtle.html#draw-some-things"
  },"225": {
    "doc": "Lab",
    "title": "Interactive Drawing!",
    "content": "The program guestbook.py is a simple guest book app that prints out a name on the screen using Turtle. If you run it, it should print my name and move the turtle a bit. Exercise 5: Input name from user . Turtle has a function called textinput() that allows you to ask the user for a text input, which you can then save to a variable and use elsewhere. Modify the guestbook program to ask the user for their name, and then write the user’s name on the screen using Turtle underneath my name. textinput() works similarly to input(), which we’ve used in the past. But there are two main differences: . | Unlike input(), which prompts the user in the terminal, textinput() causes a window to pop up asking the user for information | Also unlike input(), textinput() needs two pieces of information: the title of the window (text that shows up at the top of the input window), and the prompt that is displayed to the user. | . For example, the code: . name2 = textinput(\"Name\", \"Please enter your name\") . would pop up a window titled “Name” and ask the user to “Please enter your name”. Whatever the user enters would be saved into the name2 variable. Exercise 6: Second Name . The guestbook should have two names in it now - my name, and then a name captured via textinput() underneath it. Now modify the guest book to ask the user for a third name, and display the third name below the second one. You’ll have to move the pen down again before writing the third name to make sure the names aren’t on top of each other. Hint: you’ll likely want to have three different variables at this point, each storing a different name. Exercise 7: Looped Guestbook . Now you should have three names in your guestbook, with the turtle moving between each name. You might have noticed that you had to repeat the move code and the input code to get it to work. When you see repeated code, that can be a good time to use a loop instead. Put the code that asks for a name, draws it, and then moves the turtle down into a loop so it will keep asking for names and then printing them out, one after the other. Hint: a while loop will probably work better than a for loop for this. Go back to the Guessing Game exercises in Lab 4 if you need a reminder on how to use while loops. Note you can end the program anytime by closing the Turtle window, so you don’t need to worry if the loop is infinite. ",
    "url": "/labs/turtle.html#interactive-drawing",
    "relUrl": "/labs/turtle.html#interactive-drawing"
  },"226": {
    "doc": "Lab",
    "title": "Seeing Stars",
    "content": "Exercise 8: Star . Create a new program called stars.py. For this program, write a program that draws a 5 pointed stars. Here’s the catch: you must you a for loop do draw the star. If you do it right, the star can be drawn using only 3 lines of code. Note: The angle at a point of a star is 144 degrees. Note 2: Drawing a star should just involve moving forward, turning 144 degrees, moving forward, turning again, and so on until the star is finished. One finished, it should look like this: . Hint: Remember to add from turtle import * to the beginning of your stars.py program and done() to the end. Exercise 9: Row of stars . Next, modify your program to use a for loop to create a row of 5 stars next to each other. You should use the same code you wrote above to draw a single star, but put it inside loop with some additional code between the stars to move the turtle to get ready to draw the next star. Exercise 10: Fill In the Stars . Modify your program to fill in the stars with a color. You can specify the fill color using the color() command. Use begin_fill() when you start drawing to begin filling in the stars, and end_fill() when you are done with what you want filled. For this exercise, fill the stars so they’re all black (color(\"black\")). Note: For some reason, on Macs, it doesn’t actually fill in the center of the star. That’s fine! . Hollow star, on a Mac . Filled star, on Windows . Exercise 11: Brightly Colored Stars . Black is boring. Make the stars brightly colored. Here’s a handy resource for colors you can use in Turtle. If you want an even broader range of colors, you can also use HTML color codes, also known as hex codes. Here’s a good color picker. Play around and find a color you and your partner both like, and make all the stars that color. Bonus: can you make the stars multiple colors? . Exercise 12: Lots of Stars . Now that you have the commands to draw a star, let’s draw lots of stars. Using nexts for loops, modify your previous program to draw 50 stars in a 10 by 5 grid. Hint: the command speed(0) will speed up the turtle drawing so you don’t have to wait as long. Hint 2: You’ll need to move the turtle in between each row of stars so it starts in the right place to draw the next row. ",
    "url": "/labs/turtle.html#seeing-stars",
    "relUrl": "/labs/turtle.html#seeing-stars"
  },"227": {
    "doc": "Lab",
    "title": "Challenges",
    "content": "If you finish all of the exercises before the end of class, try at least one of the challenges below. Challenge 1: Draw more shapes . You’ve drawn a square and a star so far. Use the turtle to draw these shapes as well: . | Pentagon (5 sides) | Hexagon (6 sides) | Octagon (8 sides) | . If you aren’t sure of the angles you need to turn the turtle in order to draw these shapes, use Google to look it up! . Challenge 2: Quit the Guestbook . Right now you can quit the guestbook by closing the Turtle window. Change the code so that the guestbook program stops taking new names when the user types “quit”. The Turtle window should still stay open. Hint: remember you can use if statements inside of while loops to check for a condition. Challenge 3: Stars on the U.S. Flag . Modify the program to create a blue background, and change the stars to be solid white. You can set the background color using bgcolor(), or by drawing a large square and filling it in with the color you want before you draw the stars. Bonus: draw the 50 stars in the pattern they appear on the US Flag. Challenge 4: Random Number of Stars . Instead of drawing a set number of stars in a set number of rows, draw a grid of stars with random dimensions using the random library. You’ll probably want to provide boundaries to the range of random numbers that are generated so you don’t accidentally draw a million rows (that would take forever!). Hint: If you need a refresher on the random library, look at the first few exercises in Lab 4. Also remember to add import random at the top of your program. ",
    "url": "/labs/turtle.html#challenges",
    "relUrl": "/labs/turtle.html#challenges"
  },"228": {
    "doc": "Lab",
    "title": "Lab",
    "content": "For this lab, we are going to use a git repository like we did for last week. The first thing you should do is fork the turtles repository (link above), add your partner, Caitlin (geierac) and Jack (waierjac) to the repository, and then clone the repository onto your computer. Refer to the Git reference if you’ve forgotten how to do this. For this lab, we will be working with turtle graphics all day. There are a LOT of commands you can use for turtle, and you don’t have to memorize them all. Instead, you can refer to the documentation: . | Turtle Documentation | . I’d recommend that the navigator (the person who isn’t driving) keep the documentation open to refer to while you work. I also strongly advise you to write your code in small chunks and test it frequently. Add one or two lines of code, and then run it to see what happens. If it’s not working, tinker with it until it does. Then add one or two more lines, run it again. And so on. The more often you run it, the more you’ll understand what it is doing and the easier it will be to troubleshoot when things go wrong. ",
    "url": "/labs/turtle.html",
    "relUrl": "/labs/turtle.html"
  },"229": {
    "doc": "Using Git",
    "title": "Forking a repository",
    "content": "For every lab, a repository will already exist with code files in it that you will use for lab exercises. You will need to make a copy of it so you can work with the files inside: only one person per pair needs to do this step. | On the GitLab repo for the lab, find the Fork button - it should be on the top right of the page. Click it. | It will ask you for a ‘namespace’: there should be only one option, with your username. If you have multiple options, make sure you choose your username as the name space. | Leave everything else on the page as-is and click the blue “Fork project” button at the bottom. | Be patient - it might take a few moments. Once the fork is complete, it will take you to the project page for your newly forked project. You’ll be able to tell because if you look at the breadcrumbs above the project name, instead of saying “MI 250 &gt; Name of Lab”, it should say your username instead of MI 250. | Add your groupmates to the project. Also add Caitlin (geierac) and Jack (waierjac). (For a reminder of how to do this, see sharing a repository with other people.) | . Note: if you get a 404 error, it’s because GitLab tried to load the repository page for your new forked repo before the fork was complete. Wait a few seconds and try reloading the page. If that doesn’t work, go to your main projects page by clicking the fox icon in the upper left and see if the project you created is in the list. ",
    "url": "/reference/using_git.html#forking-a-repository",
    "relUrl": "/reference/using_git.html#forking-a-repository"
  },"230": {
    "doc": "Using Git",
    "title": "Creating a new repository",
    "content": "For every studio, one member of your group will need to create a new repository. | From your projects page in GitLab (this is the main landing page when you first log into Gitlab), click the blue “New Project” button | Choose the “Create blank project” option | On the Create blank project page, give your project a name (Studio 3 works fine, but you can name it whatever you want). Keep all the other options on that page as-is and click the blue “Create project” button at the bottom. | Add your groupmates to the project. Also add Caitlin (geierac) and Jack (waierjac). (For a reminder of how to do this, see sharing a repository with other people.) | . ",
    "url": "/reference/using_git.html#creating-a-new-repository",
    "relUrl": "/reference/using_git.html#creating-a-new-repository"
  },"231": {
    "doc": "Using Git",
    "title": "Sharing a repository with other people",
    "content": "If you want other people to be able to see your code, you need to share the repository with them. This includes your partner or groupmates in class, and Caitlin and Jack. To share a repo, you need to add the people you want to share with as members of that repo. | Go to the main page for your project in Gitlab | In the left hand menu, find Manage (it should be near the top.) Hover over it and you’ll see a smaller menu - choose “Members” in that menu. | On the Members page, click the blue “Invite Members” button on the top right. | In the window that pops up, add each of your partners / groupmates - you can search for them using their MSU NetID (same as their MSU email). Also add Caitlin (geierac) and Jack (waierjac). Make sure to select the Maintainer role before clicking Invite at the bottom! | Everyone you added should show up on the list on the Project Members page - double check that they all have the Maintainer role. Everyone in that list will be able to see and edit your project. | . ",
    "url": "/reference/using_git.html#sharing-a-repository-with-other-people",
    "relUrl": "/reference/using_git.html#sharing-a-repository-with-other-people"
  },"232": {
    "doc": "Using Git",
    "title": "Git clone: Getting a repository onto your computer for the first time",
    "content": "Cloning a repository is always done in three steps: . | Fork the repository (you will do this for every lab) or create a new repository (for studios) | In command line, use cd to navigate to the place on your computer where you want the repository to live | Copy the https link for the respository you want to clone | Use git clone followed by the respository link to clone your repository onto your computer | . A clone command might look like this: . git clone https://gitlab.msu.edu/geierac/git-and-gitlab.git . Make sure the last part of the link matches the name of the repository you want to clone! Also make sure it’s your or your partner’s username in the middle of the link, and not MI-250. ",
    "url": "/reference/using_git.html#git-clone-getting-a-repository-onto-your-computer-for-the-first-time",
    "relUrl": "/reference/using_git.html#git-clone-getting-a-repository-onto-your-computer-for-the-first-time"
  },"233": {
    "doc": "Using Git",
    "title": "Git add, commit, push: Pushing code from your computer to GitLab",
    "content": "There are three steps to getting your code from your computer up to GitLab (or any Git repository in the cloud) - staging (add), committing, and pushing. | git add &lt;filename&gt; will add a file to the staging area - when it’s staged, it means you’ve decided you want to save those changes to the cloud version of the repository. If you made changes to a lot of files and want to save them all at once, use git add -A. | git commit -m \"&lt;your commit message&gt;\" is what you run once all the files you want to save have been staged. The commit message should say, very briefly, what changes you made and why. | git push is the final step - this command takes all of your changes and pushes them up to the cloud version of the repo. | . If any issues happen while you’re giving these commands, errors usually will show in red text in command line. You can also get an idea of where you are in the process and what you need to do next by using git status. ",
    "url": "/reference/using_git.html#git-add-commit-push-pushing-code-from-your-computer-to-gitlab",
    "relUrl": "/reference/using_git.html#git-add-commit-push-pushing-code-from-your-computer-to-gitlab"
  },"234": {
    "doc": "Using Git",
    "title": "Git pull: Pulling changes from GitLab onto your computer",
    "content": "Other people might change the code in the repository after you’ve cloned it. git clone captures a snapshot in time and saves that snapshot to your computer - it represents the state of the project at the exact time you cloned it, and it doesn’t update automatically when changes are made to GitLab. You have to pull down those changes manually. To do that, use this command: . git pull . This will pull all of the new stuff from GitLab into the version of the repo on your computer. This should be the first thing you do before you start editing. ",
    "url": "/reference/using_git.html#git-pull-pulling-changes-from-gitlab-onto-your-computer",
    "relUrl": "/reference/using_git.html#git-pull-pulling-changes-from-gitlab-onto-your-computer"
  },"235": {
    "doc": "Using Git",
    "title": "Avoiding Git conflicts",
    "content": "If multiple people are making changes to a repository at the same time, sometimes there can be conflicts. This especially happens in studios, where different people might be working on different aspects of the studio at the same time. A few tips for avoiding conflicts: . | Always use git pull before you start working on a file to make sure you have the most updated version. | When you’re done working on a file, always add, commit, and push your code to Gitlab. | For studios, talk at the beginning of class about how you might split up the work. If it makes sense to have multiple people writing code at the same time, try each using different files to work on small pieces and combining your code into one file later. Keep talking with everyone in your group so that everyone knows what the others are working on and in what files. | . Dealing with conflicts . If two people have edited the same file at the same time, this is where you will likely get a merge conflict when trying to save changes to GitLab. The person experiencing the conflict should follow these steps to merge the changes together: . | use git pull to make sure all of the latest changes are on your computer | open up the file with the conflict in your text editor. If it’s already open, close it and open it again to make sure you’re in the latest version of the file. | In the file, you should see conflict markers: these look like &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD, ========, and &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;. The code inside the markers is what’s in conflict. Edit this code to make sure it’s what you and your partner want it to look like. When you’re done, delete the conflict markers and save the file. | Use add, commit, and push like usual on the file. This should complete the merge. | . For more details, see Resolving a merge conflict using the command line. If you’ve tried to fix the conflict but it’s not working, git restore and git reset are two options to get your repository back in working order. These options will delete any changes you’ve made since the last commit. If you want to save those changes, create a new file as a temporary place to keep your code and copy and paste your changes into that file. You can move them back in later, once Git is back in order. | git restore &lt;filename&gt;: use this if you forgot to pull your partner’s changes before starting to make your own changes. This will restore the file to the last time it was committed, which will undo any changes made to it. | git reset --hard: use this if you’ve tried to commit changes already. This command will reset the local version of your repository to the last commit that went through, and will delete any changes you’ve made since then. | . If you do either of these, make sure to use git pull immediately after to make sure the respository is up to date. For more details, see Git restore and Git reset. Don’t worry if you run into a conflict; Caitlin and Jack are always around to help you resolve them! . ",
    "url": "/reference/using_git.html#avoiding-git-conflicts",
    "relUrl": "/reference/using_git.html#avoiding-git-conflicts"
  },"236": {
    "doc": "Using Git",
    "title": "Using Git",
    "content": "Working with Git and GitLab allows you to easily share your code with your partner or groupmates in labs and studio. GitLab works as cloud storage for your project, which every member of the project can then pull down onto their own computers using Git. When you’ve made the edits you want on your own version of the code, you can then push it back up to GitLab so your teammates can access it. | Forking a repository | Creating a new repository | Sharing a repository with other people | Git clone: Getting a repository onto your computer for the first time | Git add, commit, push: Pushing code from your computer to GitLab | Git pull: Pulling changes from GitLab onto your computer | Avoiding Git conflicts . | Dealing with conflicts | . | . ",
    "url": "/reference/using_git.html",
    "relUrl": "/reference/using_git.html"
  },"237": {
    "doc": "Readings",
    "title": "Readings",
    "content": "This week, the readings cover initially how to get Python to do some things, including using it as a calculator and getting it to output things. To understand the concepts, read these online book chapters: . | Think Python: The Way of the Program | Think Python: Variables, Expressions, and Statements | Automate the Boring Stuff: Python Basics | Automate the Boring Stuff: Flow Control – only the first half, stop before “For loops and the range() function” | . There is overlap in these chapters; they sometimes talk about the same things. Please read all of them. This won’t take long, and having heard the concepts in different places and in different ways will help them make more sense to you. Don’t worry if you don’t quite understand what you’ve read yet. That’s normal. ",
    "url": "/readings/variables.html#readings",
    "relUrl": "/readings/variables.html#readings"
  },"238": {
    "doc": "Readings",
    "title": "Summary",
    "content": "When writing your summary this week, think about what you learned from the readings and what did and didn’t make sense to you. In particular, think about the idea of variables. Think about things you already have experience with - classes you’ve taken, or hobbies or jobs you’ve had - and whether you’ve encountered anything similar before. Summary prompt: How would you explain what a variable is and how they are used? . ",
    "url": "/readings/variables.html#summary",
    "relUrl": "/readings/variables.html#summary"
  },"239": {
    "doc": "Readings",
    "title": "Question",
    "content": "Your question this week, and for most future weeks, can be one of three “types” of question: . | A confusion question: what are you still confused about after going through the readings? It can be confusion about a specific point or a more general confusion about the topic overall. | A curiosity question: what would you like to learn more about? The readings and/or videos may have gotten you to think about something else that is related, but not really discussed in the material that you don’t understand; that is, it got you to be curious about something else. This is a great chance to express that curiousity. | A connection might not be a question; instead, it is an example that applies the concept that your are learning to some other aspect of your life or some other interesting thing in the world. | . After reading the material, come up with one question. Caitlin will read through the questions before class starts and answer the most interesting ones at the beginning of class. NOTE: You do have to ask a question for it to count. “I have no questions” is not a question. If you can’t think of a question, think of a connection instead. Submit your summary+question on D2L under Quizzes. ",
    "url": "/readings/variables.html#question",
    "relUrl": "/readings/variables.html#question"
  },"240": {
    "doc": "Readings",
    "title": "Readings",
    "content": "In class this week we’ll be practicing using variables, and controlling the flow of programs. The readings below will help you learn about the concepts, which we’ll practice in class. Don’t worry if you don’t understand everything yet - it will start to make more sense once you get a chance to practice. ",
    "url": "/readings/variables.html",
    "relUrl": "/readings/variables.html"
  },"241": {
    "doc": "Readings",
    "title": "Readings",
    "content": "Some of these readings get in the weeds about using Git - don’t worry if you don’t understand everything. We’ll be practicing in class this week. | What is Version Control? | Git Handbook | Saving Changes in Git | Getting Changes from a Remote Repository | . ",
    "url": "/readings/version_control.html#readings",
    "relUrl": "/readings/version_control.html#readings"
  },"242": {
    "doc": "Readings",
    "title": "Summary",
    "content": "When writing your summary this week, think about the kinds of tools you’ve used to collaborate with classmates in the past. What did you read about version control that sounded similar to other tools you’ve used? What was new to you about it? . Summary prompt: Why do we need version control, and how is it different than how I’ve shared work with group members in the past? . ",
    "url": "/readings/version_control.html#summary",
    "relUrl": "/readings/version_control.html#summary"
  },"243": {
    "doc": "Readings",
    "title": "Question",
    "content": "As per usual, your question can be one of three types: . | Confusion: what didn’t you understand in the readings? | Curiousity: what do you want to know more about? | Connection: how does this topic connect to your own experiences? | . Submit your summary+question on D2L under Quizzes before class starts on Tuesday. ",
    "url": "/readings/version_control.html#question",
    "relUrl": "/readings/version_control.html#question"
  },"244": {
    "doc": "Readings",
    "title": "Readings",
    "content": "From here on out, you’ll be using something called version control to collaborate with partners in class and to turn in code. Version control allows programmers to keep track of their code and to collaborate with other programmers more easily. The type of version control we’ll be using is called Git. We’ll be using it alongsize Gitlab, which is kind of like Google Docs except specifically for storing code. Gitlab is where you’ll turn in your code from now on. Note: Some of these readings talk about Github, which we won’t be using. We’re using Gitlab instead. Gitlab and Github are two different variations on the same thing - they’re run by different companies, but they do the same thing, which is allow people to store coding projects in the cloud. We use Gitlab for this class because MSU runs an MSU-specific Gitlab server that all students can use for free. ",
    "url": "/readings/version_control.html",
    "relUrl": "/readings/version_control.html"
  },"245": {
    "doc": "Studio",
    "title": "Advice",
    "content": "Create text files . Most of the text you find online are in Word files or google docs or web pages. Your program only needs to work with text files – files that contain nothing but plain text. No formatting, no colors, not pages, nothing but text. Your code that you edit in Atom is a text file. I recommend you start by finding a couple of things that you want to look at a word cloud for. Copy-and-paste the texts into files in your text editor (like Atom, or Notepad) and save it as a plain text file (.txt), in the same directory as your word cloud program. That way, you can easily run your program on these different files to try it out. A great place to start is song lyrics. Pick a song you like, google for the lyrics, and then save those lyrics into a text file. Another alternative is to pick an old book or play. You can find plain text copies of Shakespeare’s plays on Project Gutenberg. Just do a word list to start . There are many ways to display your word cloud. A cloud representation is pretty normal, but it is hard to know where to put the words. You don’t need to get something that complicated working. Instead, try something simpler. You could just display words in order. That visualization just puts common words in alphabetical order, and makes the words bigger that appear more often. You can even go simpler than that, and start with a single list of words, with more common words bigger: . A word is as big vertically as you tell it . When you use write() with turtle graphics, you can tell it a font size. That font size is approximately how big, vertically, the word is. So if you tell it to write the word with a size of 20, then you can go down one line by moving the turtle down 20 steps. This is really handy to know when making the word list, and it is what I did to make that word list above. You can tell write to move the pen horizontally . By default, when you use write() to put some text on the screen, the turtle doesn’t move. It stays right where it is, and puts the text there. However, you can tell the turtle to move with the text, so the turtle ends up to the right of the text instead of where it started on the left. To do so, you just say move=True: . write(\"Hello\", font=(\"Arial\", 20, \"normal\"), move=True) . This is really useful if you want to put the words horizontally next to each other. Count words . We have worked with code that counts letters or words in a string multiple times. You wrote word counting code in this week’s lab. I wrote some code to do this back in Week 10’s lab about reading code. Basically, you create a dictionary where words are the keys and the count – the number of times the word appears – is the value. You split the string into words using .split(), and then you look up each word you find and add 1 to the count as you loop through each word. If you didn’t finish this week’s lab, I recommend going back through with your group and trying to get through as much as you can. OR, alternatively, you can use the code I wrote for the reading code lab, but you’ll need to understand how it works to use it. Read in Whole Files . In this week’s lab, you learned how to read in a file one line at a time. You can read in a single line of a file using f.readline(), or you can do it in a loop by using for line in f. However, sometimes, you don’t want to read it in one line at a time. Instead, you want to read the whole file in at once and store its contents in a string. You can do this with f.read(). f.read() reads the whole file in at once, and stores it in a python string. You’ll want to remember to save that string to a variable: str = f.read(). Also, remember that this only works after you’ve already opened the file with open(). Sort words . The first challenge from this week’s lab describes how to sort dictionaries. Actually, you can’t sort a dictionary, but you can loop through the dictionary in sorted order. You can use this to go through the dictionary with the most frequent words first (or last, depending on what you want). ",
    "url": "/studios/wordcloud.html#advice",
    "relUrl": "/studios/wordcloud.html#advice"
  },"246": {
    "doc": "Studio",
    "title": "Challenges",
    "content": "If you get a basic word cloud display working, first try it on different texts. See what works well and what doesn’t. Remove stopwords . It won’t surprise you that the most common words in English are really boring – “the”, “a”, “is”, etc. It isn’t very interesting to have a word cloud where the biggest words are those really common words. It is much more interesting to see which of the less common words appear frequently in a text. Make a list of “stopwords” – common words that aren’t interesting that you want to remove. Then modify your program to remove stopwords from your list so they don’t get displayed, and it only displays the more interesting words. Layout . Try different ways of laying things out. You can make things a vertical list. You can move around in a circle. You can put words horizontally, and then wrap when it gets past a certain part of the screen. You can put words in alphabetical order. You can sort the words and put the most common one first. You can put longer words first and shorter words later (len(word) will calculate the length of a word). Try making the words different colors. Try different layouts and and see which one(s) you like better. There is no right answer; different layouts might be useful in different situations. As you create more than one layout, make each layout a separate function. That way, you can just call a different function to get a different layout, and it is easy to go back to a previous layout. Automatic rescaling . As you try your word cloud program on different texts, you will find that some longer texts end up with really big words, and some shorter texts have only small words. Try to add a calculation that figures out what the most common word is, and then figures out how big that word should be. Then rescale all of the words relative to that, so that what is important is not how many times a word was mentioned, but how much more or less often a word was mentioned. Add visual design . A word cloud frequently only has words on it – but it doesn’t have to. You can put other designs on the word cloud. Circle the biggest word? Underline words with more than 20 mentions? Draw a cloud around the whole thing? Make it look interesting. Fonts . You can also vary the fonts. You can use the same font for everything, to make it look nice. Or you can change words into different fonts to emphasize some words over others. Here is a program that you can run to get a list of all the fonts available on your computer. Color . You can also vary the colors used. For example, many word clouds use different shades of the same color to indicate different ranges of frequencies. Instead of using the same color for everything, can you make different words have different colors? What might the colors mean? . ",
    "url": "/studios/wordcloud.html#challenges",
    "relUrl": "/studios/wordcloud.html#challenges"
  },"247": {
    "doc": "Studio",
    "title": "Studio",
    "content": "A word cloud is a way of visualizing some text. If you have some text – like a song, a speech, or a document – you can use the word cloud to see approximately what that text is about and what kinds of things are being talked about. Word clouds show words on the screen, where a word is bigger if it appears more often in the text, and the word is smaller if it appears less often. Your goal today is to write a program that reads in a text file, calculates how often each word appears in that file, and then finds an intersting way to display the common words on the screen using turtle graphics. Work in teams of 2-4 people. That’s it. That’s the whole of the instructions – form a group, write the three parts of the program, and then use the program to create word clouds. Be creative in how you display the word cloud. Try the program on different files and see if you can get it to work for different texts. Have fun with it. Here’s an example word cloud: . And another showing the world population by country: . What follows is just advice for doing it. You don’t have to follow my advice. Do whatever you want. This is just my experience in doing this, and you might want to do it differently. ",
    "url": "/studios/wordcloud.html",
    "relUrl": "/studios/wordcloud.html"
  }
}
